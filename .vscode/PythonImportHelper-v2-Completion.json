[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "getLogger",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "getLogger",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "getLogger",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "PathLike",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "PathLike",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "PathLike",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF8",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF16_BE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF16_LE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_BE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_LE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF8",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF16_BE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF16_LE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_BE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_LE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF8",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF16_BE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF16_LE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_BE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF32_LE",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "aliases",
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "isExtraImport": true,
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "IGNORECASE",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "compile",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sub",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "findall",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "IGNORECASE",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "compile",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sub",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "findall",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "IGNORECASE",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "compile",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sub",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "findall",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "importPath": "warnings",
        "description": "warnings",
        "isExtraImport": true,
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha256",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha256",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha256",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "# type: ignore[import-not-found",
        "importPath": "_multibytecodec",
        "description": "_multibytecodec",
        "isExtraImport": true,
        "detail": "_multibytecodec",
        "documentation": {}
    },
    {
        "label": "import]\n    MultibyteIncrementalDecoder",
        "importPath": "_multibytecodec",
        "description": "_multibytecodec",
        "isExtraImport": true,
        "detail": "_multibytecodec",
        "documentation": {}
    },
    {
        "label": "# type: ignore[import-not-found",
        "importPath": "_multibytecodec",
        "description": "_multibytecodec",
        "isExtraImport": true,
        "detail": "_multibytecodec",
        "documentation": {}
    },
    {
        "label": "import]\n    MultibyteIncrementalDecoder",
        "importPath": "_multibytecodec",
        "description": "_multibytecodec",
        "isExtraImport": true,
        "detail": "_multibytecodec",
        "documentation": {}
    },
    {
        "label": "# type: ignore[import-not-found",
        "importPath": "_multibytecodec",
        "description": "_multibytecodec",
        "isExtraImport": true,
        "detail": "_multibytecodec",
        "documentation": {}
    },
    {
        "label": "import]\n    MultibyteIncrementalDecoder",
        "importPath": "_multibytecodec",
        "description": "_multibytecodec",
        "isExtraImport": true,
        "detail": "_multibytecodec",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "socket",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "getdefaulttimeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "socket",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "getdefaulttimeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "socket",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "getdefaulttimeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "timeout",
        "importPath": "socket",
        "description": "socket",
        "isExtraImport": true,
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "ClosedPoolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationValueError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "MaxRetryError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NewConnectionError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DecodeError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ClosedPoolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationValueError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "MaxRetryError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NewConnectionError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DecodeError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ClosedPoolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationValueError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "MaxRetryError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NewConnectionError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DecodeError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "PoolManager",
        "importPath": "urllib3.poolmanager",
        "description": "urllib3.poolmanager",
        "isExtraImport": true,
        "detail": "urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "proxy_from_url",
        "importPath": "urllib3.poolmanager",
        "description": "urllib3.poolmanager",
        "isExtraImport": true,
        "detail": "urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "PoolManager",
        "importPath": "urllib3.poolmanager",
        "description": "urllib3.poolmanager",
        "isExtraImport": true,
        "detail": "urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "proxy_from_url",
        "importPath": "urllib3.poolmanager",
        "description": "urllib3.poolmanager",
        "isExtraImport": true,
        "detail": "urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "PoolManager",
        "importPath": "urllib3.poolmanager",
        "description": "urllib3.poolmanager",
        "isExtraImport": true,
        "detail": "urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "proxy_from_url",
        "importPath": "urllib3.poolmanager",
        "description": "urllib3.poolmanager",
        "isExtraImport": true,
        "detail": "urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "make_headers",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "retry",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "make_headers",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "retry",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "make_headers",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "retry",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "Retry",
        "importPath": "urllib3.util.retry",
        "description": "urllib3.util.retry",
        "isExtraImport": true,
        "detail": "urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry",
        "importPath": "urllib3.util.retry",
        "description": "urllib3.util.retry",
        "isExtraImport": true,
        "detail": "urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry",
        "importPath": "urllib3.util.retry",
        "description": "urllib3.util.retry",
        "isExtraImport": true,
        "detail": "urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "where",
        "importPath": "certifi",
        "description": "certifi",
        "isExtraImport": true,
        "detail": "certifi",
        "documentation": {}
    },
    {
        "label": "where",
        "importPath": "certifi",
        "description": "certifi",
        "isExtraImport": true,
        "detail": "certifi",
        "documentation": {}
    },
    {
        "label": "where",
        "importPath": "certifi",
        "description": "certifi",
        "isExtraImport": true,
        "detail": "certifi",
        "documentation": {}
    },
    {
        "label": "urllib3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib3",
        "description": "urllib3",
        "detail": "urllib3",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "urllib3",
        "description": "urllib3",
        "isExtraImport": true,
        "detail": "urllib3",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "urllib3",
        "description": "urllib3",
        "isExtraImport": true,
        "detail": "urllib3",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "urllib3",
        "description": "urllib3",
        "isExtraImport": true,
        "detail": "urllib3",
        "documentation": {}
    },
    {
        "label": "collections.abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections.abc",
        "description": "collections.abc",
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "cookiejar",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "cookiejar",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "cookiejar",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "Morsel",
        "importPath": "http.cookies",
        "description": "http.cookies",
        "isExtraImport": true,
        "detail": "http.cookies",
        "documentation": {}
    },
    {
        "label": "Morsel",
        "importPath": "http.cookies",
        "description": "http.cookies",
        "isExtraImport": true,
        "detail": "http.cookies",
        "documentation": {}
    },
    {
        "label": "Morsel",
        "importPath": "http.cookies",
        "description": "http.cookies",
        "isExtraImport": true,
        "detail": "http.cookies",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "UnsupportedOperation",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "IOBase",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "UnsupportedOperation",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "IOBase",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "UnsupportedOperation",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "IOBase",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BufferedReader",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote_plus",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote_plus",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urldefrag",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlencode",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlsplit",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlunparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlencode",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "parse_qs",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote_plus",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote_plus",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urldefrag",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlencode",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlsplit",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlunparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlencode",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "parse_qs",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote_plus",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote_plus",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urldefrag",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlencode",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlsplit",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlunparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlencode",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "parse_qs",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "getproxies",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "getproxies_environment",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "parse_http_list",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "proxy_bypass",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "proxy_bypass_environment",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "getproxies",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "getproxies_environment",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "parse_http_list",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "proxy_bypass",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "proxy_bypass_environment",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "getproxies",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "getproxies_environment",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "parse_http_list",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "proxy_bypass",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "proxy_bypass_environment",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "calendar",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "calendar",
        "description": "calendar",
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "ssl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ssl",
        "description": "ssl",
        "detail": "ssl",
        "documentation": {}
    },
    {
        "label": "idna",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "idna",
        "description": "idna",
        "detail": "idna",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "encodings.idna",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "encodings.idna",
        "description": "encodings.idna",
        "detail": "encodings.idna",
        "documentation": {}
    },
    {
        "label": "RequestField",
        "importPath": "urllib3.fields",
        "description": "urllib3.fields",
        "isExtraImport": true,
        "detail": "urllib3.fields",
        "documentation": {}
    },
    {
        "label": "RequestField",
        "importPath": "urllib3.fields",
        "description": "urllib3.fields",
        "isExtraImport": true,
        "detail": "urllib3.fields",
        "documentation": {}
    },
    {
        "label": "RequestField",
        "importPath": "urllib3.fields",
        "description": "urllib3.fields",
        "isExtraImport": true,
        "detail": "urllib3.fields",
        "documentation": {}
    },
    {
        "label": "encode_multipart_formdata",
        "importPath": "urllib3.filepost",
        "description": "urllib3.filepost",
        "isExtraImport": true,
        "detail": "urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "encode_multipart_formdata",
        "importPath": "urllib3.filepost",
        "description": "urllib3.filepost",
        "isExtraImport": true,
        "detail": "urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "encode_multipart_formdata",
        "importPath": "urllib3.filepost",
        "description": "urllib3.filepost",
        "isExtraImport": true,
        "detail": "urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "http.client",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "http.client",
        "description": "http.client",
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "ResponseNotReady",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPConnection",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "ResponseNotReady",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "IncompleteRead",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPMessage",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPResponse",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "ResponseNotReady",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPConnection",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "ResponseNotReady",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "IncompleteRead",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPMessage",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPResponse",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "ResponseNotReady",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPConnection",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "ResponseNotReady",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "IncompleteRead",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPMessage",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPResponse",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "email.parser",
        "description": "email.parser",
        "isExtraImport": true,
        "detail": "email.parser",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "email.parser",
        "description": "email.parser",
        "isExtraImport": true,
        "detail": "email.parser",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "email.parser",
        "description": "email.parser",
        "isExtraImport": true,
        "detail": "email.parser",
        "documentation": {}
    },
    {
        "label": "files",
        "importPath": "importlib.resources",
        "description": "importlib.resources",
        "isExtraImport": true,
        "detail": "importlib.resources",
        "documentation": {}
    },
    {
        "label": "files",
        "importPath": "importlib.resources",
        "description": "importlib.resources",
        "isExtraImport": true,
        "detail": "importlib.resources",
        "documentation": {}
    },
    {
        "label": "files",
        "importPath": "importlib.resources",
        "description": "importlib.resources",
        "isExtraImport": true,
        "detail": "importlib.resources",
        "documentation": {}
    },
    {
        "label": "js",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "js",
        "description": "js",
        "detail": "js",
        "documentation": {}
    },
    {
        "label": "# type: ignore[import-not-found]\n    JsArray",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "JsException",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "JsProxy",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "to_js",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "# type: ignore[import-not-found]\n    JsArray",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "JsException",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "JsProxy",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "to_js",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "# type: ignore[import-not-found]\n    JsArray",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "JsException",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "JsProxy",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "to_js",
        "importPath": "pyodide.ffi",
        "description": "pyodide.ffi",
        "isExtraImport": true,
        "detail": "pyodide.ffi",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "OpenSSL.SSL",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "OpenSSL.SSL",
        "description": "OpenSSL.SSL",
        "detail": "OpenSSL.SSL",
        "documentation": {}
    },
    {
        "label": "x509",
        "importPath": "cryptography",
        "description": "cryptography",
        "isExtraImport": true,
        "detail": "cryptography",
        "documentation": {}
    },
    {
        "label": "x509",
        "importPath": "cryptography",
        "description": "cryptography",
        "isExtraImport": true,
        "detail": "cryptography",
        "documentation": {}
    },
    {
        "label": "x509",
        "importPath": "cryptography",
        "description": "cryptography",
        "isExtraImport": true,
        "detail": "cryptography",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "h2.config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h2.config",
        "description": "h2.config",
        "detail": "h2.config",
        "documentation": {}
    },
    {
        "label": "h2.connection",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h2.connection",
        "description": "h2.connection",
        "detail": "h2.connection",
        "documentation": {}
    },
    {
        "label": "h2.events",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h2.events",
        "description": "h2.events",
        "detail": "h2.events",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "MultipartInvariantViolationDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "StartBoundaryNotFoundDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "MessageDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "MultipartInvariantViolationDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "StartBoundaryNotFoundDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "MessageDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "MultipartInvariantViolationDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "StartBoundaryNotFoundDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "MessageDefect",
        "importPath": "email.errors",
        "description": "email.errors",
        "isExtraImport": true,
        "detail": "email.errors",
        "documentation": {}
    },
    {
        "label": "email",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "email",
        "description": "email",
        "detail": "email",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "takewhile",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "takewhile",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "takewhile",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "hmac",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hmac",
        "description": "hmac",
        "detail": "hmac",
        "documentation": {}
    },
    {
        "label": "binascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii",
        "description": "binascii",
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "unhexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "unhexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "unhexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "ipaddress",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ipaddress",
        "description": "ipaddress",
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "IPv4Address",
        "importPath": "ipaddress",
        "description": "ipaddress",
        "isExtraImport": true,
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "IPv6Address",
        "importPath": "ipaddress",
        "description": "ipaddress",
        "isExtraImport": true,
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "IPv4Address",
        "importPath": "ipaddress",
        "description": "ipaddress",
        "isExtraImport": true,
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "IPv6Address",
        "importPath": "ipaddress",
        "description": "ipaddress",
        "isExtraImport": true,
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "IPv4Address",
        "importPath": "ipaddress",
        "description": "ipaddress",
        "isExtraImport": true,
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "IPv6Address",
        "importPath": "ipaddress",
        "description": "ipaddress",
        "isExtraImport": true,
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "select",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "select",
        "description": "select",
        "detail": "select",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "email.utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "email.utils",
        "description": "email.utils",
        "detail": "email.utils",
        "documentation": {}
    },
    {
        "label": "mimetypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mimetypes",
        "description": "mimetypes",
        "detail": "mimetypes",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Clamped",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Inexact",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Overflow",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Rounded",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Underflow",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Clamped",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Inexact",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Overflow",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Rounded",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Underflow",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Clamped",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Inexact",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Overflow",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Rounded",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Underflow",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "requests",
        "description": "requests",
        "isExtraImport": true,
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "requests",
        "description": "requests",
        "isExtraImport": true,
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "requests",
        "description": "requests",
        "isExtraImport": true,
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "zcatalyst_sdk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zcatalyst_sdk",
        "description": "zcatalyst_sdk",
        "detail": "zcatalyst_sdk",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "zcatalyst_sdk",
        "description": "zcatalyst_sdk",
        "isExtraImport": true,
        "detail": "zcatalyst_sdk",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "zcatalyst_sdk",
        "description": "zcatalyst_sdk",
        "isExtraImport": true,
        "detail": "zcatalyst_sdk",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "zcatalyst_sdk",
        "description": "zcatalyst_sdk",
        "isExtraImport": true,
        "detail": "zcatalyst_sdk",
        "documentation": {}
    },
    {
        "label": "QuickMLError",
        "importPath": "zcatalyst_sdk.exceptions",
        "description": "zcatalyst_sdk.exceptions",
        "isExtraImport": true,
        "detail": "zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "QuickMLError",
        "importPath": "zcatalyst_sdk.exceptions",
        "description": "zcatalyst_sdk.exceptions",
        "isExtraImport": true,
        "detail": "zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "QuickMLError",
        "importPath": "zcatalyst_sdk.exceptions",
        "description": "zcatalyst_sdk.exceptions",
        "isExtraImport": true,
        "detail": "zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "make_response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "make_response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "make_response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "make_response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "make_response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "make_response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "exit_cacert_ctx",
        "kind": 2,
        "importPath": ".build.functions.exams.certifi.core",
        "description": ".build.functions.exams.certifi.core",
        "peekOfCode": "def exit_cacert_ctx() -> None:\n    _CACERT_CTX.__exit__(None, None, None)  # type: ignore[union-attr]\nif sys.version_info >= (3, 11):\n    from importlib.resources import as_file, files\n    _CACERT_CTX = None\n    _CACERT_PATH = None\n    def where() -> str:\n        # This is slightly terrible, but we want to delay extracting the file\n        # in cases where we're inside of a zipimport situation until someone\n        # actually calls where(), but we don't want to re-extract the file",
        "detail": ".build.functions.exams.certifi.core",
        "documentation": {}
    },
    {
        "label": "from_bytes",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.api",
        "description": ".build.functions.exams.charset_normalizer.api",
        "peekOfCode": "def from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.exams.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "from_fp",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.api",
        "description": ".build.functions.exams.charset_normalizer.api",
        "peekOfCode": "def from_fp(\n    fp: BinaryIO,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.exams.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "from_path",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.api",
        "description": ".build.functions.exams.charset_normalizer.api",
        "peekOfCode": "def from_path(\n    path: str | bytes | PathLike,  # type: ignore[type-arg]\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.exams.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "is_binary",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.api",
        "description": ".build.functions.exams.charset_normalizer.api",
        "peekOfCode": "def is_binary(\n    fp_or_path_or_payload: PathLike | str | BinaryIO | bytes,  # type: ignore[type-arg]\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.exams.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.api",
        "description": ".build.functions.exams.charset_normalizer.api",
        "peekOfCode": "logger = logging.getLogger(\"charset_normalizer\")\nexplain_handler = logging.StreamHandler()\nexplain_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s | %(levelname)s | %(message)s\")\n)\ndef from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,",
        "detail": ".build.functions.exams.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "explain_handler",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.api",
        "description": ".build.functions.exams.charset_normalizer.api",
        "peekOfCode": "explain_handler = logging.StreamHandler()\nexplain_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s | %(levelname)s | %(message)s\")\n)\ndef from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,\n    cp_isolation: list[str] | None = None,",
        "detail": ".build.functions.exams.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "encoding_unicode_range",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def encoding_unicode_range(iana_name: str) -> list[str]:\n    \"\"\"\n    Return associated unicode ranges in a single byte code page.\n    \"\"\"\n    if is_multi_byte_encoding(iana_name):\n        raise OSError(\"Function not supported on multi-byte code page\")\n    decoder = importlib.import_module(f\"encodings.{iana_name}\").IncrementalDecoder\n    p: IncrementalDecoder = decoder(errors=\"ignore\")\n    seen_ranges: dict[str, int] = {}\n    character_count: int = 0",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "unicode_range_languages",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def unicode_range_languages(primary_range: str) -> list[str]:\n    \"\"\"\n    Return inferred languages used with a unicode range.\n    \"\"\"\n    languages: list[str] = []\n    for language, characters in FREQUENCIES.items():\n        for character in characters:\n            if unicode_range(character) == primary_range:\n                languages.append(language)\n                break",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "encoding_languages",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def encoding_languages(iana_name: str) -> list[str]:\n    \"\"\"\n    Single-byte encoding language association. Some code page are heavily linked to particular language(s).\n    This function does the correspondence.\n    \"\"\"\n    unicode_ranges: list[str] = encoding_unicode_range(iana_name)\n    primary_range: str | None = None\n    for specified_range in unicode_ranges:\n        if \"Latin\" not in specified_range:\n            primary_range = specified_range",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "mb_encoding_languages",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def mb_encoding_languages(iana_name: str) -> list[str]:\n    \"\"\"\n    Multi-byte encoding language association. Some code page are heavily linked to particular language(s).\n    This function does the correspondence.\n    \"\"\"\n    if (\n        iana_name.startswith(\"shift_\")\n        or iana_name.startswith(\"iso2022_jp\")\n        or iana_name.startswith(\"euc_j\")\n        or iana_name == \"cp932\"",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "get_target_features",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def get_target_features(language: str) -> tuple[bool, bool]:\n    \"\"\"\n    Determine main aspects from a supported language if it contains accents and if is pure Latin.\n    \"\"\"\n    target_have_accents: bool = False\n    target_pure_latin: bool = True\n    for character in FREQUENCIES[language]:\n        if not target_have_accents and is_accentuated(character):\n            target_have_accents = True\n        if target_pure_latin and is_latin(character) is False:",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "alphabet_languages",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def alphabet_languages(\n    characters: list[str], ignore_non_latin: bool = False\n) -> list[str]:\n    \"\"\"\n    Return associated languages associated to given characters.\n    \"\"\"\n    languages: list[tuple[str, float]] = []\n    source_have_accents = any(is_accentuated(character) for character in characters)\n    for language, language_characters in FREQUENCIES.items():\n        target_have_accents, target_pure_latin = get_target_features(language)",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "characters_popularity_compare",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def characters_popularity_compare(\n    language: str, ordered_characters: list[str]\n) -> float:\n    \"\"\"\n    Determine if a ordered characters list (by occurrence from most appearance to rarest) match a particular language.\n    The result is a ratio between 0. (absolutely no correspondence) and 1. (near perfect fit).\n    Beware that is function is not strict on the match in order to ease the detection. (Meaning close match is 1.)\n    \"\"\"\n    if language not in FREQUENCIES:\n        raise ValueError(f\"{language} not available\")",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "alpha_unicode_split",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def alpha_unicode_split(decoded_sequence: str) -> list[str]:\n    \"\"\"\n    Given a decoded text sequence, return a list of str. Unicode range / alphabet separation.\n    Ex. a text containing English/Latin with a bit a Hebrew will return two items in the resulting list;\n    One containing the latin letters and the other hebrew.\n    \"\"\"\n    layers: dict[str, str] = {}\n    for character in decoded_sequence:\n        if character.isalpha() is False:\n            continue",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "merge_coherence_ratios",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def merge_coherence_ratios(results: list[CoherenceMatches]) -> CoherenceMatches:\n    \"\"\"\n    This function merge results previously given by the function coherence_ratio.\n    The return type is the same as coherence_ratio.\n    \"\"\"\n    per_language_ratios: dict[str, list[float]] = {}\n    for result in results:\n        for sub_result in result:\n            language, ratio = sub_result\n            if language not in per_language_ratios:",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "filter_alt_coherence_matches",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def filter_alt_coherence_matches(results: CoherenceMatches) -> CoherenceMatches:\n    \"\"\"\n    We shall NOT return \"English\" in CoherenceMatches because it is an alternative\n    of \"English\". This function only keeps the best match and remove the em-dash in it.\n    \"\"\"\n    index_results: dict[str, list[float]] = dict()\n    for result in results:\n        language, ratio = result\n        no_em_name: str = language.replace(\"\", \"\")\n        if no_em_name not in index_results:",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "coherence_ratio",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.cd",
        "description": ".build.functions.exams.charset_normalizer.cd",
        "peekOfCode": "def coherence_ratio(\n    decoded_sequence: str, threshold: float = 0.1, lg_inclusion: str | None = None\n) -> CoherenceMatches:\n    \"\"\"\n    Detect ANY language that can be identified in given sequence. The sequence will be analysed by layers.\n    A layer = Character extraction by alphabets/ranges.\n    \"\"\"\n    results: list[tuple[str, float]] = []\n    ignore_non_latin: bool = False\n    sufficient_match_count: int = 0",
        "detail": ".build.functions.exams.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "RE_POSSIBLE_ENCODING_INDICATION",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.constant",
        "description": ".build.functions.exams.charset_normalizer.constant",
        "peekOfCode": "RE_POSSIBLE_ENCODING_INDICATION = re_compile(\n    r\"(?:(?:encoding)|(?:charset)|(?:coding))(?:[\\:= ]{1,10})(?:[\\\"\\']?)([a-zA-Z0-9\\-_]+)(?:[\\\"\\']?)\",\n    IGNORECASE,\n)\nIANA_NO_ALIASES = [\n    \"cp720\",\n    \"cp737\",\n    \"cp856\",\n    \"cp874\",\n    \"cp875\",",
        "detail": ".build.functions.exams.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "IANA_NO_ALIASES",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.constant",
        "description": ".build.functions.exams.charset_normalizer.constant",
        "peekOfCode": "IANA_NO_ALIASES = [\n    \"cp720\",\n    \"cp737\",\n    \"cp856\",\n    \"cp874\",\n    \"cp875\",\n    \"cp1006\",\n    \"koi8_r\",\n    \"koi8_t\",\n    \"koi8_u\",",
        "detail": ".build.functions.exams.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_CHINESE_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.constant",
        "description": ".build.functions.exams.charset_normalizer.constant",
        "peekOfCode": "COMMON_CHINESE_CHARACTERS = \"\"\nCOMMON_JAPANESE_CHARACTERS = \"\"\nCOMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,",
        "detail": ".build.functions.exams.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_JAPANESE_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.constant",
        "description": ".build.functions.exams.charset_normalizer.constant",
        "peekOfCode": "COMMON_JAPANESE_CHARACTERS = \"\"\nCOMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]",
        "detail": ".build.functions.exams.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_KOREAN_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.constant",
        "description": ".build.functions.exams.charset_normalizer.constant",
        "peekOfCode": "COMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]\n    )",
        "detail": ".build.functions.exams.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_CJK_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.constant",
        "description": ".build.functions.exams.charset_normalizer.constant",
        "peekOfCode": "COMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]\n    )\n)\nKO_NAMES: set[str] = {\"johab\", \"cp949\", \"euc_kr\"}",
        "detail": ".build.functions.exams.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "detect",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.legacy",
        "description": ".build.functions.exams.charset_normalizer.legacy",
        "peekOfCode": "def detect(\n    byte_str: bytes, should_rename_legacy: bool = False, **kwargs: Any\n) -> ResultDict:\n    \"\"\"\n    chardet legacy method\n    Detect the encoding of the given byte string. It should be mostly backward-compatible.\n    Encoding name will match Chardet own writing whenever possible. (Not on encoding name unsupported by it)\n    This function is deprecated and should be used to migrate your project easily, consult the documentation for\n    further information. Not planned for removal.\n    :param byte_str:     The byte sequence to examine.",
        "detail": ".build.functions.exams.charset_normalizer.legacy",
        "documentation": {}
    },
    {
        "label": "MessDetectorPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class MessDetectorPlugin:\n    \"\"\"\n    Base abstract class used for mess detection plugins.\n    All detectors MUST extend and implement given methods.\n    \"\"\"\n    def eligible(self, character: str) -> bool:\n        \"\"\"\n        Determine if given character should be fed in.\n        \"\"\"\n        raise NotImplementedError  # pragma: nocover",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "TooManySymbolOrPunctuationPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class TooManySymbolOrPunctuationPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._punctuation_count: int = 0\n        self._symbol_count: int = 0\n        self._character_count: int = 0\n        self._last_printable_char: str | None = None\n        self._frenzy_symbol_in_word: bool = False\n    def eligible(self, character: str) -> bool:\n        return character.isprintable()\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "TooManyAccentuatedPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class TooManyAccentuatedPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._accentuated_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return character.isalpha()\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if is_accentuated(character):\n            self._accentuated_count += 1",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "UnprintablePlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class UnprintablePlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._unprintable_count: int = 0\n        self._character_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return True\n    def feed(self, character: str) -> None:\n        if is_unprintable(character):\n            self._unprintable_count += 1\n        self._character_count += 1",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuspiciousDuplicateAccentPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class SuspiciousDuplicateAccentPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._successive_count: int = 0\n        self._character_count: int = 0\n        self._last_latin_character: str | None = None\n    def eligible(self, character: str) -> bool:\n        return character.isalpha() and is_latin(character)\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if (",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuspiciousRange",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class SuspiciousRange(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._suspicious_successive_range_count: int = 0\n        self._character_count: int = 0\n        self._last_printable_seen: str | None = None\n    def eligible(self, character: str) -> bool:\n        return character.isprintable()\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if (",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuperWeirdWordPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class SuperWeirdWordPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._word_count: int = 0\n        self._bad_word_count: int = 0\n        self._foreign_long_count: int = 0\n        self._is_current_word_bad: bool = False\n        self._foreign_long_watch: bool = False\n        self._character_count: int = 0\n        self._bad_character_count: int = 0\n        self._buffer: str = \"\"",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "CjkUncommonPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class CjkUncommonPlugin(MessDetectorPlugin):\n    \"\"\"\n    Detect messy CJK text that probably means nothing.\n    \"\"\"\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._uncommon_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return is_cjk(character)\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "ArchaicUpperLowerPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class ArchaicUpperLowerPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._buf: bool = False\n        self._character_count_since_last_sep: int = 0\n        self._successive_upper_lower_count: int = 0\n        self._successive_upper_lower_count_final: int = 0\n        self._character_count: int = 0\n        self._last_alpha_seen: str | None = None\n        self._current_ascii_only: bool = True\n    def eligible(self, character: str) -> bool:",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "ArabicIsolatedFormPlugin",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "class ArabicIsolatedFormPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._isolated_form_count: int = 0\n    def reset(self) -> None:  # Abstract\n        self._character_count = 0\n        self._isolated_form_count = 0\n    def eligible(self, character: str) -> bool:\n        return is_arabic(character)\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "is_suspiciously_successive_range",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "def is_suspiciously_successive_range(\n    unicode_range_a: str | None, unicode_range_b: str | None\n) -> bool:\n    \"\"\"\n    Determine if two Unicode range seen next to each other can be considered as suspicious.\n    \"\"\"\n    if unicode_range_a is None or unicode_range_b is None:\n        return True\n    if unicode_range_a == unicode_range_b:\n        return False",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "mess_ratio",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.md",
        "description": ".build.functions.exams.charset_normalizer.md",
        "peekOfCode": "def mess_ratio(\n    decoded_sequence: str, maximum_threshold: float = 0.2, debug: bool = False\n) -> float:\n    \"\"\"\n    Compute a mess ratio given a decoded bytes sequence. The maximum threshold does stop the computation earlier.\n    \"\"\"\n    detectors: list[MessDetectorPlugin] = [\n        md_class() for md_class in MessDetectorPlugin.__subclasses__()\n    ]\n    length: int = len(decoded_sequence) + 1",
        "detail": ".build.functions.exams.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "CharsetMatch",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.models",
        "description": ".build.functions.exams.charset_normalizer.models",
        "peekOfCode": "class CharsetMatch:\n    def __init__(\n        self,\n        payload: bytes,\n        guessed_encoding: str,\n        mean_mess_ratio: float,\n        has_sig_or_bom: bool,\n        languages: CoherenceMatches,\n        decoded_payload: str | None = None,\n        preemptive_declaration: str | None = None,",
        "detail": ".build.functions.exams.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CharsetMatches",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.models",
        "description": ".build.functions.exams.charset_normalizer.models",
        "peekOfCode": "class CharsetMatches:\n    \"\"\"\n    Container with every CharsetMatch items ordered by default from most probable to the less one.\n    Act like a list(iterable) but does not implements all related methods.\n    \"\"\"\n    def __init__(self, results: list[CharsetMatch] | None = None):\n        self._results: list[CharsetMatch] = sorted(results) if results else []\n    def __iter__(self) -> Iterator[CharsetMatch]:\n        yield from self._results\n    def __getitem__(self, item: int | str) -> CharsetMatch:",
        "detail": ".build.functions.exams.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CliDetectionResult",
        "kind": 6,
        "importPath": ".build.functions.exams.charset_normalizer.models",
        "description": ".build.functions.exams.charset_normalizer.models",
        "peekOfCode": "class CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,\n        alphabets: list[str],\n        has_sig_or_bom: bool,",
        "detail": ".build.functions.exams.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CoherenceMatch",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.models",
        "description": ".build.functions.exams.charset_normalizer.models",
        "peekOfCode": "CoherenceMatch = Tuple[str, float]\nCoherenceMatches = List[CoherenceMatch]\nclass CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,",
        "detail": ".build.functions.exams.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CoherenceMatches",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.models",
        "description": ".build.functions.exams.charset_normalizer.models",
        "peekOfCode": "CoherenceMatches = List[CoherenceMatch]\nclass CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,\n        alphabets: list[str],",
        "detail": ".build.functions.exams.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "is_accentuated",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_accentuated(character: str) -> bool:\n    try:\n        description: str = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return (\n        \"WITH GRAVE\" in description\n        or \"WITH ACUTE\" in description\n        or \"WITH CEDILLA\" in description\n        or \"WITH DIAERESIS\" in description",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "remove_accent",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def remove_accent(character: str) -> str:\n    decomposed: str = unicodedata.decomposition(character)\n    if not decomposed:\n        return character\n    codes: list[str] = decomposed.split(\" \")\n    return chr(int(codes[0], 16))\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef unicode_range(character: str) -> str | None:\n    \"\"\"\n    Retrieve the Unicode range official name from a single character.",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "unicode_range",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def unicode_range(character: str) -> str | None:\n    \"\"\"\n    Retrieve the Unicode range official name from a single character.\n    \"\"\"\n    character_ord: int = ord(character)\n    for range_name, ord_range in UNICODE_RANGES_COMBINED.items():\n        if character_ord in ord_range:\n            return range_name\n    return None\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_latin",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_latin(character: str) -> bool:\n    try:\n        description: str = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"LATIN\" in description\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_punctuation(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"P\" in character_category:",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_punctuation",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_punctuation(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"P\" in character_category:\n        return True\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Punctuation\" in character_range\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_symbol(character: str) -> bool:",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_symbol",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_symbol(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"S\" in character_category or \"N\" in character_category:\n        return True\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Forms\" in character_range and character_category != \"Lo\"\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_emoticon(character: str) -> bool:",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_emoticon",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_emoticon(character: str) -> bool:\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Emoticons\" in character_range or \"Pictographs\" in character_range\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_separator(character: str) -> bool:\n    if character.isspace() or character in {\"\", \"+\", \"<\", \">\"}:\n        return True\n    character_category: str = unicodedata.category(character)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_separator",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_separator(character: str) -> bool:\n    if character.isspace() or character in {\"\", \"+\", \"<\", \">\"}:\n        return True\n    character_category: str = unicodedata.category(character)\n    return \"Z\" in character_category or character_category in {\"Po\", \"Pd\", \"Pc\"}\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_case_variable(character: str) -> bool:\n    return character.islower() != character.isupper()\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk(character: str) -> bool:",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_case_variable",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_case_variable(character: str) -> bool:\n    return character.islower() != character.isupper()\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"CJK\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cjk",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_cjk(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"CJK\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_hiragana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_hiragana",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_hiragana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"HIRAGANA\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_katakana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_katakana",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_katakana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"KATAKANA\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_hangul(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_hangul",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_hangul(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"HANGUL\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_thai(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_thai",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_thai(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"THAI\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_arabic(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_arabic",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_arabic(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"ARABIC\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_arabic_isolated_form(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_arabic_isolated_form",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_arabic_isolated_form(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"ARABIC\" in character_name and \"ISOLATED FORM\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk_uncommon(character: str) -> bool:\n    return character not in COMMON_CJK_CHARACTERS\n@lru_cache(maxsize=len(UNICODE_RANGES_COMBINED))",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cjk_uncommon",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_cjk_uncommon(character: str) -> bool:\n    return character not in COMMON_CJK_CHARACTERS\n@lru_cache(maxsize=len(UNICODE_RANGES_COMBINED))\ndef is_unicode_range_secondary(range_name: str) -> bool:\n    return any(keyword in range_name for keyword in UNICODE_SECONDARY_RANGE_KEYWORD)\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_unicode_range_secondary",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_unicode_range_secondary(range_name: str) -> bool:\n    return any(keyword in range_name for keyword in UNICODE_SECONDARY_RANGE_KEYWORD)\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False\n        and character != \"\\x1a\"  # Why? Its the ASCII substitute character.\n        and character != \"\\ufeff\"  # bug discovered in Python,\n        # Zero Width No-Break Space located in \tArabic Presentation Forms-B, Unicode 1.1 not acknowledged as space.",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_unprintable",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False\n        and character != \"\\x1a\"  # Why? Its the ASCII substitute character.\n        and character != \"\\ufeff\"  # bug discovered in Python,\n        # Zero Width No-Break Space located in \tArabic Presentation Forms-B, Unicode 1.1 not acknowledged as space.\n    )\ndef any_specified_encoding(sequence: bytes, search_zone: int = 8192) -> str | None:\n    \"\"\"",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "any_specified_encoding",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def any_specified_encoding(sequence: bytes, search_zone: int = 8192) -> str | None:\n    \"\"\"\n    Extract using ASCII-only decoder any specified encoding in the first n-bytes.\n    \"\"\"\n    if not isinstance(sequence, bytes):\n        raise TypeError\n    seq_len: int = len(sequence)\n    results: list[str] = findall(\n        RE_POSSIBLE_ENCODING_INDICATION,\n        sequence[: min(seq_len, search_zone)].decode(\"ascii\", errors=\"ignore\"),",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_multi_byte_encoding",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_multi_byte_encoding(name: str) -> bool:\n    \"\"\"\n    Verify is a specific encoding is a multi byte one based on it IANA name\n    \"\"\"\n    return name in {\n        \"utf_8\",\n        \"utf_8_sig\",\n        \"utf_16\",\n        \"utf_16_be\",\n        \"utf_16_le\",",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "identify_sig_or_bom",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def identify_sig_or_bom(sequence: bytes) -> tuple[str | None, bytes]:\n    \"\"\"\n    Identify and extract SIG/BOM in given sequence.\n    \"\"\"\n    for iana_encoding in ENCODING_MARKS:\n        marks: bytes | list[bytes] = ENCODING_MARKS[iana_encoding]\n        if isinstance(marks, bytes):\n            marks = [marks]\n        for mark in marks:\n            if sequence.startswith(mark):",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "should_strip_sig_or_bom",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def should_strip_sig_or_bom(iana_encoding: str) -> bool:\n    return iana_encoding not in {\"utf_16\", \"utf_32\"}\ndef iana_name(cp_name: str, strict: bool = True) -> str:\n    \"\"\"Returns the Python normalized encoding name (Not the IANA official name).\"\"\"\n    cp_name = cp_name.lower().replace(\"-\", \"_\")\n    encoding_alias: str\n    encoding_iana: str\n    for encoding_alias, encoding_iana in aliases.items():\n        if cp_name in [encoding_alias, encoding_iana]:\n            return encoding_iana",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "iana_name",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def iana_name(cp_name: str, strict: bool = True) -> str:\n    \"\"\"Returns the Python normalized encoding name (Not the IANA official name).\"\"\"\n    cp_name = cp_name.lower().replace(\"-\", \"_\")\n    encoding_alias: str\n    encoding_iana: str\n    for encoding_alias, encoding_iana in aliases.items():\n        if cp_name in [encoding_alias, encoding_iana]:\n            return encoding_iana\n    if strict:\n        raise ValueError(f\"Unable to retrieve IANA for '{cp_name}'\")",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "cp_similarity",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def cp_similarity(iana_name_a: str, iana_name_b: str) -> float:\n    if is_multi_byte_encoding(iana_name_a) or is_multi_byte_encoding(iana_name_b):\n        return 0.0\n    decoder_a = importlib.import_module(f\"encodings.{iana_name_a}\").IncrementalDecoder\n    decoder_b = importlib.import_module(f\"encodings.{iana_name_b}\").IncrementalDecoder\n    id_a: IncrementalDecoder = decoder_a(errors=\"ignore\")\n    id_b: IncrementalDecoder = decoder_b(errors=\"ignore\")\n    character_match_count: int = 0\n    for i in range(255):\n        to_be_decoded: bytes = bytes([i])",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cp_similar",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def is_cp_similar(iana_name_a: str, iana_name_b: str) -> bool:\n    \"\"\"\n    Determine if two code page are at least 80% similar. IANA_SUPPORTED_SIMILAR dict was generated using\n    the function cp_similarity.\n    \"\"\"\n    return (\n        iana_name_a in IANA_SUPPORTED_SIMILAR\n        and iana_name_b in IANA_SUPPORTED_SIMILAR[iana_name_a]\n    )\ndef set_logging_handler(",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "set_logging_handler",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def set_logging_handler(\n    name: str = \"charset_normalizer\",\n    level: int = logging.INFO,\n    format_string: str = \"%(asctime)s | %(levelname)s | %(message)s\",\n) -> None:\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(format_string))\n    logger.addHandler(handler)",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "cut_sequence_chunks",
        "kind": 2,
        "importPath": ".build.functions.exams.charset_normalizer.utils",
        "description": ".build.functions.exams.charset_normalizer.utils",
        "peekOfCode": "def cut_sequence_chunks(\n    sequences: bytes,\n    encoding_iana: str,\n    offsets: range,\n    chunk_size: int,\n    bom_or_sig_available: bool,\n    strip_sig_or_bom: bool,\n    sig_payload: bytes,\n    is_multi_byte_decoder: bool,\n    decoded_payload: str | None = None,",
        "detail": ".build.functions.exams.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.version",
        "description": ".build.functions.exams.charset_normalizer.version",
        "peekOfCode": "__version__ = \"3.4.4\"\nVERSION = __version__.split(\".\")",
        "detail": ".build.functions.exams.charset_normalizer.version",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": ".build.functions.exams.charset_normalizer.version",
        "description": ".build.functions.exams.charset_normalizer.version",
        "peekOfCode": "VERSION = __version__.split(\".\")",
        "detail": ".build.functions.exams.charset_normalizer.version",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.codec",
        "description": ".build.functions.exams.idna.codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        return encode(data), len(data)\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))",
        "detail": ".build.functions.exams.idna.codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.codec",
        "description": ".build.functions.exams.idna.codec",
        "peekOfCode": "class IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = b\"\"\n        if labels:\n            if not labels[-1]:",
        "detail": ".build.functions.exams.idna.codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.codec",
        "description": ".build.functions.exams.idna.codec",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return (\"\", 0)\n        if not isinstance(data, str):\n            data = str(data, \"ascii\")\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = \"\"",
        "detail": ".build.functions.exams.idna.codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.codec",
        "description": ".build.functions.exams.idna.codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    pass\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,",
        "detail": ".build.functions.exams.idna.codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.codec",
        "description": ".build.functions.exams.idna.codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    pass\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,  # type: ignore\n        incrementalencoder=IncrementalEncoder,",
        "detail": ".build.functions.exams.idna.codec",
        "documentation": {}
    },
    {
        "label": "search_function",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.codec",
        "description": ".build.functions.exams.idna.codec",
        "peekOfCode": "def search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,  # type: ignore\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,",
        "detail": ".build.functions.exams.idna.codec",
        "documentation": {}
    },
    {
        "label": "_unicode_dots_re",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.codec",
        "description": ".build.functions.exams.idna.codec",
        "peekOfCode": "_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        return encode(data), len(data)\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":",
        "detail": ".build.functions.exams.idna.codec",
        "documentation": {}
    },
    {
        "label": "ToASCII",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.compat",
        "description": ".build.functions.exams.idna.compat",
        "peekOfCode": "def ToASCII(label: str) -> bytes:\n    return encode(label)\ndef ToUnicode(label: Union[bytes, bytearray]) -> str:\n    return decode(label)\ndef nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.exams.idna.compat",
        "documentation": {}
    },
    {
        "label": "ToUnicode",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.compat",
        "description": ".build.functions.exams.idna.compat",
        "peekOfCode": "def ToUnicode(label: Union[bytes, bytearray]) -> str:\n    return decode(label)\ndef nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.exams.idna.compat",
        "documentation": {}
    },
    {
        "label": "nameprep",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.compat",
        "description": ".build.functions.exams.idna.compat",
        "peekOfCode": "def nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.exams.idna.compat",
        "documentation": {}
    },
    {
        "label": "IDNAError",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "class IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "IDNABidiError",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "class IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "InvalidCodepoint",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "class InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "InvalidCodepointContext",
        "kind": 6,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "class InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):\n            raise ValueError(\"Unknown character in unicodedata\")\n    return v\ndef _is_script(cp: str, script: str) -> bool:",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_label_length",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def valid_label_length(label: Union[bytes, str]) -> bool:\n    if len(label) > 63:\n        return False\n    return True\ndef valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_string_length",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == \"\":",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "check_bidi",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == \"\":\n            # String likely comes from a newer version of Unicode\n            raise IDNABidiError(\"Unknown directionality in label {} at position {}\".format(repr(label), idx))\n        if direction in [\"R\", \"AL\", \"AN\"]:\n            bidi_label = True",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "check_initial_combiner",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def check_initial_combiner(label: str) -> bool:\n    if unicodedata.category(label[0])[0] == \"M\":\n        raise IDNAError(\"Label begins with an illegal combining character\")\n    return True\ndef check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == \"--\":\n        raise IDNAError(\"Label has disallowed hyphens in 3rd and 4th position\")\n    if label[0] == \"-\" or label[-1] == \"-\":\n        raise IDNAError(\"Label must not start or end with a hyphen\")\n    return True",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "check_hyphen_ok",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == \"--\":\n        raise IDNAError(\"Label has disallowed hyphens in 3rd and 4th position\")\n    if label[0] == \"-\" or label[-1] == \"-\":\n        raise IDNAError(\"Label must not start or end with a hyphen\")\n    return True\ndef check_nfc(label: str) -> None:\n    if unicodedata.normalize(\"NFC\", label) != label:\n        raise IDNAError(\"Label must be in Normalization Form C\")\ndef valid_contextj(label: str, pos: int) -> bool:",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "check_nfc",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def check_nfc(label: str) -> None:\n    if unicodedata.normalize(\"NFC\", label) != label:\n        raise IDNAError(\"Label must be in Normalization Form C\")\ndef valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x200C:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        ok = False",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_contextj",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x200C:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        ok = False\n        for i in range(pos - 1, -1, -1):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord(\"T\"):",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_contexto",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def valid_contexto(label: str, pos: int, exception: bool = False) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x00B7:\n        if 0 < pos < len(label) - 1:\n            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:\n                return True\n        return False\n    elif cp_value == 0x0375:\n        if pos < len(label) - 1 and len(label) > 1:\n            return _is_script(label[pos + 1], \"Greek\")",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "check_label",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def check_label(label: Union[str, bytes, bytearray]) -> None:\n    if isinstance(label, (bytes, bytearray)):\n        label = label.decode(\"utf-8\")\n    if len(label) == 0:\n        raise IDNAError(\"Empty Label\")\n    check_nfc(label)\n    check_hyphen_ok(label)\n    check_initial_combiner(label)\n    for pos, cp in enumerate(label):\n        cp_value = ord(cp)",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "alabel",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def alabel(label: str) -> bytes:\n    try:\n        label_bytes = label.encode(\"ascii\")\n        ulabel(label_bytes)\n        if not valid_label_length(label_bytes):\n            raise IDNAError(\"Label too long\")\n        return label_bytes\n    except UnicodeEncodeError:\n        pass\n    check_label(label)",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "ulabel",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def ulabel(label: Union[str, bytes, bytearray]) -> str:\n    if not isinstance(label, (bytes, bytearray)):\n        try:\n            label_bytes = label.encode(\"ascii\")\n        except UnicodeEncodeError:\n            check_label(label)\n            return label\n    else:\n        label_bytes = bytes(label)\n    label_bytes = label_bytes.lower()",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "uts46_remap",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:\n    \"\"\"Re-map the characters in the string according to UTS46 processing.\"\"\"\n    from .uts46data import uts46data\n    output = \"\"\n    for pos, char in enumerate(domain):\n        code_point = ord(char)\n        try:\n            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, \"Z\")) - 1]\n            status = uts46row[1]\n            replacement: Optional[str] = None",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def encode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n    transitional: bool = False,\n) -> bytes:\n    if not isinstance(s, str):\n        try:\n            s = str(s, \"ascii\")",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "def decode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n) -> str:\n    try:\n        if not isinstance(s, str):\n            s = str(s, \"ascii\")\n    except UnicodeDecodeError:",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "_virama_combining_class",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "_virama_combining_class = 9\n_alabel_prefix = b\"xn--\"\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "_alabel_prefix",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "_alabel_prefix = b\"xn--\"\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "_unicode_dots_re",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.core",
        "description": ".build.functions.exams.idna.core",
        "peekOfCode": "_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass",
        "detail": ".build.functions.exams.idna.core",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.idnadata",
        "description": ".build.functions.exams.idna.idnadata",
        "peekOfCode": "__version__ = \"16.0.0\"\nscripts = {\n    \"Greek\": (\n        0x37000000374,\n        0x37500000378,\n        0x37A0000037E,\n        0x37F00000380,\n        0x38400000385,\n        0x38600000387,\n        0x3880000038B,",
        "detail": ".build.functions.exams.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "scripts",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.idnadata",
        "description": ".build.functions.exams.idna.idnadata",
        "peekOfCode": "scripts = {\n    \"Greek\": (\n        0x37000000374,\n        0x37500000378,\n        0x37A0000037E,\n        0x37F00000380,\n        0x38400000385,\n        0x38600000387,\n        0x3880000038B,\n        0x38C0000038D,",
        "detail": ".build.functions.exams.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "joining_types",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.idnadata",
        "description": ".build.functions.exams.idna.idnadata",
        "peekOfCode": "joining_types = {\n    0xAD: 84,\n    0x300: 84,\n    0x301: 84,\n    0x302: 84,\n    0x303: 84,\n    0x304: 84,\n    0x305: 84,\n    0x306: 84,\n    0x307: 84,",
        "detail": ".build.functions.exams.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "codepoint_classes",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.idnadata",
        "description": ".build.functions.exams.idna.idnadata",
        "peekOfCode": "codepoint_classes = {\n    \"PVALID\": (\n        0x2D0000002E,\n        0x300000003A,\n        0x610000007B,\n        0xDF000000F7,\n        0xF800000100,\n        0x10100000102,\n        0x10300000104,\n        0x10500000106,",
        "detail": ".build.functions.exams.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "intranges_from_list",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.intranges",
        "description": ".build.functions.exams.idna.intranges",
        "peekOfCode": "def intranges_from_list(list_: List[int]) -> Tuple[int, ...]:\n    \"\"\"Represent a list of integers as a sequence of ranges:\n    ((start_0, end_0), (start_1, end_1), ...), such that the original\n    integers are exactly those x such that start_i <= x < end_i for some i.\n    Ranges are encoded as single integers (start << 32 | end), not as tuples.\n    \"\"\"\n    sorted_list = sorted(list_)\n    ranges = []\n    last_write = -1\n    for i in range(len(sorted_list)):",
        "detail": ".build.functions.exams.idna.intranges",
        "documentation": {}
    },
    {
        "label": "intranges_contain",
        "kind": 2,
        "importPath": ".build.functions.exams.idna.intranges",
        "description": ".build.functions.exams.idna.intranges",
        "peekOfCode": "def intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:\n    \"\"\"Determine if `int_` falls into one of the ranges in `ranges`.\"\"\"\n    tuple_ = _encode_range(int_, 0)\n    pos = bisect.bisect_left(ranges, tuple_)\n    # we could be immediately ahead of a tuple (start, end)\n    # with start < int_ <= end\n    if pos > 0:\n        left, right = _decode_range(ranges[pos - 1])\n        if left <= int_ < right:\n            return True",
        "detail": ".build.functions.exams.idna.intranges",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.package_data",
        "description": ".build.functions.exams.idna.package_data",
        "peekOfCode": "__version__ = \"3.11\"",
        "detail": ".build.functions.exams.idna.package_data",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.uts46data",
        "description": ".build.functions.exams.idna.uts46data",
        "peekOfCode": "__version__ = \"16.0.0\"\ndef _seg_0() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x0, \"V\"),\n        (0x1, \"V\"),\n        (0x2, \"V\"),\n        (0x3, \"V\"),\n        (0x4, \"V\"),\n        (0x5, \"V\"),\n        (0x6, \"V\"),",
        "detail": ".build.functions.exams.idna.uts46data",
        "documentation": {}
    },
    {
        "label": "uts46data",
        "kind": 5,
        "importPath": ".build.functions.exams.idna.uts46data",
        "description": ".build.functions.exams.idna.uts46data",
        "peekOfCode": "uts46data = tuple(\n    _seg_0()\n    + _seg_1()\n    + _seg_2()\n    + _seg_3()\n    + _seg_4()\n    + _seg_5()\n    + _seg_6()\n    + _seg_7()\n    + _seg_8()",
        "detail": ".build.functions.exams.idna.uts46data",
        "documentation": {}
    },
    {
        "label": "to_native_string",
        "kind": 2,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "def to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        out = string.decode(encoding)\n    return out",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "unicode_is_ascii",
        "kind": 2,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode(\"ascii\")\n        return True",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_NAME_RE_BYTE",
        "kind": 5,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_NAME_RE_BYTE = re.compile(rb\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_NAME_RE_STR = re.compile(r\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_NAME_RE_STR",
        "kind": 5,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_NAME_RE_STR = re.compile(r\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_VALUE_RE_BYTE",
        "kind": 5,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_VALUE_RE_STR",
        "kind": 5,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_HEADER_VALIDATORS_STR",
        "kind": 5,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_HEADER_VALIDATORS_BYTE",
        "kind": 5,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "HEADER_VALIDATORS",
        "kind": 5,
        "importPath": ".build.functions.exams.requests._internal_utils",
        "description": ".build.functions.exams.requests._internal_utils",
        "peekOfCode": "HEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):",
        "detail": ".build.functions.exams.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "BaseAdapter",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.adapters",
        "description": ".build.functions.exams.requests.adapters",
        "peekOfCode": "class BaseAdapter:\n    \"\"\"The Base Transport Adapter\"\"\"\n    def __init__(self):\n        super().__init__()\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.",
        "detail": ".build.functions.exams.requests.adapters",
        "documentation": {}
    },
    {
        "label": "HTTPAdapter",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.adapters",
        "description": ".build.functions.exams.requests.adapters",
        "peekOfCode": "class HTTPAdapter(BaseAdapter):\n    \"\"\"The built-in HTTP Adapter for urllib3.\n    Provides a general-case interface for Requests sessions to contact HTTP and\n    HTTPS urls by implementing the Transport Adapter interface. This class will\n    usually be created by the :class:`Session <Session>` class under the\n    covers.\n    :param pool_connections: The number of urllib3 connection pools to cache.\n    :param pool_maxsize: The maximum number of connections to save in the pool.\n    :param max_retries: The maximum number of retries each connection\n        should attempt. Note, this applies only to failed DNS lookups, socket",
        "detail": ".build.functions.exams.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOLBLOCK",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.adapters",
        "description": ".build.functions.exams.requests.adapters",
        "peekOfCode": "DEFAULT_POOLBLOCK = False\nDEFAULT_POOLSIZE = 10\nDEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":",
        "detail": ".build.functions.exams.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOLSIZE",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.adapters",
        "description": ".build.functions.exams.requests.adapters",
        "peekOfCode": "DEFAULT_POOLSIZE = 10\nDEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}",
        "detail": ".build.functions.exams.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RETRIES",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.adapters",
        "description": ".build.functions.exams.requests.adapters",
        "peekOfCode": "DEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}\n    pool_kwargs = {}",
        "detail": ".build.functions.exams.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOL_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.adapters",
        "description": ".build.functions.exams.requests.adapters",
        "peekOfCode": "DEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}\n    pool_kwargs = {}\n    parsed_request_url = urlparse(request.url)",
        "detail": ".build.functions.exams.requests.adapters",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def request(method, url, **kwargs):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n    :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "get",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def get(url, params=None, **kwargs):\n    r\"\"\"Sends a GET request.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"get\", url, params=params, **kwargs)",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def options(url, **kwargs):\n    r\"\"\"Sends an OPTIONS request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"options\", url, **kwargs)\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "head",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n        `allow_redirects` is not provided, it will be set to `False` (as\n        opposed to the default :meth:`request` behavior).\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    kwargs.setdefault(\"allow_redirects\", False)",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "post",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def post(url, data=None, json=None, **kwargs):\n    r\"\"\"Sends a POST request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "put",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def put(url, data=None, **kwargs):\n    r\"\"\"Sends a PUT request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "patch",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def patch(url, data=None, **kwargs):\n    r\"\"\"Sends a PATCH request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "delete",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.api",
        "description": ".build.functions.exams.requests.api",
        "peekOfCode": "def delete(url, **kwargs):\n    r\"\"\"Sends a DELETE request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"delete\", url, **kwargs)",
        "detail": ".build.functions.exams.requests.api",
        "documentation": {}
    },
    {
        "label": "AuthBase",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.auth",
        "description": ".build.functions.exams.requests.auth",
        "peekOfCode": "class AuthBase:\n    \"\"\"Base class that all auth implementations derive from\"\"\"\n    def __call__(self, r):\n        raise NotImplementedError(\"Auth hooks must be callable.\")\nclass HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    def __eq__(self, other):",
        "detail": ".build.functions.exams.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPBasicAuth",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.auth",
        "description": ".build.functions.exams.requests.auth",
        "peekOfCode": "class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),",
        "detail": ".build.functions.exams.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPProxyAuth",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.auth",
        "description": ".build.functions.exams.requests.auth",
        "peekOfCode": "class HTTPProxyAuth(HTTPBasicAuth):\n    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n    def __call__(self, r):\n        r.headers[\"Proxy-Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r\nclass HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password",
        "detail": ".build.functions.exams.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPDigestAuth",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.auth",
        "description": ".build.functions.exams.requests.auth",
        "peekOfCode": "class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n    def init_per_thread_state(self):\n        # Ensure state is initialized just once per-thread\n        if not hasattr(self._thread_local, \"init\"):",
        "detail": ".build.functions.exams.requests.auth",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE_FORM_URLENCODED",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.auth",
        "description": ".build.functions.exams.requests.auth",
        "peekOfCode": "CONTENT_TYPE_FORM_URLENCODED = \"application/x-www-form-urlencoded\"\nCONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility",
        "detail": ".build.functions.exams.requests.auth",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE_MULTI_PART",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.auth",
        "description": ".build.functions.exams.requests.auth",
        "peekOfCode": "CONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility\n    # for things like ints. This will be removed in 3.0.0.",
        "detail": ".build.functions.exams.requests.auth",
        "documentation": {}
    },
    {
        "label": "chardet",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "chardet = _resolve_char_detection()\n# -------\n# Pythons\n# -------\n# Syntax sugar.\n_ver = sys.version_info\n#: Python 2.x?\nis_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "_ver",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "_ver = sys.version_info\n#: Python 2.x?\nis_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "is_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "is_py3",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "is_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json\nif has_simplejson:\n    from simplejson import JSONDecodeError",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "has_simplejson",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "has_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json\nif has_simplejson:\n    from simplejson import JSONDecodeError\nelse:\n    from json import JSONDecodeError",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "builtin_str",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "builtin_str = str\nstr = str\nbytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "str = str\nbytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "bytes",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "bytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "basestring",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "basestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "numeric_types",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "numeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "integer_types",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.compat",
        "description": ".build.functions.exams.requests.compat",
        "peekOfCode": "integer_types = (int,)",
        "detail": ".build.functions.exams.requests.compat",
        "documentation": {}
    },
    {
        "label": "MockRequest",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "class MockRequest:\n    \"\"\"Wraps a `requests.Request` to mimic a `urllib2.Request`.\n    The code in `http.cookiejar.CookieJar` expects this interface in order to correctly\n    manage cookie policies, i.e., determine whether a cookie can be set, given the\n    domains of the request and the cookie.\n    The original request object is read-only. The client is responsible for collecting\n    the new headers via `get_new_headers()` and interpreting them appropriately. You\n    probably want `get_cookie_header`, defined below.\n    \"\"\"\n    def __init__(self, request):",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "MockResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "class MockResponse:\n    \"\"\"Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n    ...what? Basically, expose the parsed HTTP headers from the server response\n    the way `http.cookiejar` expects to see them.\n    \"\"\"\n    def __init__(self, headers):\n        \"\"\"Make a MockResponse for `cookiejar` to read.\n        :param headers: a httplib.HTTPMessage or analogous carrying the headers\n        \"\"\"\n        self._headers = headers",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "CookieConflictError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "class CookieConflictError(RuntimeError):\n    \"\"\"There are two cookies that meet the criteria specified in the cookie jar.\n    Use .get and .set and include domain and path args in order to be more specific.\n    \"\"\"\nclass RequestsCookieJar(cookielib.CookieJar, MutableMapping):\n    \"\"\"Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\n    interface.\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "RequestsCookieJar",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "class RequestsCookieJar(cookielib.CookieJar, MutableMapping):\n    \"\"\"Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\n    interface.\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n    Requests does not use the dict interface internally; it's just for\n    compatibility with external client code. All requests code should work\n    out of the box with externally provided instances of ``CookieJar``, e.g.\n    ``LWPCookieJar`` and ``FileCookieJar``.",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "extract_cookies_to_jar",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "def extract_cookies_to_jar(jar, request, response):\n    \"\"\"Extract the cookies from the response into a CookieJar.\n    :param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n    :param request: our own requests.Request object\n    :param response: urllib3.HTTPResponse object\n    \"\"\"\n    if not (hasattr(response, \"_original_response\") and response._original_response):\n        return\n    # the _original_response field is the wrapped httplib.HTTPResponse object,\n    req = MockRequest(request)",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "get_cookie_header",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "def get_cookie_header(jar, request):\n    \"\"\"\n    Produce an appropriate Cookie header string to be sent with `request`, or None.\n    :rtype: str\n    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get(\"Cookie\")\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "remove_cookie_by_name",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "def remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.\n    Wraps CookieJar.clear(), is O(n).\n    \"\"\"\n    clearables = []\n    for cookie in cookiejar:\n        if cookie.name != name:\n            continue\n        if domain is not None and domain != cookie.domain:\n            continue",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "create_cookie",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "def create_cookie(name, value, **kwargs):\n    \"\"\"Make a cookie from underspecified parameters.\n    By default, the pair of `name` and `value` will be set for the domain ''\n    and sent on every request (this is sometimes called a \"supercookie\").\n    \"\"\"\n    result = {\n        \"version\": 0,\n        \"name\": name,\n        \"value\": value,\n        \"port\": None,",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "morsel_to_cookie",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "def morsel_to_cookie(morsel):\n    \"\"\"Convert a Morsel object into a Cookie containing the one k/v pair.\"\"\"\n    expires = None\n    if morsel[\"max-age\"]:\n        try:\n            expires = int(time.time() + int(morsel[\"max-age\"]))\n        except ValueError:\n            raise TypeError(f\"max-age: {morsel['max-age']} must be integer\")\n    elif morsel[\"expires\"]:\n        time_template = \"%a, %d-%b-%Y %H:%M:%S GMT\"",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "cookiejar_from_dict",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :param cookiejar: (optional) A cookiejar to add the cookies to.\n    :param overwrite: (optional) If False, will not replace cookies\n        already in the jar with new ones.\n    :rtype: CookieJar\n    \"\"\"\n    if cookiejar is None:\n        cookiejar = RequestsCookieJar()",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "merge_cookies",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.cookies",
        "description": ".build.functions.exams.requests.cookies",
        "peekOfCode": "def merge_cookies(cookiejar, cookies):\n    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n    :param cookiejar: CookieJar object to add the cookies to.\n    :param cookies: Dictionary or CookieJar object to be added.\n    :rtype: CookieJar\n    \"\"\"\n    if not isinstance(cookiejar, cookielib.CookieJar):\n        raise ValueError(\"You can only merge into CookieJar\")\n    if isinstance(cookies, dict):\n        cookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)",
        "detail": ".build.functions.exams.requests.cookies",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class RequestException(IOError):\n    \"\"\"There was an ambiguous exception that occurred while handling your\n    request.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize RequestException with `request` and `response` objects.\"\"\"\n        response = kwargs.pop(\"response\", None)\n        self.response = response\n        self.request = kwargs.pop(\"request\", None)\n        if response is not None and not self.request and hasattr(response, \"request\"):",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidJSONError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class InvalidJSONError(RequestException):\n    \"\"\"A JSON error occurred.\"\"\"\nclass JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n    \"\"\"Couldn't decode the text into json\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Construct the JSONDecodeError instance first with all\n        args. Then use it's args to construct the IOError so that\n        the json specific args aren't used as IOError specific args\n        and the error message from JSONDecodeError is preserved.",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n    \"\"\"Couldn't decode the text into json\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Construct the JSONDecodeError instance first with all\n        args. Then use it's args to construct the IOError so that\n        the json specific args aren't used as IOError specific args\n        and the error message from JSONDecodeError is preserved.\n        \"\"\"\n        CompatJSONDecodeError.__init__(self, *args)",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class HTTPError(RequestException):\n    \"\"\"An HTTP error occurred.\"\"\"\nclass ConnectionError(RequestException):\n    \"\"\"A Connection error occurred.\"\"\"\nclass ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class ConnectionError(RequestException):\n    \"\"\"A Connection error occurred.\"\"\"\nclass ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"\nclass ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"\nclass ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.\n    Requests that produced this error are safe to retry.\n    \"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeout",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.\n    Requests that produced this error are safe to retry.\n    \"\"\"\nclass ReadTimeout(Timeout):\n    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"\nclass URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeout",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class ReadTimeout(Timeout):\n    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"\nclass URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "URLRequired",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "TooManyRedirects",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "MissingSchema",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidSchema",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidURL",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidProxyURL",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ChunkedEncodingError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ContentDecodingError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "StreamConsumedError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RetryError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "UnrewindableBodyError",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestsWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "FileModeWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestsDependencyWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.exceptions",
        "description": ".build.functions.exams.requests.exceptions",
        "peekOfCode": "class RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.exams.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "info",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.help",
        "description": ".build.functions.exams.requests.help",
        "peekOfCode": "def info():\n    \"\"\"Generate information for a bug report.\"\"\"\n    try:\n        platform_info = {\n            \"system\": platform.system(),\n            \"release\": platform.release(),\n        }\n    except OSError:\n        platform_info = {\n            \"system\": \"Unknown\",",
        "detail": ".build.functions.exams.requests.help",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.help",
        "description": ".build.functions.exams.requests.help",
        "peekOfCode": "def main():\n    \"\"\"Pretty-print the bug information as JSON.\"\"\"\n    print(json.dumps(info(), sort_keys=True, indent=2))\nif __name__ == \"__main__\":\n    main()",
        "detail": ".build.functions.exams.requests.help",
        "documentation": {}
    },
    {
        "label": "default_hooks",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.hooks",
        "description": ".build.functions.exams.requests.hooks",
        "peekOfCode": "def default_hooks():\n    return {event: [] for event in HOOKS}\n# TODO: response is the only one\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]",
        "detail": ".build.functions.exams.requests.hooks",
        "documentation": {}
    },
    {
        "label": "dispatch_hook",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.hooks",
        "description": ".build.functions.exams.requests.hooks",
        "peekOfCode": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if _hook_data is not None:",
        "detail": ".build.functions.exams.requests.hooks",
        "documentation": {}
    },
    {
        "label": "HOOKS",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.hooks",
        "description": ".build.functions.exams.requests.hooks",
        "peekOfCode": "HOOKS = [\"response\"]\ndef default_hooks():\n    return {event: [] for event in HOOKS}\n# TODO: response is the only one\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):",
        "detail": ".build.functions.exams.requests.hooks",
        "documentation": {}
    },
    {
        "label": "RequestEncodingMixin",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "class RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:\n            path = \"/\"\n        url.append(path)",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "RequestHooksMixin",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "class RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n    def deregister_hook(self, event, hook):",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "Request",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "class Request(RequestHooksMixin):\n    \"\"\"A user-created :class:`Request <Request>` object.\n    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n    :param method: HTTP method to use.\n    :param url: URL to send.\n    :param headers: dictionary of headers to send.\n    :param files: dictionary of {filename: fileobject} files to multipart upload.\n    :param data: the body to attach to the request. If a dictionary or\n        list of tuples ``[(key, value)]`` is provided, form-encoding will\n        take place.",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "PreparedRequest",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n    \"\"\"The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\n    containing the exact bytes that will be sent to the server.\n    Instances are generated from a :class:`Request <Request>` object, and\n    should not be instantiated manually; doing so may produce undesirable\n    effects.\n    Usage::\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "class Response:\n    \"\"\"The :class:`Response <Response>` object, which contains a\n    server's response to an HTTP request.\n    \"\"\"\n    __attrs__ = [\n        \"_content\",\n        \"status_code\",\n        \"headers\",\n        \"url\",\n        \"history\",",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "REDIRECT_STATI",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "REDIRECT_STATI = (\n    codes.moved,  # 301\n    codes.found,  # 302\n    codes.other,  # 303\n    codes.temporary_redirect,  # 307\n    codes.permanent_redirect,  # 308\n)\nDEFAULT_REDIRECT_LIMIT = 30\nCONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "DEFAULT_REDIRECT_LIMIT",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "DEFAULT_REDIRECT_LIMIT = 30\nCONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "CONTENT_CHUNK_SIZE",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "CONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "ITER_CHUNK_SIZE",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.models",
        "description": ".build.functions.exams.requests.models",
        "peekOfCode": "ITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:\n            path = \"/\"",
        "detail": ".build.functions.exams.requests.models",
        "documentation": {}
    },
    {
        "label": "SessionRedirectMixin",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.sessions",
        "description": ".build.functions.exams.requests.sessions",
        "peekOfCode": "class SessionRedirectMixin:\n    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:",
        "detail": ".build.functions.exams.requests.sessions",
        "documentation": {}
    },
    {
        "label": "Session",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.sessions",
        "description": ".build.functions.exams.requests.sessions",
        "peekOfCode": "class Session(SessionRedirectMixin):\n    \"\"\"A Requests session.\n    Provides cookie persistence, connection-pooling, and configuration.\n    Basic Usage::\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n    Or as a context manager::\n      >>> with requests.Session() as s:",
        "detail": ".build.functions.exams.requests.sessions",
        "documentation": {}
    },
    {
        "label": "merge_setting",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.sessions",
        "description": ".build.functions.exams.requests.sessions",
        "peekOfCode": "def merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"Determines appropriate setting for a given request, taking into account\n    the explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n    if session_setting is None:\n        return request_setting\n    if request_setting is None:\n        return session_setting\n    # Bypass if not a dictionary (e.g. verify)",
        "detail": ".build.functions.exams.requests.sessions",
        "documentation": {}
    },
    {
        "label": "merge_hooks",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.sessions",
        "description": ".build.functions.exams.requests.sessions",
        "peekOfCode": "def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n    \"\"\"Properly merges both requests and session hooks.\n    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get(\"response\") == []:\n        return request_hooks\n    if request_hooks is None or request_hooks.get(\"response\") == []:\n        return session_hooks\n    return merge_setting(request_hooks, session_hooks, dict_class)",
        "detail": ".build.functions.exams.requests.sessions",
        "documentation": {}
    },
    {
        "label": "session",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.sessions",
        "description": ".build.functions.exams.requests.sessions",
        "peekOfCode": "def session():\n    \"\"\"\n    Returns a :class:`Session` for context-management.\n    .. deprecated:: 1.0.0\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n    :rtype: Session\n    \"\"\"\n    return Session()",
        "detail": ".build.functions.exams.requests.sessions",
        "documentation": {}
    },
    {
        "label": "_codes",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.status_codes",
        "description": ".build.functions.exams.requests.status_codes",
        "peekOfCode": "_codes = {\n    # Informational.\n    100: (\"continue\",),\n    101: (\"switching_protocols\",),\n    102: (\"processing\", \"early-hints\"),\n    103: (\"checkpoint\",),\n    122: (\"uri_too_long\", \"request_uri_too_long\"),\n    200: (\"ok\", \"okay\", \"all_ok\", \"all_okay\", \"all_good\", \"\\\\o/\", \"\"),\n    201: (\"created\",),\n    202: (\"accepted\",),",
        "detail": ".build.functions.exams.requests.status_codes",
        "documentation": {}
    },
    {
        "label": "codes",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.status_codes",
        "description": ".build.functions.exams.requests.status_codes",
        "peekOfCode": "codes = LookupDict(name=\"status_codes\")\ndef _init():\n    for code, titles in _codes.items():\n        for title in titles:\n            setattr(codes, title, code)\n            if not title.startswith((\"\\\\\", \"/\")):\n                setattr(codes, title.upper(), code)\n    def doc(code):\n        names = \", \".join(f\"``{n}``\" for n in _codes[code])\n        return \"* %d: %s\" % (code, names)",
        "detail": ".build.functions.exams.requests.status_codes",
        "documentation": {}
    },
    {
        "label": "CaseInsensitiveDict",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.structures",
        "description": ".build.functions.exams.requests.structures",
        "peekOfCode": "class CaseInsensitiveDict(MutableMapping):\n    \"\"\"A case-insensitive ``dict``-like object.\n    Implements all methods and operations of\n    ``MutableMapping`` as well as dict's ``copy``. Also\n    provides ``lower_items``.\n    All keys are expected to be strings. The structure remembers the\n    case of the last key to be set, and ``iter(instance)``,\n    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``\n    will contain case-sensitive keys. However, querying and contains\n    testing is case insensitive::",
        "detail": ".build.functions.exams.requests.structures",
        "documentation": {}
    },
    {
        "label": "LookupDict",
        "kind": 6,
        "importPath": ".build.functions.exams.requests.structures",
        "description": ".build.functions.exams.requests.structures",
        "peekOfCode": "class LookupDict(dict):\n    \"\"\"Dictionary lookup object.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        super().__init__()\n    def __repr__(self):\n        return f\"<lookup '{self.name}'>\"\n    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n        return self.__dict__.get(key, None)",
        "detail": ".build.functions.exams.requests.structures",
        "documentation": {}
    },
    {
        "label": "dict_to_sequence",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def dict_to_sequence(d):\n    \"\"\"Returns an internal sequence dictionary update.\"\"\"\n    if hasattr(d, \"items\"):\n        d = d.items()\n    return d\ndef super_len(o):\n    total_length = None\n    current_position = 0\n    if not is_urllib3_1 and isinstance(o, str):\n        # urllib3 2.x+ treats all strings as utf-8 instead",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "super_len",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def super_len(o):\n    total_length = None\n    current_position = 0\n    if not is_urllib3_1 and isinstance(o, str):\n        # urllib3 2.x+ treats all strings as utf-8 instead\n        # of latin-1 (iso-8859-1) like http.client.\n        o = o.encode(\"utf-8\")\n    if hasattr(o, \"__len__\"):\n        total_length = len(o)\n    elif hasattr(o, \"len\"):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_netrc_auth",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n    netrc_file = os.environ.get(\"NETRC\")\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n        netrc_locations = (f\"~/{f}\" for f in NETRC_FILES)\n    try:\n        from netrc import NetrcParseError, netrc\n        netrc_path = None",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "guess_filename",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def guess_filename(obj):\n    \"\"\"Tries to guess the filename of the given object.\"\"\"\n    name = getattr(obj, \"name\", None)\n    if name and isinstance(name, basestring) and name[0] != \"<\" and name[-1] != \">\":\n        return os.path.basename(name)\ndef extract_zipped_paths(path):\n    \"\"\"Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    \"\"\"",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "extract_zipped_paths",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def extract_zipped_paths(path):\n    \"\"\"Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    \"\"\"\n    if os.path.exists(path):\n        # this is already a valid path, no need to do anything further\n        return path\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "atomic_open",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def atomic_open(filename):\n    \"\"\"Write a file to the disk in an atomic fashion\"\"\"\n    tmp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))\n    try:\n        with os.fdopen(tmp_descriptor, \"wb\") as tmp_handler:\n            yield tmp_handler\n        os.replace(tmp_name, filename)\n    except BaseException:\n        os.remove(tmp_name)\n        raise",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "from_key_val_list",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def from_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. Unless it can not be represented as such, return an\n    OrderedDict, e.g.,\n    ::\n        >>> from_key_val_list([('key', 'val')])\n        OrderedDict([('key', 'val')])\n        >>> from_key_val_list('string')\n        Traceback (most recent call last):\n        ...",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "to_key_val_list",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def to_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. If it can be, return a list of tuples, e.g.,\n    ::\n        >>> to_key_val_list([('key', 'val')])\n        [('key', 'val')]\n        >>> to_key_val_list({'key': 'val'})\n        [('key', 'val')]\n        >>> to_key_val_list('string')\n        Traceback (most recent call last):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_list_header",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def parse_list_header(value):\n    \"\"\"Parse lists as described by RFC 2068 Section 2.\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Quotes are removed automatically after parsing.\n    It basically works like :func:`parse_set_header` just that items\n    may appear multiple times and case sensitivity is preserved.\n    The return value is a standard :class:`list`:\n    >>> parse_list_header('token, \"quoted value\"')",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_dict_header",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def parse_dict_header(value):\n    \"\"\"Parse lists of key, value pairs as described by RFC 2068 Section 2 and\n    convert them into a python dict:\n    >>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n    >>> type(d) is dict\n    True\n    >>> sorted(d.items())\n    [('bar', 'as well'), ('foo', 'is a fish')]\n    If there is no value for a key it will be `None`:\n    >>> parse_dict_header('key_without_value')",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "unquote_header_value",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def unquote_header_value(value, is_filename=False):\n    r\"\"\"Unquotes a header value.  (Reversal of :func:`quote_header_value`).\n    This does not use the real unquoting but what browsers are actually\n    using for quoting.\n    :param value: the header value to unquote.\n    :rtype: str\n    \"\"\"\n    if value and value[0] == value[-1] == '\"':\n        # this is not the real unquoting, but fixing this so that the\n        # RFC is met will result in bugs with internet explorer and",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "dict_from_cookiejar",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def dict_from_cookiejar(cj):\n    \"\"\"Returns a key/value dictionary from a CookieJar.\n    :param cj: CookieJar object to extract cookies from.\n    :rtype: dict\n    \"\"\"\n    cookie_dict = {cookie.name: cookie.value for cookie in cj}\n    return cookie_dict\ndef add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cj: CookieJar to insert cookies into.",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "add_dict_to_cookiejar",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cj: CookieJar to insert cookies into.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :rtype: CookieJar\n    \"\"\"\n    return cookiejar_from_dict(cookie_dict, cj)\ndef get_encodings_from_content(content):\n    \"\"\"Returns encodings from given content string.\n    :param content: bytestring to extract encodings from.",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_encodings_from_content",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def get_encodings_from_content(content):\n    \"\"\"Returns encodings from given content string.\n    :param content: bytestring to extract encodings from.\n    \"\"\"\n    warnings.warn(\n        (\n            \"In requests 3.0, get_encodings_from_content will be removed. For \"\n            \"more information, please see the discussion on issue #2266. (This\"\n            \" warning should only appear once.)\"\n        ),",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_encoding_from_headers",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def get_encoding_from_headers(headers):\n    \"\"\"Returns encodings from given HTTP Header Dict.\n    :param headers: dictionary to extract encoding from.\n    :rtype: str\n    \"\"\"\n    content_type = headers.get(\"content-type\")\n    if not content_type:\n        return None\n    content_type, params = _parse_content_type_header(content_type)\n    if \"charset\" in params:",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "stream_decode_response_unicode",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes an iterator.\"\"\"\n    if r.encoding is None:\n        yield from iterator\n        return\n    decoder = codecs.getincrementaldecoder(r.encoding)(errors=\"replace\")\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "iter_slices",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def iter_slices(string, slice_length):\n    \"\"\"Iterate over slices of a string.\"\"\"\n    pos = 0\n    if slice_length is None or slice_length <= 0:\n        slice_length = len(string)\n    while pos < len(string):\n        yield string[pos : pos + slice_length]\n        pos += slice_length\ndef get_unicode_from_response(r):\n    \"\"\"Returns the requested content back in unicode.",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_unicode_from_response",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def get_unicode_from_response(r):\n    \"\"\"Returns the requested content back in unicode.\n    :param r: Response object to get unicode content from.\n    Tried:\n    1. charset from content-type\n    2. fall back and replace all unicode characters\n    :rtype: str\n    \"\"\"\n    warnings.warn(\n        (",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "unquote_unreserved",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def unquote_unreserved(uri):\n    \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n    :rtype: str\n    \"\"\"\n    parts = uri.split(\"%\")\n    for i in range(1, len(parts)):\n        h = parts[i][0:2]\n        if len(h) == 2 and h.isalnum():\n            try:",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "requote_uri",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def requote_uri(uri):\n    \"\"\"Re-quote the given URI.\n    This function passes the given URI through an unquote/quote cycle to\n    ensure that it is fully and consistently quoted.\n    :rtype: str\n    \"\"\"\n    safe_with_percent = \"!#$%&'()*+,/:;=?@[]~\"\n    safe_without_percent = \"!#$&'()*+,/:;=?@[]~\"\n    try:\n        # Unquote only the unreserved characters",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "address_in_network",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n    :rtype: bool\n    \"\"\"\n    ipaddr = struct.unpack(\"=L\", socket.inet_aton(ip))[0]\n    netaddr, bits = net.split(\"/\")\n    netmask = struct.unpack(\"=L\", socket.inet_aton(dotted_netmask(int(bits))))[0]\n    network = struct.unpack(\"=L\", socket.inet_aton(netaddr))[0] & netmask",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "dotted_netmask",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def dotted_netmask(mask):\n    \"\"\"Converts mask from /xx format to xxx.xxx.xxx.xxx\n    Example: if mask is 24 function returns 255.255.255.0\n    :rtype: str\n    \"\"\"\n    bits = 0xFFFFFFFF ^ (1 << 32 - mask) - 1\n    return socket.inet_ntoa(struct.pack(\">I\", bits))\ndef is_ipv4_address(string_ip):\n    \"\"\"\n    :rtype: bool",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "is_ipv4_address",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def is_ipv4_address(string_ip):\n    \"\"\"\n    :rtype: bool\n    \"\"\"\n    try:\n        socket.inet_aton(string_ip)\n    except OSError:\n        return False\n    return True\ndef is_valid_cidr(string_network):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_cidr",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def is_valid_cidr(string_network):\n    \"\"\"\n    Very simple check of the cidr format in no_proxy variable.\n    :rtype: bool\n    \"\"\"\n    if string_network.count(\"/\") == 1:\n        try:\n            mask = int(string_network.split(\"/\")[1])\n        except ValueError:\n            return False",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "set_environ",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def set_environ(env_name, value):\n    \"\"\"Set the environment variable 'env_name' to 'value'\n    Save previous value, yield, and then restore the previous value stored in\n    the environment variable 'env_name'.\n    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "should_bypass_proxies",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def should_bypass_proxies(url, no_proxy):\n    \"\"\"\n    Returns whether we should bypass proxies or not.\n    :rtype: bool\n    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    def get_proxy(key):\n        return os.environ.get(key) or os.environ.get(key.upper())\n    # First check whether no_proxy is defined. If it is, check that the URL",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_environ_proxies",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def get_environ_proxies(url, no_proxy=None):\n    \"\"\"\n    Return a dict of environment proxies.\n    :rtype: dict\n    \"\"\"\n    if should_bypass_proxies(url, no_proxy=no_proxy):\n        return {}\n    else:\n        return getproxies()\ndef select_proxy(url, proxies):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "select_proxy",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def select_proxy(url, proxies):\n    \"\"\"Select a proxy for the url, if applicable.\n    :param url: The url being for the request\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get(\"all\"))\n    proxy_keys = [",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "resolve_proxies",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def resolve_proxies(request, proxies, trust_env=True):\n    \"\"\"This method takes proxy information from a request and configuration\n    input to resolve a mapping of target proxies. This will consider settings\n    such as NO_PROXY to strip proxy configurations.\n    :param request: Request or PreparedRequest\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    :param trust_env: Boolean declaring whether to trust environment configs\n    :rtype: dict\n    \"\"\"\n    proxies = proxies if proxies is not None else {}",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "default_user_agent",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def default_user_agent(name=\"python-requests\"):\n    \"\"\"\n    Return a string representing the default user agent.\n    :rtype: str\n    \"\"\"\n    return f\"{name}/{__version__}\"\ndef default_headers():\n    \"\"\"\n    :rtype: requests.structures.CaseInsensitiveDict\n    \"\"\"",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "default_headers",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def default_headers():\n    \"\"\"\n    :rtype: requests.structures.CaseInsensitiveDict\n    \"\"\"\n    return CaseInsensitiveDict(\n        {\n            \"User-Agent\": default_user_agent(),\n            \"Accept-Encoding\": DEFAULT_ACCEPT_ENCODING,\n            \"Accept\": \"*/*\",\n            \"Connection\": \"keep-alive\",",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_header_links",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def parse_header_links(value):\n    \"\"\"Return a list of parsed link headers proxies.\n    i.e. Link: <http:/.../front.jpeg>; rel=front; type=\"image/jpeg\",<http://.../back.jpeg>; rel=back;type=\"image/jpeg\"\n    :rtype: list\n    \"\"\"\n    links = []\n    replace_chars = \" '\\\"\"\n    value = value.strip(replace_chars)\n    if not value:\n        return links",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "guess_json_utf",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]\n    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):\n        return \"utf-32\"  # BOM included",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "prepend_scheme_if_needed",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def prepend_scheme_if_needed(url, new_scheme):\n    \"\"\"Given a URL that may or may not have a scheme, prepend the given scheme.\n    Does not replace a present scheme with the one provided as an argument.\n    :rtype: str\n    \"\"\"\n    parsed = parse_url(url)\n    scheme, auth, host, port, path, query, fragment = parsed\n    # A defect in urlparse determines that there isn't a netloc present in some\n    # urls. We previously assumed parsing was overly cautious, and swapped the\n    # netloc and path. Due to a lack of tests on the original defect, this is",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_auth_from_url",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n    :rtype: (str,str)\n    \"\"\"\n    parsed = urlparse(url)\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = (\"\", \"\")",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "check_header_validity",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def check_header_validity(header):\n    \"\"\"Verifies that header parts don't contain leading whitespace\n    reserved characters, or return characters.\n    :param header: tuple, in the format (name, value).\n    \"\"\"\n    name, value = header\n    _validate_header_part(header, name, 0)\n    _validate_header_part(header, value, 1)\ndef _validate_header_part(header, header_part, header_validator_index):\n    if isinstance(header_part, str):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "urldefragauth",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def urldefragauth(url):\n    \"\"\"\n    Given a url remove the fragment and the authentication part.\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, params, query, fragment = urlparse(url)\n    # see func:`prepend_scheme_if_needed`\n    if not netloc:\n        netloc, path = path, netloc\n    netloc = netloc.rsplit(\"@\", 1)[-1]",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "rewind_body",
        "kind": 2,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "def rewind_body(prepared_request):\n    \"\"\"Move file pointer back to its recorded starting position\n    so it can be read again on redirect.\n    \"\"\"\n    body_seek = getattr(prepared_request.body, \"seek\", None)\n    if body_seek is not None and isinstance(\n        prepared_request._body_position, integer_types\n    ):\n        try:\n            body_seek(prepared_request._body_position)",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "NETRC_FILES",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "NETRC_FILES = (\".netrc\", \"_netrc\")\nDEFAULT_CA_BUNDLE_PATH = certs.where()\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CA_BUNDLE_PATH",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "DEFAULT_CA_BUNDLE_PATH = certs.where()\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PORTS",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "DEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:\n            import winreg",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ACCEPT_ENCODING",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "DEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:\n            import winreg\n        except ImportError:\n            return False",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "UNRESERVED_SET",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "UNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\"\n)\ndef unquote_unreserved(uri):\n    \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n    :rtype: str\n    \"\"\"\n    parts = uri.split(\"%\")\n    for i in range(1, len(parts)):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "_null = \"\\x00\".encode(\"ascii\")  # encoding to ASCII for Python 3\n_null2 = _null * 2\n_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null2",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "_null2 = _null * 2\n_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null3",
        "kind": 5,
        "importPath": ".build.functions.exams.requests.utils",
        "description": ".build.functions.exams.requests.utils",
        "peekOfCode": "_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]\n    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):",
        "detail": ".build.functions.exams.requests.utils",
        "documentation": {}
    },
    {
        "label": "EmscriptenHTTPConnection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.connection",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.connection",
        "peekOfCode": "class EmscriptenHTTPConnection:\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]\n    default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n    timeout: None | (float)\n    host: str\n    port: int\n    blocksize: int\n    source_address: tuple[str, int] | None\n    socket_options: _TYPE_SOCKET_OPTIONS | None\n    proxy: Url | None",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.connection",
        "documentation": {}
    },
    {
        "label": "EmscriptenHTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.connection",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.connection",
        "peekOfCode": "class EmscriptenHTTPSConnection(EmscriptenHTTPConnection):\n    default_port = port_by_scheme[\"https\"]\n    # all this is basically ignored, as browser handles https\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None\n    cert_file: str | None\n    key_file: str | None\n    key_password: str | None",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.connection",
        "documentation": {}
    },
    {
        "label": "_RequestError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request\n        self.response = response",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_StreamingError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _StreamingError(_RequestError):\n    pass\nclass _TimeoutError(_RequestError):\n    pass\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_TimeoutError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _TimeoutError(_RequestError):\n    pass\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_ReadStream",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,\n        worker: JsProxy,\n        connection_id: int,\n        request: EmscriptenRequest,\n    ):",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_StreamingFetcher",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _StreamingFetcher:\n    def __init__(self) -> None:\n        # make web-worker and data buffer on startup\n        self.streaming_ready = False\n        streaming_worker_code = (\n            files(__package__)\n            .joinpath(\"emscripten_fetch_worker.js\")\n            .read_text(encoding=\"utf-8\")\n        )\n        js_data_blob = js.Blob.new(",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_JSPIReadStream",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _JSPIReadStream(io.RawIOBase):\n    \"\"\"\n    A read stream that uses pyodide.ffi.run_sync to read from a JavaScript fetch\n    response. This requires support for WebAssembly JavaScript Promise Integration\n    in the containing browser, and for pyodide to be launched via runPythonAsync.\n    :param js_read_stream:\n        The JavaScript stream reader\n    :param timeout:\n        Timeout in seconds\n    :param request:",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_in_browser_main_thread",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_in_browser_main_thread() -> bool:\n    return hasattr(js, \"window\") and hasattr(js, \"self\") and js.self == js.window\ndef is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_cross_origin_isolated",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\ndef is_worker_available() -> bool:",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_in_node",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\ndef is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n_fetcher: _StreamingFetcher | None = None",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_worker_available",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n_fetcher: _StreamingFetcher | None = None\nif is_worker_available() and (\n    (is_cross_origin_isolated() and not is_in_browser_main_thread())\n    and (not is_in_node())\n):\n    _fetcher = _StreamingFetcher()\nelse:\n    _fetcher = None",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_streaming_request",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if has_jspi():\n        return send_jspi_request(request, True)\n    elif is_in_node():\n        raise _RequestError(\n            message=NODE_JSPI_ERROR,\n            request=request,\n            response=None,\n        )\n    if _fetcher and streaming_ready():",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_request",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_request(request: EmscriptenRequest) -> EmscriptenResponse:\n    if has_jspi():\n        return send_jspi_request(request, False)\n    elif is_in_node():\n        raise _RequestError(\n            message=NODE_JSPI_ERROR,\n            request=request,\n            response=None,\n        )\n    try:",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_jspi_request",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_jspi_request(\n    request: EmscriptenRequest, streaming: bool\n) -> EmscriptenResponse:\n    \"\"\"\n    Send a request using WebAssembly JavaScript Promise Integration\n    to wrap the asynchronous JavaScript fetch api (experimental).\n    :param request:\n        Request to send\n    :param streaming:\n        Whether to stream the response",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "has_jspi",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def has_jspi() -> bool:\n    \"\"\"\n    Return true if jspi can be used.\n    This requires both browser support and also WebAssembly\n    to be in the correct state - i.e. that the javascript\n    call into python was async not sync.\n    :return: True if jspi can be used.\n    :rtype: bool\n    \"\"\"\n    try:",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "streaming_ready",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def streaming_ready() -> bool | None:\n    if _fetcher:\n        return _fetcher.streaming_ready\n    else:\n        return None  # no fetcher, return None to signify that\nasync def wait_for_streaming_ready() -> bool:\n    if _fetcher:\n        await _fetcher.js_worker_ready_promise\n        return True\n    else:",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "HEADERS_TO_IGNORE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "HEADERS_TO_IGNORE = (\"user-agent\",)\nSUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "SUCCESS_HEADER",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "SUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "SUCCESS_EOF",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "SUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "ERROR_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "ERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "ERROR_EXCEPTION",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "ERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "NODE_JSPI_ERROR",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "NODE_JSPI_ERROR = (\n    \"urllib3 only works in Node.js with pyodide.runPythonAsync\"\n    \" and requires the flag --experimental-wasm-stack-switching in \"\n    \" versions of node <24.\"\n)\ndef send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if has_jspi():\n        return send_jspi_request(request, True)\n    elif is_in_node():\n        raise _RequestError(",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_SHOWN_TIMEOUT_WARNING",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "_SHOWN_TIMEOUT_WARNING = False\ndef _show_timeout_warning() -> None:\n    global _SHOWN_TIMEOUT_WARNING\n    if not _SHOWN_TIMEOUT_WARNING:\n        _SHOWN_TIMEOUT_WARNING = True\n        message = \"Warning: Timeout is not available on main browser thread\"\n        js.console.warn(message)\n_SHOWN_STREAMING_WARNING = False\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_SHOWN_STREAMING_WARNING",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "_SHOWN_STREAMING_WARNING = False\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING\n    if not _SHOWN_STREAMING_WARNING:\n        _SHOWN_STREAMING_WARNING = True\n        message = \"Can't stream HTTP requests because: \\n\"\n        if not is_cross_origin_isolated():\n            message += \"  Page is not cross-origin isolated\\n\"\n        if is_in_browser_main_thread():\n            message += \"  Python is running in main browser thread\\n\"",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "EmscriptenRequest",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.request",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.request",
        "peekOfCode": "class EmscriptenRequest:\n    method: str\n    url: str\n    params: dict[str, str] | None = None\n    body: _TYPE_BODY | None = None\n    headers: dict[str, str] = field(default_factory=dict)\n    timeout: float = 0\n    decode_content: bool = True\n    def set_header(self, name: str, value: str) -> None:\n        self.headers[name.capitalize()] = value",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.request",
        "documentation": {}
    },
    {
        "label": "EmscriptenResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "peekOfCode": "class EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "EmscriptenHttpResponseWrapper",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "peekOfCode": "class EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,\n        connection: BaseHTTPConnection | BaseHTTPSConnection | None = None,\n    ):\n        self._pool = None  # set by pool class\n        self._body = None\n        self._response = internal_response",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "description": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "peekOfCode": "log = logging.getLogger(__name__)\n@dataclass\nclass EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,",
        "detail": ".build.functions.exams.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "WrappedSocket",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "class WrappedSocket:\n    \"\"\"API-compatibility wrapper for Python OpenSSL's Connection-class.\"\"\"\n    def __init__(\n        self,\n        connection: OpenSSL.SSL.Connection,\n        socket: socket_cls,\n        suppress_ragged_eofs: bool = True,\n    ) -> None:\n        self.connection = connection\n        self.socket = socket",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "PyOpenSSLContext",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "class PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)\n        self._options = 0",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "inject_into_urllib3",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "def inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n    util.SSLContext = orig_util_SSLContext",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "extract_from_urllib3",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "def extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n    util.SSLContext = orig_util_SSLContext\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.IS_PYOPENSSL = False\n    util.ssl_.IS_PYOPENSSL = False\ndef _validate_dependencies_met() -> None:\n    \"\"\"\n    Verifies that PyOpenSSL's package-level dependencies have been met.\n    Throws `ImportError` if they are not met.",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "get_subj_alt_name",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "def get_subj_alt_name(peer_cert: X509) -> list[tuple[str, str]]:\n    \"\"\"\n    Given an PyOpenSSL certificate, provides all the subject alternative names.\n    \"\"\"\n    cert = peer_cert.to_cryptography()\n    # We want to find the SAN extension. Ask Cryptography to locate it (it's\n    # faster than looping in Python)\n    try:\n        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value\n    except x509.ExtensionNotFound:",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "__all__ = [\"inject_into_urllib3\", \"extract_from_urllib3\"]\n# Map from urllib3 to PyOpenSSL compatible parameter-values.\n_openssl_versions: dict[int, int] = {\n    util.ssl_.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    util.ssl_.PROTOCOL_TLS_CLIENT: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,\n}\nif hasattr(ssl, \"PROTOCOL_TLSv1_1\") and hasattr(OpenSSL.SSL, \"TLSv1_1_METHOD\"):\n    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD\nif hasattr(ssl, \"PROTOCOL_TLSv1_2\") and hasattr(OpenSSL.SSL, \"TLSv1_2_METHOD\"):",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_stdlib_to_openssl_verify",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "_stdlib_to_openssl_verify = {\n    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,\n    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,\n    ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER\n    + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,\n}\n_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_openssl_to_stdlib_verify",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(\n    OpenSSL.SSL, \"OP_NO_SSLv3\", 0\n)\n_OP_NO_TLSv1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1\", 0)\n_OP_NO_TLSv1_1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_1\", 0)\n_OP_NO_TLSv1_2: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_2\", 0)\n_OP_NO_TLSv1_3: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_3\", 0)",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "SSL_WRITE_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "SSL_WRITE_BLOCKSIZE = 16384\norig_util_SSLContext = util.ssl_.SSLContext\nlog = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "orig_util_SSLContext",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "orig_util_SSLContext = util.ssl_.SSLContext\nlog = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "WrappedSocket.makefile",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "description": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "peekOfCode": "WrappedSocket.makefile = socket_cls.makefile  # type: ignore[attr-defined]\nclass PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)",
        "detail": ".build.functions.exams.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_TYPE_SOCKS_OPTIONS",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.socks",
        "description": ".build.functions.exams.urllib3.contrib.socks",
        "peekOfCode": "class _TYPE_SOCKS_OPTIONS(typing.TypedDict):\n    socks_version: int\n    proxy_host: str | None\n    proxy_port: str | None\n    username: str | None\n    password: str | None\n    rdns: bool\nclass SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.",
        "detail": ".build.functions.exams.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSConnection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.socks",
        "description": ".build.functions.exams.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.\n    \"\"\"\n    def __init__(\n        self,\n        _socks_options: _TYPE_SOCKS_OPTIONS,\n        *args: typing.Any,\n        **kwargs: typing.Any,\n    ) -> None:",
        "detail": ".build.functions.exams.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.socks",
        "description": ".build.functions.exams.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection):\n    pass\nclass SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.",
        "detail": ".build.functions.exams.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.socks",
        "description": ".build.functions.exams.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {",
        "detail": ".build.functions.exams.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPSConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.socks",
        "description": ".build.functions.exams.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,",
        "detail": ".build.functions.exams.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSProxyManager",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.contrib.socks",
        "description": ".build.functions.exams.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,\n    }\n    def __init__(",
        "detail": ".build.functions.exams.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "_LockedObject",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "class _LockedObject(typing.Generic[T]):\n    \"\"\"\n    A wrapper class that hides a specific object behind a lock.\n    The goal here is to provide a simple way to protect access to an object\n    that cannot safely be simultaneously accessed from multiple threads. The\n    intended use of this class is simple: take hold of it with a context\n    manager, which returns the protected object.\n    \"\"\"\n    __slots__ = (\n        \"lock\",",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "HTTP2Connection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "class HTTP2Connection(HTTPSConnection):\n    def __init__(\n        self, host: str, port: int | None = None, **kwargs: typing.Any\n    ) -> None:\n        self._h2_conn = self._new_h2_conn()\n        self._h2_stream: int | None = None\n        self._headers: list[tuple[bytes, bytes]] = []\n        if \"proxy\" in kwargs or \"proxy_config\" in kwargs:  # Defensive:\n            raise NotImplementedError(\"Proxies aren't supported with HTTP/2\")\n        super().__init__(host, port, **kwargs)",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "HTTP2Response",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "class HTTP2Response(BaseHTTPResponse):\n    # TODO: This is a woefully incomplete response object, but works for non-streaming.\n    def __init__(\n        self,\n        status: int,\n        headers: HTTPHeaderDict,\n        request_url: str,\n        data: bytes,\n        decode_content: bool = False,  # TODO: support decoding\n    ) -> None:",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "orig_HTTPSConnection",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "orig_HTTPSConnection = HTTPSConnection\nT = typing.TypeVar(\"T\")\nlog = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "T = typing.TypeVar(\"T\")\nlog = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "log = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "RE_IS_LEGAL_HEADER_NAME",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "RE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.\n    This does not allow for the `:` character in the header name, so should not",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "RE_IS_ILLEGAL_HEADER_VALUE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.connection",
        "description": ".build.functions.exams.urllib3.http2.connection",
        "peekOfCode": "RE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.\n    This does not allow for the `:` character in the header name, so should not\n    be used to validate pseudo-headers.",
        "detail": ".build.functions.exams.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "_HTTP2ProbeCache",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.http2.probe",
        "description": ".build.functions.exams.urllib3.http2.probe",
        "peekOfCode": "class _HTTP2ProbeCache:\n    __slots__ = (\n        \"_lock\",\n        \"_cache_locks\",\n        \"_cache_values\",\n    )\n    def __init__(self) -> None:\n        self._lock = threading.Lock()\n        self._cache_locks: dict[tuple[str, int], threading.RLock] = {}\n        self._cache_values: dict[tuple[str, int], bool | None] = {}",
        "detail": ".build.functions.exams.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_HTTP2_PROBE_CACHE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.probe",
        "description": ".build.functions.exams.urllib3.http2.probe",
        "peekOfCode": "_HTTP2_PROBE_CACHE = _HTTP2ProbeCache()\nset_and_release = _HTTP2_PROBE_CACHE.set_and_release\nacquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.exams.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "set_and_release",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.probe",
        "description": ".build.functions.exams.urllib3.http2.probe",
        "peekOfCode": "set_and_release = _HTTP2_PROBE_CACHE.set_and_release\nacquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.exams.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "acquire_and_get",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.probe",
        "description": ".build.functions.exams.urllib3.http2.probe",
        "peekOfCode": "acquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.exams.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_values",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.probe",
        "description": ".build.functions.exams.urllib3.http2.probe",
        "peekOfCode": "_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.exams.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_reset",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.probe",
        "description": ".build.functions.exams.urllib3.http2.probe",
        "peekOfCode": "_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.exams.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.http2.probe",
        "description": ".build.functions.exams.urllib3.http2.probe",
        "peekOfCode": "__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.exams.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "is_connection_dropped",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.connection",
        "description": ".build.functions.exams.urllib3.util.connection",
        "peekOfCode": "def is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n# This function is copied from socket.py in the Python 2.7 standard\n# library test suite. Added to its signature is only `socket_options`.\n# One additional modification is that we avoid binding to IPv6 servers\n# discovered in DNS if the system doesn't have IPv6 functionality.",
        "detail": ".build.functions.exams.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "create_connection",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.connection",
        "description": ".build.functions.exams.urllib3.util.connection",
        "peekOfCode": "def create_connection(\n    address: tuple[str, int],\n    timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n    source_address: tuple[str, int] | None = None,\n    socket_options: _TYPE_SOCKET_OPTIONS | None = None,\n) -> socket.socket:\n    \"\"\"Connect to *address* and return the socket object.\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance",
        "detail": ".build.functions.exams.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "allowed_gai_family",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.connection",
        "description": ".build.functions.exams.urllib3.util.connection",
        "peekOfCode": "def allowed_gai_family() -> socket.AddressFamily:\n    \"\"\"This function is designed to work in the context of\n    getaddrinfo, where family=socket.AF_UNSPEC is the default and\n    will perform a DNS search for both IPv6 and IPv4 records.\"\"\"\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family\ndef _has_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"",
        "detail": ".build.functions.exams.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "_TYPE_SOCKET_OPTIONS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.connection",
        "description": ".build.functions.exams.urllib3.util.connection",
        "peekOfCode": "_TYPE_SOCKET_OPTIONS = list[tuple[int, int, typing.Union[int, bytes]]]\nif typing.TYPE_CHECKING:\n    from .._base_connection import BaseHTTPConnection\ndef is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n# This function is copied from socket.py in the Python 2.7 standard",
        "detail": ".build.functions.exams.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "HAS_IPV6",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.connection",
        "description": ".build.functions.exams.urllib3.util.connection",
        "peekOfCode": "HAS_IPV6 = _has_ipv6(\"::1\")",
        "detail": ".build.functions.exams.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "connection_requires_http_tunnel",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.proxy",
        "description": ".build.functions.exams.urllib3.util.proxy",
        "peekOfCode": "def connection_requires_http_tunnel(\n    proxy_url: Url | None = None,\n    proxy_config: ProxyConfig | None = None,\n    destination_scheme: str | None = None,\n) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:",
        "detail": ".build.functions.exams.urllib3.util.proxy",
        "documentation": {}
    },
    {
        "label": "_TYPE_FAILEDTELL",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "class _TYPE_FAILEDTELL(Enum):\n    token = 0\n_FAILEDTELL: Final[_TYPE_FAILEDTELL] = _TYPE_FAILEDTELL.token\n_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "ChunksAndContentLength",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "class ChunksAndContentLength(typing.NamedTuple):\n    chunks: typing.Iterable[bytes] | None\n    content_length: int | None\ndef body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n    A 'Content-Length' of 'None' indicates the length of the body",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "make_headers",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "def make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"\n    Shortcuts for generating request headers.",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "set_file_position",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "def set_file_position(\n    body: typing.Any, pos: _TYPE_BODY_POSITION | None\n) -> _TYPE_BODY_POSITION | None:\n    \"\"\"\n    If a position is provided, move file to that point.\n    Otherwise, we'll attempt to record a position for future use.\n    \"\"\"\n    if pos is not None:\n        rewind_body(body, pos)\n    elif getattr(body, \"tell\", None) is not None:",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "rewind_body",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "def rewind_body(body: typing.IO[typing.AnyStr], body_pos: _TYPE_BODY_POSITION) -> None:\n    \"\"\"\n    Attempt to rewind body to a certain position.\n    Primarily used for request redirects and retries.\n    :param body:\n        File-like object that supports seek.\n    :param int pos:\n        Position to seek to in file.\n    \"\"\"\n    body_seek = getattr(body, \"seek\", None)",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "body_to_chunks",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "def body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n    A 'Content-Length' of 'None' indicates the length of the body\n    can't be determined so should use 'Transfer-Encoding: chunked'\n    for framing instead.\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "SKIP_HEADER",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "SKIP_HEADER = \"@@@SKIP_HEADER@@@\"\nSKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "SKIPPABLE_HEADERS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "SKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "ACCEPT_ENCODING",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "ACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:\n    ACCEPT_ENCODING += \",br\"",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "_TYPE_BODY_POSITION",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "_METHODS_NOT_EXPECTING_BODY",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.request",
        "description": ".build.functions.exams.urllib3.util.request",
        "peekOfCode": "_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "is_fp_closed",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.response",
        "description": ".build.functions.exams.urllib3.util.response",
        "peekOfCode": "def is_fp_closed(obj: object) -> bool:\n    \"\"\"\n    Checks whether a given file-like object is closed.\n    :param obj:\n        The file-like object to check.\n    \"\"\"\n    try:\n        # Check `isclosed()` first, in case Python3 doesn't set `closed`.\n        # GH Issue #928\n        return obj.isclosed()  # type: ignore[no-any-return, attr-defined]",
        "detail": ".build.functions.exams.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "assert_header_parsing",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.response",
        "description": ".build.functions.exams.urllib3.util.response",
        "peekOfCode": "def assert_header_parsing(headers: httplib.HTTPMessage) -> None:\n    \"\"\"\n    Asserts whether all headers have been successfully parsed.\n    Extracts encountered errors from the result of parsing headers.\n    Only works on Python 3.\n    :param http.client.HTTPMessage headers: Headers to verify.\n    :raises urllib3.exceptions.HeaderParsingError:\n        If parsing errors are found.\n    \"\"\"\n    # This will fail silently if we pass in the wrong kind of parameter.",
        "detail": ".build.functions.exams.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "is_response_to_head",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.response",
        "description": ".build.functions.exams.urllib3.util.response",
        "peekOfCode": "def is_response_to_head(response: httplib.HTTPResponse) -> bool:\n    \"\"\"\n    Checks whether the request of a response has been a HEAD-request.\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    \"\"\"\n    # FIXME: Can we do this somehow without accessing private httplib _method?\n    method_str = response._method  # type: str  # type: ignore[attr-defined]\n    return method_str.upper() == \"HEAD\"",
        "detail": ".build.functions.exams.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "RequestHistory",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.retry",
        "description": ".build.functions.exams.urllib3.util.retry",
        "peekOfCode": "class RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\nclass Retry:\n    \"\"\"Retry configuration.\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.",
        "detail": ".build.functions.exams.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.retry",
        "description": ".build.functions.exams.urllib3.util.retry",
        "peekOfCode": "class Retry:\n    \"\"\"Retry configuration.\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n    Retries can be defined as a default for a pool:\n    .. code-block:: python\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request(\"GET\", \"https://example.com/\")\n    Or per-request (which overrides the default for the pool):",
        "detail": ".build.functions.exams.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.retry",
        "description": ".build.functions.exams.urllib3.util.retry",
        "peekOfCode": "log = logging.getLogger(__name__)\n# Data structure for representing the metadata of requests that result in a retry.\nclass RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\nclass Retry:\n    \"\"\"Retry configuration.",
        "detail": ".build.functions.exams.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry.DEFAULT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.retry",
        "description": ".build.functions.exams.urllib3.util.retry",
        "peekOfCode": "Retry.DEFAULT = Retry(3)",
        "detail": ".build.functions.exams.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "assert_fingerprint",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n    if cert is None:\n        raise SSLError(\"No certificate for the peer.\")",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "resolve_cert_reqs",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def resolve_cert_reqs(candidate: None | int | str) -> VerifyMode:\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "resolve_ssl_version",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def resolve_ssl_version(candidate: None | int | str) -> int:\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "create_urllib3_context",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def create_urllib3_context(\n    ssl_version: int | None = None,\n    cert_reqs: int | None = None,\n    options: int | None = None,\n    ciphers: str | None = None,\n    ssl_minimum_version: int | None = None,\n    ssl_maximum_version: int | None = None,\n    verify_flags: int | None = None,\n) -> ssl.SSLContext:\n    \"\"\"Creates and configures an :class:`ssl.SSLContext` instance for use with urllib3.",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = None,\n    certfile: str | None = None,\n    cert_reqs: int | None = None,\n    ca_certs: str | None = None,\n    server_hostname: str | None = None,\n    ssl_version: int | None = None,\n    ciphers: str | None = None,\n    ssl_context: ssl.SSLContext | None = None,",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "is_ipaddress",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "def is_ipaddress(hostname: str | bytes) -> bool:\n    \"\"\"Detects whether the hostname given is an IPv4 or IPv6 address.\n    Also detects IPv6 addresses with Zone IDs.\n    :param str hostname: Hostname to examine.\n    :return: True if the hostname is an IP address, False otherwise.\n    \"\"\"\n    if isinstance(hostname, bytes):\n        # IDN A-label bytes are ASCII compatible.\n        hostname = hostname.decode(\"ascii\")\n    return bool(_IPV4_RE.match(hostname) or _BRACELESS_IPV6_ADDRZ_RE.match(hostname))",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "SSLContext",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "SSLContext = None\nSSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "SSLTransport",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "SSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "HAS_NEVER_CHECK_COMMON_NAME",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "HAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "IS_PYOPENSSL",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "IS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ALPN_PROTOCOLS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "ALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "_TYPE_VERSION_INFO",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "HASHFUNC_MAP",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "HASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,\n) -> bool:\n    \"\"\"Return True for CPython 3.9.3+ or 3.10+ and PyPy 7.3.8+ where",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "_TYPE_PEER_CERT_RET",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_",
        "description": ".build.functions.exams.urllib3.util.ssl_",
        "peekOfCode": "_TYPE_PEER_CERT_RET = typing.Union[\"_TYPE_PEER_CERT_RET_DICT\", bytes, None]\ndef assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n    if cert is None:",
        "detail": ".build.functions.exams.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "CertificateError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "peekOfCode": "class CertificateError(ValueError):\n    pass\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:",
        "detail": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "match_hostname",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "peekOfCode": "def match_hostname(\n    cert: _TYPE_PEER_CERT_RET_DICT | None,\n    hostname: str,\n    hostname_checks_common_name: bool = False,\n) -> None:\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n    CertificateError is raised on failure. On success, the function\n    returns nothing.",
        "detail": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "peekOfCode": "__version__ = \"3.5.0.1\"\nclass CertificateError(ValueError):\n    pass\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []",
        "detail": ".build.functions.exams.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "SSLTransport",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.ssltransport",
        "description": ".build.functions.exams.urllib3.util.ssltransport",
        "peekOfCode": "class SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"\n    @staticmethod\n    def _validate_ssl_context_for_tls_in_tls(ssl_context: ssl.SSLContext) -> None:",
        "detail": ".build.functions.exams.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_WriteBuffer",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssltransport",
        "description": ".build.functions.exams.urllib3.util.ssltransport",
        "peekOfCode": "_WriteBuffer = typing.Union[bytearray, memoryview]\n_ReturnValue = typing.TypeVar(\"_ReturnValue\")\nSSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.",
        "detail": ".build.functions.exams.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_ReturnValue",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssltransport",
        "description": ".build.functions.exams.urllib3.util.ssltransport",
        "peekOfCode": "_ReturnValue = typing.TypeVar(\"_ReturnValue\")\nSSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "SSL_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.ssltransport",
        "description": ".build.functions.exams.urllib3.util.ssltransport",
        "peekOfCode": "SSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"\n    @staticmethod",
        "detail": ".build.functions.exams.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_TYPE_DEFAULT",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.timeout",
        "description": ".build.functions.exams.urllib3.util.timeout",
        "peekOfCode": "class _TYPE_DEFAULT(Enum):\n    # This value should never be passed to socket.settimeout() so for safety we use a -1.\n    # socket.settimout() raises a ValueError for negative values.\n    token = -1\n_DEFAULT_TIMEOUT: Final[_TYPE_DEFAULT] = _TYPE_DEFAULT.token\n_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\nclass Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python",
        "detail": ".build.functions.exams.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.timeout",
        "description": ".build.functions.exams.urllib3.util.timeout",
        "peekOfCode": "class Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python\n        import urllib3\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n        http = urllib3.PoolManager(timeout=timeout)\n        resp = http.request(\"GET\", \"https://example.com/\")\n        print(resp.status)\n    Or per-request (which overrides the default for the pool):",
        "detail": ".build.functions.exams.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "_TYPE_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.timeout",
        "description": ".build.functions.exams.urllib3.util.timeout",
        "peekOfCode": "_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\nclass Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python\n        import urllib3\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n        http = urllib3.PoolManager(timeout=timeout)\n        resp = http.request(\"GET\", \"https://example.com/\")\n        print(resp.status)",
        "detail": ".build.functions.exams.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "Url",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "class Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),\n            (\"query\", typing.Optional[str]),",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "def parse_url(url: str) -> Url:\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 and RFC 6874 compliant.\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n    Partly backwards-compatible with :mod:`urllib.parse`.\n    Example:",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_NORMALIZABLE_SCHEMES",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_NORMALIZABLE_SCHEMES = (\"http\", \"https\", None)\n# Almost all of these patterns were derived from the\n# 'rfc3986' module: https://github.com/python-hyper/rfc3986\n_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_PERCENT_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_SCHEME_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_URI_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV4_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HEX_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_LS32_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_subs",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_variations",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",\n    # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_UNRESERVED_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\\-~\"\n_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_ZONE_ID_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_ADDRZ_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_REG_NAME_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_TARGET_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV4_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_ADDRZ_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_BRACELESS_IPV6_ADDRZ_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_ZONE_ID_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HOST_PORT_PAT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HOST_PORT_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_UNRESERVED_CHARS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_SUB_DELIM_CHARS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_USERINFO_CHARS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_PATH_CHARS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_QUERY_CHARS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.url",
        "description": ".build.functions.exams.urllib3.util.url",
        "peekOfCode": "_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),",
        "detail": ".build.functions.exams.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.util",
        "description": ".build.functions.exams.urllib3.util.util",
        "peekOfCode": "def to_bytes(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> bytes:\n    if isinstance(x, bytes):\n        return x\n    elif not isinstance(x, str):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.encode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.encode()",
        "detail": ".build.functions.exams.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "to_str",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.util",
        "description": ".build.functions.exams.urllib3.util.util",
        "peekOfCode": "def to_str(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> str:\n    if isinstance(x, str):\n        return x\n    elif not isinstance(x, bytes):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.decode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.decode()",
        "detail": ".build.functions.exams.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "reraise",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.util",
        "description": ".build.functions.exams.urllib3.util.util",
        "peekOfCode": "def reraise(\n    tp: type[BaseException] | None,\n    value: BaseException,\n    tb: TracebackType | None = None,\n) -> typing.NoReturn:\n    try:\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:",
        "detail": ".build.functions.exams.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "select_wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.wait",
        "description": ".build.functions.exams.urllib3.util.wait",
        "peekOfCode": "def select_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    rcheck = []\n    wcheck = []",
        "detail": ".build.functions.exams.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "poll_wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.wait",
        "description": ".build.functions.exams.urllib3.util.wait",
        "peekOfCode": "def poll_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    mask = 0\n    if read:",
        "detail": ".build.functions.exams.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.wait",
        "description": ".build.functions.exams.urllib3.util.wait",
        "peekOfCode": "def wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    # We delay choosing which implementation to use until the first time we're\n    # called. We could do it at import time, but then we might make the wrong\n    # decision if someone goes wild with monkeypatching select.poll after\n    # we're imported.",
        "detail": ".build.functions.exams.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_read",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.wait",
        "description": ".build.functions.exams.urllib3.util.wait",
        "peekOfCode": "def wait_for_read(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for reading to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, read=True, timeout=timeout)\ndef wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)",
        "detail": ".build.functions.exams.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_write",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.util.wait",
        "description": ".build.functions.exams.urllib3.util.wait",
        "peekOfCode": "def wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)",
        "detail": ".build.functions.exams.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.util.wait",
        "description": ".build.functions.exams.urllib3.util.wait",
        "peekOfCode": "__all__ = [\"wait_for_read\", \"wait_for_write\"]\n# How should we wait on sockets?\n#\n# There are two types of APIs you can use for waiting on sockets: the fancy\n# modern stateful APIs like epoll/kqueue, and the older stateless APIs like\n# select/poll. The stateful APIs are more efficient when you have a lots of\n# sockets to keep track of, because you can set them up once and then use them\n# lots of times. But we only ever want to wait on a single socket at a time\n# and don't want to keep track of state, so the stateless APIs are actually\n# more efficient. So we want to use select() or poll().",
        "detail": ".build.functions.exams.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "ProxyConfig",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3._base_connection",
        "description": ".build.functions.exams.urllib3._base_connection",
        "peekOfCode": "class ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str",
        "detail": ".build.functions.exams.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_ResponseOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3._base_connection",
        "description": ".build.functions.exams.urllib3._base_connection",
        "peekOfCode": "class _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str\n    preload_content: bool\n    decode_content: bool\n    enforce_content_length: bool\nif typing.TYPE_CHECKING:\n    import ssl",
        "detail": ".build.functions.exams.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_TYPE_BODY",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._base_connection",
        "description": ".build.functions.exams.urllib3._base_connection",
        "peekOfCode": "_TYPE_BODY = typing.Union[bytes, typing.IO[typing.Any], typing.Iterable[bytes], str]\nclass ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str",
        "detail": ".build.functions.exams.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_Sentinel",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "class _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "RecentlyUsedContainer",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "class RecentlyUsedContainer(typing.Generic[_KT, _VT], typing.MutableMapping[_KT, _VT]):\n    \"\"\"\n    Provides a thread-safe dict-like container which maintains up to\n    ``maxsize`` keys while throwing away the least-recently-used keys beyond\n    ``maxsize``.\n    :param maxsize:\n        Maximum number of recent elements to retain.\n    :param dispose_func:\n        Every time an item is evicted from the container,\n        ``dispose_func(value)`` is called.  Callback which will get called",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "HTTPHeaderDictItemView",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "class HTTPHeaderDictItemView(set[tuple[str, str]]):\n    \"\"\"\n    HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of\n    address.\n    If we directly try to get an item with a particular name, we will get a string\n    back that is the concatenated version of all the values:\n    >>> d['X-Header-Name']\n    'Value1, Value2, Value3'\n    However, if we iterate over an HTTPHeaderDict's items, we will optionally combine\n    these values based on whether combine=True was called when building up the dictionary",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "HTTPHeaderDict",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "class HTTPHeaderDict(typing.MutableMapping[str, str]):\n    \"\"\"\n    :param headers:\n        An iterable of field-value pairs. Must not contain multiple field names\n        when compared case-insensitively.\n    :param kwargs:\n        Additional field-value pairs to pass in to ``dict.update``.\n    A ``dict`` like container for storing HTTP Headers.\n    Field names are stored and compared case-insensitively in compliance with\n    RFC 7230. Iteration provides the first case-sensitive key seen for each",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "ensure_can_construct_http_header_dict",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "def ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.\n        return typing.cast(typing.Mapping[str, str], potential)\n    elif isinstance(potential, typing.Iterable):",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "__all__ = [\"RecentlyUsedContainer\", \"HTTPHeaderDict\"]\n# Key type\n_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_KT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_VT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_DT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "ValidHTTPHeaderSource",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._collections",
        "description": ".build.functions.exams.urllib3._collections",
        "peekOfCode": "ValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(\n    potential: object,",
        "detail": ".build.functions.exams.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "RequestMethods",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3._request_methods",
        "description": ".build.functions.exams.urllib3._request_methods",
        "peekOfCode": "class RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n    Provides behavior for making common types of HTTP request methods and\n    decides which type of request field encoding to use.\n    Specifically,\n    :meth:`.request_encode_url` is for sending requests whose fields are\n    encoded in the URL (such as GET, HEAD, DELETE).",
        "detail": ".build.functions.exams.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._request_methods",
        "description": ".build.functions.exams.urllib3._request_methods",
        "peekOfCode": "__all__ = [\"RequestMethods\"]\n_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.",
        "detail": ".build.functions.exams.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "_TYPE_ENCODE_URL_FIELDS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._request_methods",
        "description": ".build.functions.exams.urllib3._request_methods",
        "peekOfCode": "_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n    Provides behavior for making common types of HTTP request methods and",
        "detail": ".build.functions.exams.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._version",
        "description": ".build.functions.exams.urllib3._version",
        "peekOfCode": "__all__ = [\n    \"__version__\",\n    \"__version_tuple__\",\n    \"version\",\n    \"version_tuple\",\n    \"__commit_id__\",\n    \"commit_id\",\n]\nTYPE_CHECKING = False\nif TYPE_CHECKING:",
        "detail": ".build.functions.exams.urllib3._version",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._version",
        "description": ".build.functions.exams.urllib3._version",
        "peekOfCode": "TYPE_CHECKING = False\nif TYPE_CHECKING:\n    from typing import Tuple\n    from typing import Union\n    VERSION_TUPLE = Tuple[Union[int, str], ...]\n    COMMIT_ID = Union[str, None]\nelse:\n    VERSION_TUPLE = object\n    COMMIT_ID = object\nversion: str",
        "detail": ".build.functions.exams.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._version",
        "description": ".build.functions.exams.urllib3._version",
        "peekOfCode": "__version__ = version = '2.6.3'\n__version_tuple__ = version_tuple = (2, 6, 3)\n__commit_id__ = commit_id = None",
        "detail": ".build.functions.exams.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._version",
        "description": ".build.functions.exams.urllib3._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (2, 6, 3)\n__commit_id__ = commit_id = None",
        "detail": ".build.functions.exams.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__commit_id__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3._version",
        "description": ".build.functions.exams.urllib3._version",
        "peekOfCode": "__commit_id__ = commit_id = None",
        "detail": ".build.functions.exams.urllib3._version",
        "documentation": {}
    },
    {
        "label": "HTTPConnection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "class HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling\n      Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "HTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "class HTTPSConnection(HTTPConnection):\n    \"\"\"\n    Many of the parameters to this constructor are passed to the underlying SSL\n    socket by means of :py:func:`urllib3.util.ssl_wrap_socket`.\n    \"\"\"\n    default_port = port_by_scheme[\"https\"]  # type: ignore[misc]\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "_WrappedAndVerifiedSocket",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "class _WrappedAndVerifiedSocket(typing.NamedTuple):\n    \"\"\"\n    Wrapped socket and whether the connection is\n    verified after the TLS handshake\n    \"\"\"\n    socket: ssl.SSLSocket | SSLTransport\n    is_verified: bool\ndef _ssl_wrap_socket_and_match_hostname(\n    sock: socket.socket,\n    *,",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "DummyConnection",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "class DummyConnection:\n    \"\"\"Used to detect a failed ConnectionCls import.\"\"\"\nif not ssl:\n    HTTPSConnection = DummyConnection  # type: ignore[misc, assignment] # noqa: F811\nVerifiedHTTPSConnection = HTTPSConnection\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "ConnectionError = ConnectionError\nBrokenPipeError = BrokenPipeError\nlog = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "BrokenPipeError",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "BrokenPipeError = BrokenPipeError\nlog = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "log = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "port_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "port_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "RECENT_DATE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "RECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "_CONTAINS_CONTROL_CHAR_RE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "VerifiedHTTPSConnection",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connection",
        "description": ".build.functions.exams.urllib3.connection",
        "peekOfCode": "VerifiedHTTPSConnection = HTTPSConnection\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"\n    return Url(scheme=scheme, host=conn.host, port=conn.port, path=path).url",
        "detail": ".build.functions.exams.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.connectionpool",
        "description": ".build.functions.exams.urllib3.connectionpool",
        "peekOfCode": "class ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.\n    \"\"\"\n    scheme: str | None = None",
        "detail": ".build.functions.exams.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.connectionpool",
        "description": ".build.functions.exams.urllib3.connectionpool",
        "peekOfCode": "class HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n    :param timeout:",
        "detail": ".build.functions.exams.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPSConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.connectionpool",
        "description": ".build.functions.exams.urllib3.connectionpool",
        "peekOfCode": "class HTTPSConnectionPool(HTTPConnectionPool):\n    \"\"\"\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.",
        "detail": ".build.functions.exams.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "connection_from_url",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.connectionpool",
        "description": ".build.functions.exams.urllib3.connectionpool",
        "peekOfCode": "def connection_from_url(url: str, **kw: typing.Any) -> HTTPConnectionPool:\n    \"\"\"\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n    :param \\\\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like",
        "detail": ".build.functions.exams.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connectionpool",
        "description": ".build.functions.exams.urllib3.connectionpool",
        "peekOfCode": "log = logging.getLogger(__name__)\n_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded",
        "detail": ".build.functions.exams.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "_TYPE_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connectionpool",
        "description": ".build.functions.exams.urllib3.connectionpool",
        "peekOfCode": "_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.",
        "detail": ".build.functions.exams.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "_blocking_errnos",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.connectionpool",
        "description": ".build.functions.exams.urllib3.connectionpool",
        "peekOfCode": "_blocking_errnos = {errno.EAGAIN, errno.EWOULDBLOCK}\nclass HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.",
        "detail": ".build.functions.exams.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class HTTPError(Exception):\n    \"\"\"Base exception used by this module.\"\"\"\nclass HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "PoolError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)\nclass RequestError(PoolError):",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class RequestError(PoolError):\n    \"\"\"Base exception for PoolErrors that have associated URLs.\"\"\"\n    def __init__(self, pool: ConnectionPool, url: str | None, message: str) -> None:\n        self.url = url\n        super().__init__(pool, message)\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self.url, self._message)\nclass SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"\nclass ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n    # The original error is also available as __cause__.\n    original_error: Exception\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\nclass DecodeError(HTTPError):",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n    # The original error is also available as __cause__.\n    original_error: Exception\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\nclass DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\nclass ProtocolError(HTTPError):",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DecodeError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\nclass ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "MaxRetryError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n    \"\"\"\n    def __init__(\n        self, pool: ConnectionPool, url: str | None, reason: Exception | None = None",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HostChangedError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class HostChangedError(RequestError):\n    \"\"\"Raised when an existing pool gets a request for a foreign host.\"\"\"\n    def __init__(\n        self, pool: ConnectionPool, url: str, retries: Retry | int = 3\n    ) -> None:\n        message = f\"Tried to open a foreign host with url: {url}\"\n        super().__init__(pool, url, message)\n        self.retries = retries\nclass TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutStateError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"\nclass TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeoutError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        self._message = message\n        super().__init__(f\"{conn}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NewConnectionError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        self._message = message\n        super().__init__(f\"{conn}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)\n    @property",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NameResolutionError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class NameResolutionError(NewConnectionError):\n    \"\"\"Raised when host name resolution fails.\"\"\"\n    def __init__(self, host: str, conn: HTTPConnection, reason: socket.gaierror):\n        message = f\"Failed to resolve '{host}' ({reason})\"\n        self._host = host\n        self._reason = reason\n        super().__init__(conn, message)\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (self._host, None, self._reason)",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyPoolError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class EmptyPoolError(PoolError):\n    \"\"\"Raised when a pool runs out of connections and no more are allowed.\"\"\"\nclass FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "FullPoolError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ClosedPoolError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationValueError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "URLSchemeUnknown",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"\n        super().__init__(message)\n        self.scheme = scheme\nclass ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"\nclass SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SecurityWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InsecureRequestWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NotOpenSSLWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SystemTimeWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InsecurePlatformWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DependencyWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseNotChunked",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "BodyNotHttplibCompatible",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "IncompleteRead",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.\n    \"\"\"\n    partial: int  # type: ignore[assignment]\n    expected: int\n    def __init__(self, partial: int, expected: int) -> None:\n        self.partial = partial",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidChunkLength",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class InvalidChunkLength(HTTPError, httplib_IncompleteRead):\n    \"\"\"Invalid chunk length in a chunked response.\"\"\"\n    def __init__(self, response: HTTPResponse, length: bytes) -> None:\n        self.partial: int = response.tell()  # type: ignore[assignment]\n        self.expected: int | None = response.length_remaining\n        self.response = response\n        self.length = length\n    def __repr__(self) -> str:\n        return \"InvalidChunkLength(got length %r, %i bytes read)\" % (\n            self.length,",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class InvalidHeader(HTTPError):\n    \"\"\"The header provided was somehow invalid.\"\"\"\nclass ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxySchemeUnknown",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None\n        if scheme is None:\n            message = \"Proxy URL had no scheme, should start with http:// or https://\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxySchemeUnsupported",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class ProxySchemeUnsupported(ValueError):\n    \"\"\"Fetching HTTPS resources through HTTPS proxies is unsupported\"\"\"\nclass HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\nclass UnrewindableBodyError(HTTPError):",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HeaderParsingError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\nclass UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "UnrewindableBodyError",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "class UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "_TYPE_REDUCE_RESULT",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.exceptions",
        "description": ".build.functions.exams.urllib3.exceptions",
        "peekOfCode": "ConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestField",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "class RequestField:\n    \"\"\"\n    A data container for request body parameters.\n    :param name:\n        The name of this request field. Must be unicode.\n    :param data:\n        The data/value body.\n    :param filename:\n        An optional filename of the request field. Must be unicode.\n    :param headers:",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "guess_content_type",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "def guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.\n    :param filename:\n        The filename to guess the \"Content-Type\" of using :mod:`mimetypes`.\n    :param default:\n        If no \"Content-Type\" can be guessed, default to `default`.\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param_rfc2231",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "def format_header_param_rfc2231(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Helper function to format and quote a single header parameter using the\n    strategy defined in RFC 2231.\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows\n    `RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_multipart_header_param",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "def format_multipart_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Format and quote a single multipart header parameter.\n    This follows the `WHATWG HTML Standard`_ as of 2021/06/10, matching\n    the behavior of current browser and curl versions. Values are\n    assumed to be UTF-8. The ``\\\\n``, ``\\\\r``, and ``\"`` characters are\n    percent encoded.\n    .. _WHATWG HTML Standard:\n        https://html.spec.whatwg.org/multipage/\n        form-control-infrastructure.html#multipart-form-data",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param_html5",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "def format_header_param_html5(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n    warnings.warn(\n        \"'format_header_param_html5' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "def format_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n    warnings.warn(\n        \"'format_header_param' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELD_VALUE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "_TYPE_FIELD_VALUE = typing.Union[str, bytes]\n_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    tuple[str, _TYPE_FIELD_VALUE],\n    tuple[str, _TYPE_FIELD_VALUE, str],\n]\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELD_VALUE_TUPLE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.fields",
        "description": ".build.functions.exams.urllib3.fields",
        "peekOfCode": "_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    tuple[str, _TYPE_FIELD_VALUE],\n    tuple[str, _TYPE_FIELD_VALUE, str],\n]\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.",
        "detail": ".build.functions.exams.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "choose_boundary",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.filepost",
        "description": ".build.functions.exams.urllib3.filepost",
        "peekOfCode": "def choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.",
        "detail": ".build.functions.exams.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "iter_field_objects",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.filepost",
        "description": ".build.functions.exams.urllib3.filepost",
        "peekOfCode": "def iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.\n    \"\"\"\n    iterable: typing.Iterable[RequestField | tuple[str, _TYPE_FIELD_VALUE_TUPLE]]\n    if isinstance(fields, typing.Mapping):\n        iterable = fields.items()\n    else:",
        "detail": ".build.functions.exams.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "encode_multipart_formdata",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.filepost",
        "description": ".build.functions.exams.urllib3.filepost",
        "peekOfCode": "def encode_multipart_formdata(\n    fields: _TYPE_FIELDS, boundary: str | None = None\n) -> tuple[bytes, str]:\n    \"\"\"\n    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n    :param fields:\n        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n        Values are processed by :func:`urllib3.fields.RequestField.from_tuples`.\n    :param boundary:\n        If not specified, then a random boundary will be generated using",
        "detail": ".build.functions.exams.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "writer",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.filepost",
        "description": ".build.functions.exams.urllib3.filepost",
        "peekOfCode": "writer = codecs.lookup(\"utf-8\")[3]\n_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"",
        "detail": ".build.functions.exams.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELDS_SEQUENCE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.filepost",
        "description": ".build.functions.exams.urllib3.filepost",
        "peekOfCode": "_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.",
        "detail": ".build.functions.exams.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELDS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.filepost",
        "description": ".build.functions.exams.urllib3.filepost",
        "peekOfCode": "_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:",
        "detail": ".build.functions.exams.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "PoolKey",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "class PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n    key_scheme: str\n    key_host: str\n    key_port: int | None\n    key_timeout: Timeout | float | int | None",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "PoolManager",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "class PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "ProxyManager",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "class ProxyManager(PoolManager):\n    \"\"\"\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n    :param proxy_url:\n        The URL of the proxy to be used.\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "proxy_from_url",
        "kind": 2,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "def proxy_from_url(url: str, **kw: typing.Any) -> ProxyManager:\n    return ProxyManager(proxy_url=url, **kw)",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "__all__ = [\"PoolManager\", \"ProxyManager\", \"proxy_from_url\"]\nlog = logging.getLogger(__name__)\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "log = logging.getLogger(__name__)\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "SSL_KEYWORDS",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "SSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",\n    \"ca_cert_dir\",",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "_DEFAULT_BLOCKSIZE = 16384\nclass PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n    key_scheme: str\n    key_host: str\n    key_port: int | None",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "key_fn_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "key_fn_by_scheme = {\n    \"http\": functools.partial(_default_key_normalizer, PoolKey),\n    \"https\": functools.partial(_default_key_normalizer, PoolKey),\n}\npool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "pool_classes_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.poolmanager",
        "description": ".build.functions.exams.urllib3.poolmanager",
        "peekOfCode": "pool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n    :param headers:\n        Headers to include with all requests, unless other headers are given",
        "detail": ".build.functions.exams.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "ContentDecoder",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class ContentDecoder:\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        raise NotImplementedError()\n    @property\n    def has_unconsumed_tail(self) -> bool:\n        raise NotImplementedError()\n    def flush(self) -> bytes:\n        raise NotImplementedError()\nclass DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "DeflateDecoder",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._first_try = True\n        self._first_try_data = b\"\"\n        self._unfed_data = b\"\"\n        self._obj = zlib.decompressobj()\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        data = self._unfed_data + data\n        self._unfed_data = b\"\"\n        if not data and not self._obj.unconsumed_tail:",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "GzipDecoderState",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class GzipDecoderState:\n    FIRST_MEMBER = 0\n    OTHER_MEMBERS = 1\n    SWALLOW_DATA = 2\nclass GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n        self._unconsumed_tail = b\"\"\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "GzipDecoder",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n        self._unconsumed_tail = b\"\"\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        ret = bytearray()\n        if self._state == GzipDecoderState.SWALLOW_DATA:\n            return bytes(ret)\n        if max_length == 0:",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "MultiDecoder",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class MultiDecoder(ContentDecoder):\n    \"\"\"\n    From RFC7231:\n        If one or more encodings have been applied to a representation, the\n        sender that applied the encodings MUST generate a Content-Encoding\n        header field that lists the content codings in the order in which\n        they were applied.\n    \"\"\"\n    # Maximum allowed number of chained HTTP encodings in the\n    # Content-Encoding header.",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "BytesQueueBuffer",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class BytesQueueBuffer:\n    \"\"\"Memory-efficient bytes buffer\n    To return decoded data in read() and still follow the BufferedIOBase API, we need a\n    buffer to always return the correct amount of bytes.\n    This buffer should be filled using calls to put()\n    Our maximum memory usage is determined by the sum of the size of:\n     * self.buffer, which contains the full data\n     * the largest chunk that we will copy in get()\n    \"\"\"\n    def __init__(self) -> None:",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "BaseHTTPResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class BaseHTTPResponse(io.IOBase):\n    CONTENT_DECODERS = [\"gzip\", \"x-gzip\", \"deflate\"]\n    if brotli is not None:\n        CONTENT_DECODERS += [\"br\"]\n    if HAS_ZSTD:\n        CONTENT_DECODERS += [\"zstd\"]\n    REDIRECT_STATUSES = [301, 302, 303, 307, 308]\n    DECODER_ERROR_CLASSES: tuple[type[Exception], ...] = (IOError, zlib.error)\n    if brotli is not None:\n        DECODER_ERROR_CLASSES += (brotli.error,)",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "HTTPResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "class HTTPResponse(BaseHTTPResponse):\n    \"\"\"\n    HTTP Response container.\n    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\n    loaded and decoded on-demand when the ``data`` property is accessed.  This\n    class is also compatible with the Python standard library's :mod:`io`\n    module, and can hence be treated as a readable object in the context of that\n    framework.\n    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n    :param preload_content:",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.exams.urllib3.response",
        "description": ".build.functions.exams.urllib3.response",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass ContentDecoder:\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        raise NotImplementedError()\n    @property\n    def has_unconsumed_tail(self) -> bool:\n        raise NotImplementedError()\n    def flush(self) -> bytes:\n        raise NotImplementedError()\nclass DeflateDecoder(ContentDecoder):",
        "detail": ".build.functions.exams.urllib3.response",
        "documentation": {}
    },
    {
        "label": "ICatalystCacheResp",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.cache._segment",
        "description": ".build.functions.exams.zcatalyst_sdk.cache._segment",
        "peekOfCode": "class ICatalystCacheResp(ICatalystCache):\n    project_details: Optional[ICatalystProject]\nclass Segment(ParsableComponent):\n    def __init__(self, cache_instance, segment_details: Dict):\n        if segment_details:\n            validator.is_non_empty_dict(segment_details, 'segment_details', CatalystCacheError)\n        self._requester: AuthorizedHttpClient = cache_instance._requester\n        self._id = segment_details.get('id') if segment_details else None\n        self._segment_details = segment_details\n    def __repr__(self) -> str:",
        "detail": ".build.functions.exams.zcatalyst_sdk.cache._segment",
        "documentation": {}
    },
    {
        "label": "Segment",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.cache._segment",
        "description": ".build.functions.exams.zcatalyst_sdk.cache._segment",
        "peekOfCode": "class Segment(ParsableComponent):\n    def __init__(self, cache_instance, segment_details: Dict):\n        if segment_details:\n            validator.is_non_empty_dict(segment_details, 'segment_details', CatalystCacheError)\n        self._requester: AuthorizedHttpClient = cache_instance._requester\n        self._id = segment_details.get('id') if segment_details else None\n        self._segment_details = segment_details\n    def __repr__(self) -> str:\n        return str(self.to_dict())\n    def get_component_name(self):",
        "detail": ".build.functions.exams.zcatalyst_sdk.cache._segment",
        "documentation": {}
    },
    {
        "label": "Connector",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.connection._connector",
        "description": ".build.functions.exams.zcatalyst_sdk.connection._connector",
        "peekOfCode": "class Connector:\n    def __init__(self, connection_instance, connector_details: Dict[str, str]) -> None:\n        self._app = connection_instance._app\n        self._requester: HttpClient = connection_instance._requester\n        self.connector_name = connector_details.get(CONNECTOR_NAME)\n        self.auth_url = connector_details.get(AUTH_URL)\n        self.refresh_url = connector_details.get(REFRESH_URL)\n        self.refresh_token = connector_details.get(REFRESH_TOKEN)\n        self.client_id = connector_details.get(CLIENT_ID)\n        self.client_secret = connector_details.get(CLIENT_SECRET)",
        "detail": ".build.functions.exams.zcatalyst_sdk.connection._connector",
        "documentation": {}
    },
    {
        "label": "BulkJob",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkJob(Component, ABC):\n    def __init__(self, table_instance, operation: str):\n        self._requester: AuthorizedHttpClient = table_instance._requester\n        self._identifier = table_instance._identifier\n        self._operation = operation\n    def get_component_name(self):\n        return Components.DATA_STORE\n    def get_status(self, job_id: Union[str, int]) -> ICatalystBulkJob:\n        validator.is_non_empty_string_or_number(job_id, 'job_id', CatalystDatastoreError)\n        resp = self._requester.request(",
        "detail": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "BulkRead",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkRead(BulkJob):\n    def __init__(self, table_instance):\n        super().__init__(table_instance, 'read')\n    def create_job(\n        self,\n        query: ICatalystBulkReadQuery = None,\n        callback: ICatalystBulkCallback = None\n    ) -> ICatalystBulkJob:\n        resp = self._requester.request(\n            method=RequestMethod.POST,",
        "detail": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "BulkWrite",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkWrite(BulkJob):\n    def __init__(self, table_instance):\n        super().__init__(table_instance, 'write')\n    def create_job(\n        self,\n        file_details: Union[CatalystBucketObject, str],\n        options: ICatalystBulkWriteInput = None,\n        callback: ICatalystBulkCallback = None\n    ) -> ICatalystBulkJob:\n        if options:",
        "detail": ".build.functions.exams.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "Table",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "peekOfCode": "class Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)\n    def get_component_name(self):\n        return Components.DATA_STORE",
        "detail": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "ICatalystRowInput",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "peekOfCode": "ICatalystRowInput = TypedDict('ICatalystRowInput', {'ROWID': str})\nBulkOperation = Literal['read', 'write']\nclass Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)",
        "detail": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "BulkOperation",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "peekOfCode": "BulkOperation = Literal['read', 'write']\nclass Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)\n    def get_component_name(self):",
        "detail": ".build.functions.exams.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "ICatalystFolderDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class ICatalystFolderDetails(ICatalystFolder):\n    created_time: Optional[str]\n    created_by: Optional[ICatalystSysUser]\n    project_details: Optional[ICatalystProject]\nclass ICatalystFileDetails(ICatalystFile, ICatalystGResponse):\n    pass\nclass Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester",
        "detail": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "ICatalystFileDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class ICatalystFileDetails(ICatalystFile, ICatalystGResponse):\n    pass\nclass Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester\n        self._folder_details = folder_details\n        self._id = folder_details.get('id')\n    def __repr__(self) -> str:\n        return str(self._folder_details)",
        "detail": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "Folder",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester\n        self._folder_details = folder_details\n        self._id = folder_details.get('id')\n    def __repr__(self) -> str:\n        return str(self._folder_details)\n    def get_component_name(self):\n        return Components.FILE_STORE",
        "detail": ".build.functions.exams.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "Cron",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._cron",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._cron",
        "peekOfCode": "class Cron:\n    def __init__(self, job_scheduling_instance) -> None:\n        self._requester: AuthorizedHttpClient = job_scheduling_instance._requester\n    def get_component_name(self):\n        return Components.JOB_SCHEDULING\n    def get_all(self) -> List[ICatalystCronDetails]:\n        \"\"\"\n        Get a list of all static crons\n        Returns:\n            List[ICatalystCronDetails]: List of static cron details",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._cron",
        "documentation": {}
    },
    {
        "label": "CatalystJobSchedulingError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._exception",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._exception",
        "peekOfCode": "class CatalystJobSchedulingError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._exception",
        "documentation": {}
    },
    {
        "label": "Job",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._job",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._job",
        "peekOfCode": "class Job:\n    def __init__(self, job_scheduling_instance):\n        self._requester: AuthorizedHttpClient = job_scheduling_instance._requester\n    def get_job(self, job_id: str) -> ICatalystJobDetails:\n        \"\"\"\n        Get a job's details\n        Args:\n            job_id: Id of the job to be fetched\n        Returns:\n            ICatalystJobDetails: Details of job fetched with the job_id",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._job",
        "documentation": {}
    },
    {
        "label": "CapacityAttribute",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CapacityAttribute(Enum):\n    MEMORY = \"memory\"\n    NUMBER = \"number\"\nclass CronExecutionType(Enum):\n    PRE_DEFINED = \"pre-defined\"\n    DYNAMIC = \"dynamic\"\nclass CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "CronExecutionType",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CronExecutionType(Enum):\n    PRE_DEFINED = \"pre-defined\"\n    DYNAMIC = \"dynamic\"\nclass CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"\n    CRON_EXPRESSION = \"CronExpression\"\nclass TargetType(Enum):\n    FUNCTION = \"Function\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "CronType",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"\n    CRON_EXPRESSION = \"CronExpression\"\nclass TargetType(Enum):\n    FUNCTION = \"Function\"\n    CIRCUIT = \"Circuit\"\n    APPSAIL = \"AppSail\"\n    WEBHOOK = \"Webhook\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TargetType",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class TargetType(Enum):\n    FUNCTION = \"Function\"\n    CIRCUIT = \"Circuit\"\n    APPSAIL = \"AppSail\"\n    WEBHOOK = \"Webhook\"\nclass JobStatus(Enum):\n    SUBMITTED = \"Submitted\"\n    PENDING = \"Pending\"\n    RUNNING = \"Running\"\n    SUCCESSFUL = \"Successful\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "JobStatus",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class JobStatus(Enum):\n    SUBMITTED = \"Submitted\"\n    PENDING = \"Pending\"\n    RUNNING = \"Running\"\n    SUCCESSFUL = \"Successful\"\n    FAILURE = \"Failure\"\nclass RepetitionType(Enum):\n    EVERY = \"every\"\n    DAILY = \"daily\"\n    MONTHLY = \"monthly\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "RepetitionType",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class RepetitionType(Enum):\n    EVERY = \"every\"\n    DAILY = \"daily\"\n    MONTHLY = \"monthly\"\n    YEARLY = \"yearly\"\nclass ICatalystCapacityAttributes(TypedDict):\n    memory: int\n    number: int\nclass ICatalystJobTargetDetails(TypedDict):\n    id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCapacityAttributes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCapacityAttributes(TypedDict):\n    memory: int\n    number: int\nclass ICatalystJobTargetDetails(TypedDict):\n    id: str\n    target_name: str\n    details: Dict[str, Any]\nclass ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobTargetDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobTargetDetails(TypedDict):\n    id: str\n    target_name: str\n    details: Dict[str, Any]\nclass ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType\n    name: str\n    capacity: ICatalystCapacityAttributes\nclass ICatalystJobMetaConfig(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobpoolDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType\n    name: str\n    capacity: ICatalystCapacityAttributes\nclass ICatalystJobMetaConfig(TypedDict):\n    number_of_retires: int\n    retry_interval: int\nclass ICatalystJobBasic(TypedDict):\n    job_name: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobMetaConfig",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobMetaConfig(TypedDict):\n    number_of_retires: int\n    retry_interval: int\nclass ICatalystJobBasic(TypedDict):\n    job_name: str\n    job_config: Optional[ICatalystJobMetaConfig]\n    jobpool_id: str\n    jobpool_name: str\nclass ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobBasic",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobBasic(TypedDict):\n    job_name: str\n    job_config: Optional[ICatalystJobMetaConfig]\n    jobpool_id: str\n    jobpool_name: str\nclass ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]\n    target_id: str\n    params: Dict[str, str]\nclass ICatalystWebhookJob(ICatalystJobBasic):",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystFunctionJob",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]\n    target_id: str\n    params: Dict[str, str]\nclass ICatalystWebhookJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.WEBHOOK]\n    target_id: str\n    url: str\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystWebhookJob",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystWebhookJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.WEBHOOK]\n    target_id: str\n    url: str\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]\n    request_method: str\n    request_body: Optional[str]\nclass ICatalystAppSailJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.APPSAIL]",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystAppSailJob",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystAppSailJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.APPSAIL]\n    target_id: str\n    url: Optional[str]\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]\n    request_method: str\n    request_body: Optional[str]\nclass ICatalystCircuitJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.CIRCUIT]",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCircuitJob",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCircuitJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.CIRCUIT]\n    target_id: str\n    test_cases: Dict[str, Any]\n# pylint: disable=invalid-name\nTCatalystJobs = Union[\n    ICatalystFunctionJob, ICatalystWebhookJob, ICatalystAppSailJob, ICatalystCircuitJob\n]\nclass ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobMetaDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str\n    target_details: ICatalystJobTargetDetails\n    source_type: str\n    source_id: str\n    source_details: str\n    jobpool_details: ICatalystJobpoolDetails\n    target_type: TargetType\n    target_id: str\n    url: Optional[str]",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobDetails(ICatalystGResponse):\n    job_id: str\n    status: bool\n    job_status: JobStatus\n    capacity: ICatalystCapacityAttributes\n    job_meta_details: ICatalystJobMetaDetails\n    response_code: Optional[str]\n    start_time: str\n    end_time: str\n    execution_time: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronBasic",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronBasic(TypedDict):\n    cron_execution_type: CronExecutionType\n    cron_name: str\n    cron_status: bool\n    job_meta: TCatalystJobs\none_time_cron_detail = TypedDict(\n    \"one_time_cron_detail\", {\"time_of_execution\": str, \"timezone\": Optional[str]}\n)\nclass ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystOneTimeCron",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]\n    cron_detail: one_time_cron_detail\nevery_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystEveryCron",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystEveryCron(ICatalystCronBasic):\n    cron_type: Literal[\"Periodic\"]\n    cron_detail: every_cron_detail\n    end_time: Optional[str]\ndaily_cron_detail = TypedDict(\n    \"daily_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystDailyCron",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystDailyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: daily_cron_detail\n    end_time: Optional[str]\nmonthly_cron_detail = TypedDict(\n    \"monthly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"monthly\"],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystMonthlyCron",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystMonthlyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: monthly_cron_detail\n    end_time: Optional[str]\nyearly_cron_detail = TypedDict(\n    \"yearly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"yearly\"],\n        \"months\": List[int],\n        \"days\": Optional[List[int]],",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystYearlyCron",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystYearlyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: yearly_cron_detail\n    end_time: Optional[str]\nexpression_cron_detail = TypedDict(\n    \"expression_cron_detail\", {\"timezone\": Optional[str]}\n)\nclass ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronExpression",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str\n    cron_detail: expression_cron_detail\n    end_time: Optional[str]\n# pylint: disable=invalid-name\nTCatalystCron = Union[\n    ICatalystOneTimeCron,\n    ICatalystEveryCron,\n    ICatalystDailyCron,",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronDetails(ICatalystGResponse):\n    id: str\n    cron_name: str\n    description: Optional[str]\n    cron_type: CronType\n    cron_function_id: Optional[str]\n    cron_execution_type: CronExecutionType\n    cron_status: bool\n    start_time: str\n    end_time: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TCatalystJobs",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "TCatalystJobs = Union[\n    ICatalystFunctionJob, ICatalystWebhookJob, ICatalystAppSailJob, ICatalystCircuitJob\n]\nclass ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str\n    target_details: ICatalystJobTargetDetails\n    source_type: str\n    source_id: str\n    source_details: str\n    jobpool_details: ICatalystJobpoolDetails",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "one_time_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "one_time_cron_detail = TypedDict(\n    \"one_time_cron_detail\", {\"time_of_execution\": str, \"timezone\": Optional[str]}\n)\nclass ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]\n    cron_detail: one_time_cron_detail\nevery_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "every_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "every_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],\n        \"repetition_type\": Literal[\"every\"],\n    },\n)",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "daily_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "daily_cron_detail = TypedDict(\n    \"daily_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],\n        \"repetition_type\": Literal[\"daily\"],\n    },\n)",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "monthly_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "monthly_cron_detail = TypedDict(\n    \"monthly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"monthly\"],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],\n        \"week_day\": Optional[List[int]],\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "yearly_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "yearly_cron_detail = TypedDict(\n    \"yearly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"yearly\"],\n        \"months\": List[int],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],\n        \"week_day\": Optional[List[int]],\n        \"hour\": int,\n        \"minute\": int,",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "expression_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "expression_cron_detail = TypedDict(\n    \"expression_cron_detail\", {\"timezone\": Optional[str]}\n)\nclass ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str\n    cron_detail: expression_cron_detail\n    end_time: Optional[str]\n# pylint: disable=invalid-name\nTCatalystCron = Union[",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TCatalystCron",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "TCatalystCron = Union[\n    ICatalystOneTimeCron,\n    ICatalystEveryCron,\n    ICatalystDailyCron,\n    ICatalystMonthlyCron,\n    ICatalystYearlyCron,\n    ICatalystCronExpression,\n]\nclass ICatalystCronDetails(ICatalystGResponse):\n    id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TableItem",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql._table_items",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql._table_items",
        "peekOfCode": "class TableItem(Component):\n    \"\"\"This class used to perform NoSQL table operations.\n    Args:\n        Component (ABC): Class used to retrieve the component's name.\n    \"\"\"\n    def __init__(self, nosql_instance, table) -> None:\n        self._requester: AuthorizedHttpClient = nosql_instance._requester\n        if not is_non_empty_string_or_number(table, 'table_identifier'):\n            table = table['id']\n        self.base_path = f'/nosqltable/{table}'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql._table_items",
        "documentation": {}
    },
    {
        "label": "AttrBase",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttrBase:\n    \"\"\"This class used to construct the attribute condition dict.\"\"\"\n    operator = ''\n    def __init__(self, name, values):\n        self.name = name\n        self.value = values\n    def get_condition(self):\n        return {\n            'attribute': self.name,\n            'operator': self.operator,",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "FuncBase",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class FuncBase:\n    \"\"\"This class used to construct the function condition dict.\"\"\"\n    operator = ''\n    def __init__(self, name, value = None):\n        self.args = []\n        self.args.append({\n            'attribute_path': name\n        })\n        self.values = value\n    def get_condition(self):",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GroupBase",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GroupBase:\n    \"\"\"This class used to construct the group condition dict.\"\"\"\n    operator = ''\n    group= []\n    def __init__(self, value):\n        self.value = value\n    def get_grouped_values(self):\n        self.group.extend(self.value)\n    def get_condition(self):\n        self.get_grouped_values()",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Attr",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Attr:\n    \"\"\"Represents an NoSql attribute condition.\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def __and__(self, value):\n        raise CatalystNoSqlError('AND', self)\n    def __or__(self, value):\n        raise CatalystNoSqlError('OR', self)\n    def __invert__(self):\n        raise CatalystNoSqlError('NOT', self)",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Func",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Func:\n    \"\"\"Represents an NoSql function condition.\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def exists(self):\n        \"\"\"Creates a condition where the attribute exists.\"\"\"\n        return AttributeExists(self.name).get_condition()\n    def not_exists(self):\n        \"\"\"Creates a condition where the attribute does not exist.\"\"\"\n        return AttributeNotExists(self.name).get_condition()",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Group",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Group:\n    \"\"\"Represents an NoSql Group condition.\"\"\"\n    def __init__(self, value):\n        self.value = value\n    def with_and(self):\n        \"\"\"Creates a group condition where the condition and to the other condition\n        :param value: The condition that the other condition is group with AND operator.\n        \"\"\"\n        return And(self.value).get_condition()\n    def with_or(self):",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Key",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Key(Attr):\n    pass\nclass Equals(AttrBase):\n    operator = 'equals'\nclass NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Equals",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Equals(AttrBase):\n    operator = 'equals'\nclass NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "NotEquals",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "LessThan",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "LessThanEquals",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GreaterThan",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GreaterThanEquals",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Between",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "BeginsWith",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Contains",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "In",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeExists",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeNotExists",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeType",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "And",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Or",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class Item:\n    \"\"\"This class used to perform coversion between NoSQL and Python types.\n    Returns:\n        Item: Instance of the class.\n    \"\"\"\n    @staticmethod\n    def to_nosql(items):\n        \"\"\"Convert the given type to NoSQl typs.\n        Args:\n            items (dict): Items to converted in to NoSQL type.",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "NoSqlItemResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class NoSqlItemResponse():\n    \"\"\" NoSQL Table Response.\"\"\"\n    def __init__(self, res_data: NoSqlItem):\n        self.status = res_data.get('status')\n        self.item = res_data.get('item') and Item.to_python({ 'M': res_data.get('item')})\n        self.old_item = res_data.get('old_item') and \\\n            Item.to_python({ 'M' :res_data.get('old_item')})\n    def to_dict(self):\n        return {k: v for k, v in self.__dict__.items() if v is not None and v != self.status}\n    def __repr__(self):",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "NoSqlResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class NoSqlResponse():\n    \"\"\"NoSQL response for all operations performed in the NoSQL table.\"\"\"\n    def __init__(self, res_data: NoSqlItemRes) -> None:\n        self._res_data = res_data\n        self.size = res_data.get('size')\n        self.operation = res_data.get('operation')\n        self.start_key = res_data.get('start_key')\n        self.get = res_data.get('get') and \\\n            [NoSqlItemResponse(i).to_dict() for i in res_data.get('get')]\n        self.update = res_data.get('update') and \\",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "Binary",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify\n    binary data for item in NoSQL. It is essentially a wrapper around\n    binary. Unicode and Python 3 string types are not allowed.\n    \"\"\"\n    def __init__(self, value):\n        if not isinstance(value, BINARY_TYPES):\n            types = ', '.join([str(t) for t in BINARY_TYPES])\n            raise TypeError(f'Value must be of the following types: {types}')",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "TypeSerializer",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class TypeSerializer:\n    \"\"\"This class serializes Python data types to NoSQL types.\"\"\"\n    def serialize(self, value):\n        \"\"\"The method to serialize the Python data types.\n        :param value: A python value to be serialized to NoSQL. Here are\n            the various conversions:\n            Python                                  NoSQL\n            ------                                  --------\n            None                                    {'NULL': True}\n            True/False                              {'BOOL': True/False}",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "TypeDeserializer",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class TypeDeserializer:\n    \"\"\"This class deserializes NoSQL types to Python types.\"\"\"\n    def deserialize(self, value):\n        \"\"\"The method to deserialize the NoSQL data types.\n        :param value: A NoSQL value to be deserialized to a pythonic value.\n            Here are the various conversions:\n            NoSQL                                Python\n            --------                                ------\n            {'NULL': True}                          None\n            {'BOOL': True/False}                    True/False",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "STRING",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "STRING = 'S'\nNUMBER = 'N'\nBINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NUMBER",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NUMBER = 'N'\nBINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "STRING_SET",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "STRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NUMBER_SET",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY_SET",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NULL",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BOOLEAN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "MAP",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "MAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "LIST",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "LIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NOSQL_CONTEXT",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY_TYPES",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify\n    binary data for item in NoSQL. It is essentially a wrapper around\n    binary. Unicode and Python 3 string types are not allowed.\n    \"\"\"\n    def __init__(self, value):\n        if not isinstance(value, BINARY_TYPES):\n            types = ', '.join([str(t) for t in BINARY_TYPES])",
        "detail": ".build.functions.exams.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "MobilePlatform",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.push_notification._mobile_notification",
        "description": ".build.functions.exams.zcatalyst_sdk.push_notification._mobile_notification",
        "peekOfCode": "class MobilePlatform(Enum):\n    IOS = \"ios\"\n    ANDROID = \"android\"\nclass MobileNotification:\n    \"\"\"\n    Class that contains the APIs for mobile push notification\n    \"\"\"\n    def __init__(self, requester: AuthorizedHttpClient, app_id):\n        self._app_id = app_id\n        self._requester = requester",
        "detail": ".build.functions.exams.zcatalyst_sdk.push_notification._mobile_notification",
        "documentation": {}
    },
    {
        "label": "MobileNotification",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.push_notification._mobile_notification",
        "description": ".build.functions.exams.zcatalyst_sdk.push_notification._mobile_notification",
        "peekOfCode": "class MobileNotification:\n    \"\"\"\n    Class that contains the APIs for mobile push notification\n    \"\"\"\n    def __init__(self, requester: AuthorizedHttpClient, app_id):\n        self._app_id = app_id\n        self._requester = requester\n    def send_ios_notification(\n        self, notify_obj: ICatalystPushDetails, recipient: str\n    ) -> ICatalystMobileNotification:",
        "detail": ".build.functions.exams.zcatalyst_sdk.push_notification._mobile_notification",
        "documentation": {}
    },
    {
        "label": "WebNotification",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.push_notification._web_notificaton",
        "description": ".build.functions.exams.zcatalyst_sdk.push_notification._web_notificaton",
        "peekOfCode": "class WebNotification:\n    def __init__(self, notification_instance):\n        self._app = notification_instance._app\n        self._requester: AuthorizedHttpClient = notification_instance._requester\n    def send_notification(\n        self,\n        message: str,\n        recipients: List[str]\n    ) -> bool:\n        validator.is_non_empty_string(message, 'message', CatalystPushNotificationError)",
        "detail": ".build.functions.exams.zcatalyst_sdk.push_notification._web_notificaton",
        "documentation": {}
    },
    {
        "label": "SignatureCache",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.stratus._auth_util",
        "description": ".build.functions.exams.zcatalyst_sdk.stratus._auth_util",
        "peekOfCode": "class SignatureCache:\n    \"\"\"\n    Handles signature caching and retrieval for bucket authentication.\n    \"\"\"\n    bucket_signatures: Dict[str, Dict] = {}\n    @classmethod\n    def get_signature(cls, bucket_name: str) -> Optional[Dict]:\n        \"\"\"\n        Retrieve the cached signature for the specified bucket if valid.\n        \"\"\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.stratus._auth_util",
        "documentation": {}
    },
    {
        "label": "AuthUtil",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.stratus._auth_util",
        "description": ".build.functions.exams.zcatalyst_sdk.stratus._auth_util",
        "peekOfCode": "class AuthUtil:\n    \"\"\"\n    Handles user authentication and signature retrieval for buckets.\n    \"\"\"\n    def __init__(self, bucket_name: str, requester: AuthorizedHttpClient) -> None:\n        self.bucket_name = bucket_name\n        self._requester = requester\n        self.user_type = requester._app.credential.current_user_type()\n        self.user_scope = requester._app.credential.current_user()\n    def get_user_type(self) -> str:",
        "detail": ".build.functions.exams.zcatalyst_sdk.stratus._auth_util",
        "documentation": {}
    },
    {
        "label": "Bucket",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.stratus.bucket",
        "description": ".build.functions.exams.zcatalyst_sdk.stratus.bucket",
        "peekOfCode": "class Bucket(ParsableComponent):\n    def __init__(self, stratus_instance, bucket_details: Dict):\n        validator.is_non_empty_dict(bucket_details, 'bucket_details', CatalystStratusError)\n        self._requester: AuthorizedHttpClient = stratus_instance._requester\n        self._bucket_name = bucket_details.get('bucket_name')\n        self.bucket_details = bucket_details\n        self._auth_util = AuthUtil(self._bucket_name, self._requester)\n        if self._requester._app.config.get(ENVIRONMENT) == 'Development':\n            self.bucket_domain = f'https://{self._bucket_name}-development{STRATUS_SUFFIX}'\n        else:",
        "detail": ".build.functions.exams.zcatalyst_sdk.stratus.bucket",
        "documentation": {}
    },
    {
        "label": "StratusObject",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.stratus.object",
        "description": ".build.functions.exams.zcatalyst_sdk.stratus.object",
        "peekOfCode": "class StratusObject(ParsableComponent):\n    def __init__(self, bucket_instance, object_details: Dict):\n        validator.is_non_empty_dict(object_details, 'object_details', CatalystStratusError)\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self._key = object_details.get('key')\n        self.object_details = object_details\n        self.req_params = {\n            'bucket_name': bucket_instance.get_name(),\n            'object_key': self._key\n        }",
        "detail": ".build.functions.exams.zcatalyst_sdk.stratus.object",
        "documentation": {}
    },
    {
        "label": "MultipartUpload",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "class MultipartUpload():\n    def __init__(self, bucket_instance, key, upload_id):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.key = key\n        self.upload_id = upload_id\n    def upload_part(self,\n            body: Union[BufferedReader, bytes],\n            part_number: Union[str, int],\n            overwrite: Union[str, bool] = False",
        "detail": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "TransferManager",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "class TransferManager(Component):\n    def __init__(self, bucket_instance):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.bucket_domain = bucket_instance.bucket_domain\n    def get_component_name(self):\n        return Components.STRATUS\n    def create_multipart_instance(self,\n        key: str,\n        upload_id: str = None,",
        "detail": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "logger = get_logger()\nclass MultipartUpload():\n    def __init__(self, bucket_instance, key, upload_id):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.key = key\n        self.upload_id = upload_id\n    def upload_part(self,\n            body: Union[BufferedReader, bytes],\n            part_number: Union[str, int],",
        "detail": ".build.functions.exams.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "NoSqlCrudOperation",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\nclass CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str\n    first_name: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystSysUser",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str\n    first_name: str\n    last_name: str\n    zuid: Optional[str]\n    is_confirmed: Optional[bool]\nclass CatalystProjectInfo(TypedDict):\n    id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystProjectInfo",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystProjectInfo(TypedDict):\n    id: str\n    project_name: str\n    project_type: str\nclass CatalystNoSqlKeyInfo(TypedDict):\n    column_name: str\n    data_type: str\nclass NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystNoSqlKeyInfo",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystNoSqlKeyInfo(TypedDict):\n    column_name: str\n    data_type: str\nclass NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    modified_by: CatalystSysUser\n    modified_time: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlTableResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str\n    partition_key: CatalystNoSqlKeyInfo\n    project_id: CatalystProjectInfo",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlIndexRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlIndexRes(TypedDict):\n    created_by: CatalystSysUser\n    created_time: str\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str\n    partition_key:CatalystNoSqlKeyInfo\n    project_id: CatalystProjectInfo\n    projected_attributes: ProjectedAttribute",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlTableResourceRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlTableResourceRes(TypedDict):\n    additional_sort_keys: List[NoSqlIndexRes]\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    global_index: List[NoSqlIndexRes]\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "UpdateCondion",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class UpdateCondion(TypedDict):\n    function_name: Literal['if_not_exists', 'add', 'subtract', 'append_list']\n    args: AttributePath\nclass NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion\n    attribute_path: List[str]\nclass NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItemUpdateAttributeOperation",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion\n    attribute_path: List[str]\nclass NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']\n    args: AttributePath\nclass NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlFunctionCondition",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']\n    args: AttributePath\nclass NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]\nclass NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlConditionFuncOperation",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]\nclass NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlAttributeCondition",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool\nNoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlGroupCondition",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool\nNoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItem",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]\n    create: List[NoSqlItem]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItemRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]\n    create: List[NoSqlItem]\n    delete: List[NoSqlItem]\n    get: List[NoSqlItem]\nNoSqlInsertItemReq = TypedDict('NoSqlInsertItemReq', {\n    'item': Dict[str, str],",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlFetchItemReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlFetchItemReq(TypedDict):\n    keys: List[Dict[str, str]]\n    required_attributes: List[str]\nclass NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\nclass NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlDeleteItemReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\nclass NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]\nclass NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlUpdateItemReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]\nclass NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition\n    other_condition: Optional[NoSqlCondition]\n    limit: int\n    forward_scan: bool",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlQueryItemReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition\n    other_condition: Optional[NoSqlCondition]\n    limit: int\n    forward_scan: bool\n    start_key: Dict[str, str]\n    additional_sort_keys: str\n    required_attributes: List[str]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlAttributeType",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlAttributeType = Literal['keys_only', 'all', 'include']\nNoSqlGroupOperator = Literal['AND', 'OR']\nNoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlGroupOperator",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlGroupOperator = Literal['AND', 'OR']\nNoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlUpdateOperation",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlOperator",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ItemType",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlSecondaryKeyCondition",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ReturnType",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\nclass CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ProjectedAttribute",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ProjectedAttribute = TypedDict('ProjectedAttribute', {\n    'type': str,\n})\nclass NoSqlIndexRes(TypedDict):\n    created_by: CatalystSysUser\n    created_time: str\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "AttributePath",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "AttributePath = TypedDict('AttributePath', {\n        'attribute_path': List[str]\n})\nclass UpdateCondion(TypedDict):\n    function_name: Literal['if_not_exists', 'add', 'subtract', 'append_list']\n    args: AttributePath\nclass NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlCondition",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlInsertItemReq",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlInsertItemReq = TypedDict('NoSqlInsertItemReq', {\n    'item': Dict[str, str],\n    'condition': Optional[NoSqlCondition],\n    'return': ReturnType\n}, total = False)\nclass NoSqlFetchItemReq(TypedDict):\n    keys: List[Dict[str, str]]\n    required_attributes: List[str]\nclass NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "PipelineDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.pipeline",
        "description": ".build.functions.exams.zcatalyst_sdk.types.pipeline",
        "peekOfCode": "class PipelineDetails(TypedDict):\n    pipeline_id: str\n    name: str\n    description: str\n    project_details: ICatalystProject\n    created_time: str\n    created_by: ICatalystSysUser\n    modified_time: str\n    modified_by: ICatalystSysUser\n    git_account_id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.pipeline",
        "documentation": {}
    },
    {
        "label": "PipelineRun",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.pipeline",
        "description": ".build.functions.exams.zcatalyst_sdk.types.pipeline",
        "peekOfCode": "class PipelineRun(TypedDict):\n    history_id: str\n    pipeline_id: str\n    event_time: str\n    event_details: Dict[str, str]\n    history_status: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.pipeline",
        "documentation": {}
    },
    {
        "label": "PdfOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class PdfOptions(TypedDict, total=False):\n    scale: Union[int,str]\n    display_header_footer: bool\n    header_template: str\n    password: str\n    footer_template: str\n    print_background: bool\n    landscape: bool\n    page_ranges: Union[int,str]\n    format: PdfFormats",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfPageOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name\n    viewport: PdfViewPort\n    javascript_enabled: bool\nclass ScreenShotOptions(TypedDict, total=False):\n    type: Literal['jpeg', 'png']\n    quality: Union[int, str]\n    full_page: bool\n    omit_background: bool",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "ScreenShotOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class ScreenShotOptions(TypedDict, total=False):\n    type: Literal['jpeg', 'png']\n    quality: Union[int, str]\n    full_page: bool\n    omit_background: bool\n    capture_beyond_viewport: bool\nclass ScreenShotPageOptions(TypedDict):\n    device: str\nclass NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "ScreenShotPageOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class ScreenShotPageOptions(TypedDict):\n    device: str\nclass NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]\n    wait_until: Literal['load', 'domcontentloaded', 'networkidle0', 'networkidle2']\nclass OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "NavigationOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]\n    wait_until: Literal['load', 'domcontentloaded', 'networkidle0', 'networkidle2']\nclass OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "OutputOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseSimilarCompanyReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseEnrichLeadReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,\n    'street':str,\n    'pincode':str\n}, total=False)",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseLead",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseLead(TypedDict, total = False):\n    organization_name: str\n    description: str\n    employee_count: str\n    revenue: str\n    organization_type: str\n    organization_status: str\n    email: List[str]\n    address: List[str]\n    contact: List[str]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseTechStack",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseTechStack(TypedDict, total = False):\n    organization_name: str\n    website: str\n    website_status: str\n    technographic_data: Dict[str, None]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfFormats",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfFormats = Literal[\n    'Letter', 'Legal', 'Tabloid', 'Ledger',\n    'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6'\n]\nPdfMargin = TypedDict('PdfMargin', {\n    'top': str,\n    'bottom': str,\n    'left': str,\n    'right': str\n}, total=False)",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfMargin",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfMargin = TypedDict('PdfMargin', {\n    'top': str,\n    'bottom': str,\n    'left': str,\n    'right': str\n}, total=False)\nclass PdfOptions(TypedDict, total=False):\n    scale: Union[int,str]\n    display_header_footer: bool\n    header_template: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "CssContent",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "CssContent = TypedDict('CssContent', {\n    'content': str\n})\nCssUrl = TypedDict('CssUrl', {\n    'url': str\n})\nJsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "CssUrl",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "CssUrl = TypedDict('CssUrl', {\n    'url': str\n})\nJsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "JsContent",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "JsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "JsUrl",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "JsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})\nclass PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfViewPort",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})\nclass PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name\n    viewport: PdfViewPort\n    javascript_enabled: bool\nclass ScreenShotOptions(TypedDict, total=False):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "OrgHeadquarters",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "OrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,\n    'street':str,\n    'pincode':str\n}, total=False)\nclass DataverseLead(TypedDict, total = False):\n    organization_name: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "BucketMeta",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class BucketMeta(TypedDict):\n    versioning: bool\n    caching: Cache\n    encryption: bool\n    audit_consent: bool\nclass StratusObjectDetails(TypedDict):\n    key_type: str\n    key: str\n    size: int\n    version_id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectDetails",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectDetails(TypedDict):\n    key_type: str\n    key: str\n    size: int\n    version_id: str\n    etag: str\n    content_type: str\n    last_modified: str\n    object_url: Optional[str]\nclass StratusObjectsRes(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectsRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectsRes(TypedDict):\n    key_count: int\n    max_keys: Optional[int]\n    truncated: str\n    next_continuation_token: Optional[str]\n    contents: List[StratusObjectDetails]\nclass DeleteObjectOptions(TypedDict):\n    key: str\n    version_id: str\nclass StratusBucket(ICatalystGResponse):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "DeleteObjectOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class DeleteObjectOptions(TypedDict):\n    key: str\n    version_id: str\nclass StratusBucket(ICatalystGResponse):\n    bucket_name: str\n    bucket_url: str\n    objects_count: str\n    size_in_bytes: str\n    bucket_meta: BucketMeta\nclass StratusObjectVersion(TypedDict, total = False):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusBucket",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusBucket(ICatalystGResponse):\n    bucket_name: str\n    bucket_url: str\n    objects_count: str\n    size_in_bytes: str\n    bucket_meta: BucketMeta\nclass StratusObjectVersion(TypedDict, total = False):\n    version_id: str\n    is_latest: Optional[bool]\n    last_modified: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectVersion",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectVersion(TypedDict, total = False):\n    version_id: str\n    is_latest: Optional[bool]\n    last_modified: str\n    size: str\n    etag: str\nclass ObjectVersionsRes(TypedDict):\n    key: str\n    versions_count: str\n    next_continuation_token: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "ObjectVersionsRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class ObjectVersionsRes(TypedDict):\n    key: str\n    versions_count: str\n    next_continuation_token: str\n    max_versions: str\n    is_truncated: Optional[bool]\n    version: List[StratusObjectVersion]\nclass BucketCorsResponse(TypedDict):\n    domain: str\n    allowed_methods: List[str]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "BucketCorsResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class BucketCorsResponse(TypedDict):\n    domain: str\n    allowed_methods: List[str]\nclass CopyObjectResponse(TypedDict):\n    key: str\n    copy_to: str\n    message: str\nclass RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "CopyObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class CopyObjectResponse(TypedDict):\n    key: str\n    copy_to: str\n    message: str\nclass RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str\n    message: str\nclass UnzipObjectResponse(TypedDict):\n    key: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "RenameObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str\n    message: str\nclass UnzipObjectResponse(TypedDict):\n    key: str\n    destination: str\n    message: str\n    task_id: str\nclass DeleteObjectPathResponse(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "UnzipObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class UnzipObjectResponse(TypedDict):\n    key: str\n    destination: str\n    message: str\n    task_id: str\nclass DeleteObjectPathResponse(TypedDict):\n    prefix: str\n    message: str\nclass InitiateMultipartUploadResponse(TypedDict):\n    bucket: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "DeleteObjectPathResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class DeleteObjectPathResponse(TypedDict):\n    prefix: str\n    message: str\nclass InitiateMultipartUploadResponse(TypedDict):\n    bucket: str\n    key: str\n    upload_id: int\n    status: str\nclass UploadedObjectPartRes(TypedDict):\n    part_number: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "InitiateMultipartUploadResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class InitiateMultipartUploadResponse(TypedDict):\n    bucket: str\n    key: str\n    upload_id: int\n    status: str\nclass UploadedObjectPartRes(TypedDict):\n    part_number: str\n    size: str\n    upload_at: str\nclass MultipartUploadSummaryRes(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "UploadedObjectPartRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class UploadedObjectPartRes(TypedDict):\n    part_number: str\n    size: str\n    upload_at: str\nclass MultipartUploadSummaryRes(TypedDict):\n    bucket: str\n    key: str\n    upload_id: str\n    parts: List[UploadedObjectPartRes]\nclass StratusSignature(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "MultipartUploadSummaryRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class MultipartUploadSummaryRes(TypedDict):\n    bucket: str\n    key: str\n    upload_id: str\n    parts: List[UploadedObjectPartRes]\nclass StratusSignature(TypedDict):\n    stsPolicy: str\n    stsSignature: str\nclass StratusPutObjectRes(TypedDict):\n    task_id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusSignature",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusSignature(TypedDict):\n    stsPolicy: str\n    stsSignature: str\nclass StratusPutObjectRes(TypedDict):\n    task_id: str\nclass PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusPutObjectRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusPutObjectRes(TypedDict):\n    task_id: str\nclass PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "PutObjectAsPartsOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusInitiateUploadOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "Cache",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "Cache = TypedDict('caching', {\n    'status': Union[str, bool]\n})\nStratusUploadOptions = TypedDict('StratusUploadOptions', {\n    'overwrite': Union[str, bool],\n    'ttl': str,\n    'compress': str,\n    'meta_data': Dict[str, str],\n    'content_type': str,\n    'extract_upload': Literal['true', 'false']",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusUploadOptions",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "StratusUploadOptions = TypedDict('StratusUploadOptions', {\n    'overwrite': Union[str, bool],\n    'ttl': str,\n    'compress': str,\n    'meta_data': Dict[str, str],\n    'content_type': str,\n    'extract_upload': Literal['true', 'false']\n}, total= False)\nStratusDownloadOptions = TypedDict('StratusDownloadOptions', {\n    'version_id': str,",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusDownloadOptions",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "peekOfCode": "StratusDownloadOptions = TypedDict('StratusDownloadOptions', {\n    'version_id': str,\n    'range': str\n}, total= False)\nclass BucketMeta(TypedDict):\n    versioning: bool\n    caching: Cache\n    encryption: bool\n    audit_consent: bool\nclass StratusObjectDetails(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "ObjectParams",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ObjectParams(TypedDict):\n    co_ordinates: List[int]\n    object_type: str\n    confidence: str\nclass ICatalystZiaObject(TypedDict):\n    object: List[ObjectParams]\nclass ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaObject",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaObject(TypedDict):\n    object: List[ObjectParams]\nclass ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaOCR",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaBarcode",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaModeration",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):\n    confidence: int\n    id: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaCom",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):\n    confidence: int\n    id: str\n    co_ordinates: List[int]\n    emotion: ICatalystZiaCom\n    age: ICatalystZiaCom\n    gender: ICatalystZiaCom",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "FaceParams",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class FaceParams(TypedDict):\n    confidence: int\n    id: str\n    co_ordinates: List[int]\n    emotion: ICatalystZiaCom\n    age: ICatalystZiaCom\n    gender: ICatalystZiaCom\n    landmarks: Optional[Dict[str, List[int]]]\nclass ICatalystZiaFace(TypedDict):\n    faces: List[FaceParams]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaFace",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaFace(TypedDict):\n    faces: List[FaceParams]\nclass ICatalystZiaFaceComparison(TypedDict):\n    confidence: Optional[int]\n    matched: bool\nclass ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaFaceComparison",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaFaceComparison(TypedDict):\n    confidence: Optional[int]\n    matched: bool\nclass ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaAutoML",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int\n    positive: int\nclass ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ConfidenceScores",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int\n    positive: int\nclass ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]\n    confidence_scores: ConfidenceScores\nclass ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaAnalytics",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]\n    confidence_scores: ConfidenceScores\nclass ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentenceAnalytics",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaKeywordAnalytics",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentimentAnalysis",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentimentAnalysisResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]\nclass ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaExtractedKeywords",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]\nclass ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaKeywordExtractionResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str\n    token: str\nclass ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNer",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str\n    token: str\nclass ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]\nclass ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNerGeneralEntities",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]\nclass ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities\nclass ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNERPredictionResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities\nclass ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaTextAnalyticsResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.exams.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "AcceptHeader",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialUser",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    HEAD = \"HEAD\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "RequestMethod",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    HEAD = \"HEAD\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"\nclass Components:\n    CACHE = \"Cache\"\n    FILE_STORE = \"FileStore\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "Components",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class Components:\n    CACHE = \"Cache\"\n    FILE_STORE = \"FileStore\"\n    MAIL = \"Mail\"\n    SEARCH = \"Search\"\n    ZCQL = \"ZCQL\"\n    ZIA = \"Zia\"\n    CRON = \"Cron\"\n    DATA_STORE = \"DataStore\"\n    FUNCTION = \"Function\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialType",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialType:\n    token = 'token'\n    ticket = 'ticket'\nclass ProjectHeader:\n    project_id = 'X-ZC-ProjectId'\n    domain = 'X-ZC-Project-Domain'\n    key = 'X-ZC-Project-Key'\n    environment = 'X-ZC-Environment'\n    project_secret_key = 'X-ZC-PROJECT-SECRET-KEY'\nclass CredentialHeader:",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ProjectHeader",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class ProjectHeader:\n    project_id = 'X-ZC-ProjectId'\n    domain = 'X-ZC-Project-Domain'\n    key = 'X-ZC-Project-Key'\n    environment = 'X-ZC-Environment'\n    project_secret_key = 'X-ZC-PROJECT-SECRET-KEY'\nclass CredentialHeader:\n    admin_cred_type = 'X-ZC-Admin-Cred-Type'\n    user_cred_type = 'X-ZC-User-Cred-Type'\n    admin_token = 'X-ZC-Admin-Cred-Token'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialHeader",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialHeader:\n    admin_cred_type = 'X-ZC-Admin-Cred-Type'\n    user_cred_type = 'X-ZC-User-Cred-Type'\n    admin_token = 'X-ZC-Admin-Cred-Token'\n    user_token = 'X-ZC-User-Cred-Token'\n    cookie = 'x-zc-cookie'\n    zcsrf = 'X-ZCSRF-TOKEN'\n    user = 'X-ZC-User-Type'\n    signature = \"X-ZC-Stratus-Signature\"\nclass CatalystService:",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CatalystService",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "class CatalystService:\n    SERVERLESS = 'baas'\n    BROWSER360 = 'browser360'\n    QUICK_ML = 'quickml'\n    STRATUS = 'stratus'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "env_override",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "def env_override(env_name: str, default_value: str):\n    env_value = os.getenv(env_name)\n    if not env_value:\n        return default_value\n    return env_value\nmeta_file = path.join(path.dirname(path.abspath(__file__)), '__version__.py')\nmeta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "meta_file",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "meta_file = path.join(path.dirname(path.abspath(__file__)), '__version__.py')\nmeta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version\nSDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "meta",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "meta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version\nSDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "SDK_VERSION",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "SDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_KEY",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_STATUS",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_MESSAGE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_CODE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "SUCCESS_STATUS",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "SUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "FAILURE_STATUS",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "FAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_KEY",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_ID",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_DOMAIN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_SECRET_KEY",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_CRED",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_CRED",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE_CRED",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_ACCESS_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_COOKIE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_ID",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "EXPIRES_IN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "EXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_IN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_SECRET",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "AUTH_URL",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "AUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_URL",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REDIRECT_URL",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "REDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "GRANT_TYPE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "GRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CODE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "TICKET",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "TICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_CRED_TYPE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_CRED_TYPE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JWT_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "JWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_TYPE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "USER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CONNECTOR_NAME",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "USER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "X_CATALYST_ORG_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "X_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_URL",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "URL_SEPARATOR",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "URL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "IS_LOCAL",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "IS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_TOKEN_COOKIE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "APP_DOMAIN",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "APP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "APP_VERSION_V1",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "APP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ACCOUNTS_URL",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "STRATUS_SUFFIX",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "STRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_HEADER",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE_HEADER",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_HEADER",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_AGENT",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "USER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "AUTHORIZATION",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "AUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_SCOPE_HEADER",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "USER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_SCOPE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_SCOPE",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "USER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "OAUTH_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "OAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "TICKET_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "TICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_PARAM_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ZAID",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._constants",
        "description": ".build.functions.exams.zcatalyst_sdk._constants",
        "peekOfCode": "ZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"",
        "detail": ".build.functions.exams.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "DefaultHttpResponse",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._http_client",
        "description": ".build.functions.exams.zcatalyst_sdk._http_client",
        "peekOfCode": "class DefaultHttpResponse:\n    def __init__(self, resp: requests.Response):\n        self._response = resp\n        self._status_code = resp.status_code\n        self._headers = resp.headers\n        self.check_status()\n    @property\n    def response(self):\n        return self._response\n    @property",
        "detail": ".build.functions.exams.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "HttpClient",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._http_client",
        "description": ".build.functions.exams.zcatalyst_sdk._http_client",
        "peekOfCode": "class HttpClient:\n    def __init__(\n        self,\n        app=None,\n        base_url=None,\n        retries=DEFAULT_RETRY_CONFIG,\n        timeout=DEFAULT_TIMEOUT\n    ):\n        self._session = requests.session()\n        self._timeout = timeout",
        "detail": ".build.functions.exams.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "AuthorizedHttpClient",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._http_client",
        "description": ".build.functions.exams.zcatalyst_sdk._http_client",
        "peekOfCode": "class AuthorizedHttpClient(HttpClient):\n    temp_credential: JwtTokenCredential = None\n    def __init__(\n        self,\n        app\n    ):\n        super().__init__(app)\n    def request(\n        self,\n        method: str,",
        "detail": ".build.functions.exams.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "USERAGENT_HEADER",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._http_client",
        "description": ".build.functions.exams.zcatalyst_sdk._http_client",
        "peekOfCode": "USERAGENT_HEADER = {USER_AGENT: \"zc-python-sdk/\" + SDK_VERSION}\n# Default timeout for connect and read operation in seconds\nDEFAULT_TIMEOUT = (60, 30)\nDEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5",
        "detail": ".build.functions.exams.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._http_client",
        "description": ".build.functions.exams.zcatalyst_sdk._http_client",
        "peekOfCode": "DEFAULT_TIMEOUT = (60, 30)\nDEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5\n)\nclass DefaultHttpResponse:",
        "detail": ".build.functions.exams.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RETRY_CONFIG",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk._http_client",
        "description": ".build.functions.exams.zcatalyst_sdk._http_client",
        "peekOfCode": "DEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5\n)\nclass DefaultHttpResponse:\n    def __init__(self, resp: requests.Response):",
        "detail": ".build.functions.exams.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "ZCThreadUtil",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk._thread_util",
        "description": ".build.functions.exams.zcatalyst_sdk._thread_util",
        "peekOfCode": "class ZCThreadUtil:\n    def __init__(self) -> None:\n        try:\n            self.__zclocal = getattr(threading.current_thread(), '__zc_local')\n        except AttributeError:\n            setattr(threading.current_thread(), '__zc_local', {})\n            self.__zclocal = getattr(threading.current_thread(), '__zc_local')\n    def get_value(self, key: str):\n        return self.__zclocal.get(key)\n    def put_value(self, key: str, val: Any):",
        "detail": ".build.functions.exams.zcatalyst_sdk._thread_util",
        "documentation": {}
    },
    {
        "label": "get_attr",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk._thread_util",
        "description": ".build.functions.exams.zcatalyst_sdk._thread_util",
        "peekOfCode": "def get_attr(obj: dict, key: str):\n    if obj.get(key):\n        return obj.get(key)\n    fallback_obj = dict((k.lower(), v) for k, v in obj.items())\n    return fallback_obj.get(key.lower())",
        "detail": ".build.functions.exams.zcatalyst_sdk._thread_util",
        "documentation": {}
    },
    {
        "label": "parse_headers_from_request",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk._util",
        "description": ".build.functions.exams.zcatalyst_sdk._util",
        "peekOfCode": "def parse_headers_from_request(request):\n    try:\n        if hasattr(request, 'headers'):\n            thread_obj = ZCThreadUtil()\n            thread_obj.put_value(\"catalyst_headers\", dict(request.headers))\n    except Exception as err:\n        raise CatalystAppError(\n            \"Invalid req_obj\",\n            \"Kindly ensure whether the request object is valid\"\n        ) from err",
        "detail": ".build.functions.exams.zcatalyst_sdk._util",
        "documentation": {}
    },
    {
        "label": "ICatalystNewUser",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.authentication",
        "description": ".build.functions.exams.zcatalyst_sdk.authentication",
        "peekOfCode": "class ICatalystNewUser(ICatalystSignupConfig):\n    user_details: ICatalystUser\nclass Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:\n        resp = self._requester.request(",
        "detail": ".build.functions.exams.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "Authentication",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.authentication",
        "description": ".build.functions.exams.zcatalyst_sdk.authentication",
        "peekOfCode": "class Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:\n        resp = self._requester.request(\n            method=RequestMethod.GET,\n            path='/project-user/current',",
        "detail": ".build.functions.exams.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "UserStatus",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.authentication",
        "description": ".build.functions.exams.zcatalyst_sdk.authentication",
        "peekOfCode": "UserStatus = Literal['enable', 'disable']\nclass ICatalystNewUser(ICatalystSignupConfig):\n    user_details: ICatalystUser\nclass Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:",
        "detail": ".build.functions.exams.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "CatalystAppOptions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "class CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()\n        if not isinstance(options, dict):\n            raise CatalystAppError(\n                'INVALID_APP_OPTIONS',\n                f'Illegal app option type - {type(options)}. App options must be a instance of dict'\n            )\n        config = CatalystAppOptions.validate_options(options)",
        "detail": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CatalystApp",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "class CatalystApp:\n    def __init__(\n        self,\n        credential: Credential,\n        options: Dict,\n        name: str\n    ):\n        if not name or not isinstance(name, str):\n            raise CatalystAppError(\n                'INVALID_APP_NAME',",
        "detail": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CATALYST_OPTIONS_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "CATALYST_OPTIONS_ENV_KEY = 'CATALYST_OPTIONS'\nCONFIG_MANDATORIES = {\n    APIConstants.PROJECT_ID: (int, str),\n    APIConstants.PROJECT_KEY: (int, str),\n    APIConstants.PROJECT_DOMAIN: (str,)\n}\nDEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:",
        "detail": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CONFIG_MANDATORIES",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "CONFIG_MANDATORIES = {\n    APIConstants.PROJECT_ID: (int, str),\n    APIConstants.PROJECT_KEY: (int, str),\n    APIConstants.PROJECT_DOMAIN: (str,)\n}\nDEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()",
        "detail": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENVIRONMENT",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "DEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()\n        if not isinstance(options, dict):\n            raise CatalystAppError(\n                'INVALID_APP_OPTIONS',\n                f'Illegal app option type - {type(options)}. App options must be a instance of dict'\n            )",
        "detail": ".build.functions.exams.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "Circuit",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.circuit",
        "description": ".build.functions.exams.zcatalyst_sdk.circuit",
        "peekOfCode": "class Circuit(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CIRCUIT\n    def execute(\n        self,\n        circuit_id: Union[int, str],\n        name: str,",
        "detail": ".build.functions.exams.zcatalyst_sdk.circuit",
        "documentation": {}
    },
    {
        "label": "Credential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class Credential(ABC):\n    @abstractmethod\n    def token(self):\n        pass\n    def _switch_user(self, user=None):  # pylint: disable=unused-argument\n        return None\n    def current_user(self):\n        return CredentialUser.ADMIN\n    def current_user_type(self):\n        return CredentialUser.ADMIN",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "RefreshTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class RefreshTokenCredential(Credential):\n    def __init__(self, refresh_obj: ICatalystRefreshObj):\n        super().__init__()\n        RefreshTokenCredential._validate_refresh_obj(refresh_obj)\n        self._client_id = refresh_obj.get(APIConstants.CLIENT_ID)\n        self._client_secret = refresh_obj.get(APIConstants.CLIENT_SECRET)\n        self._refresh_token = refresh_obj.get(APIConstants.REFRESH_TOKEN)\n        self._cached_token: Dict[str, Union[str, int]] = None\n    def token(self) -> str:\n        if not self._cached_token or self._cached_token.get('expires_in') <= int(round(time())):",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "JwtTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class JwtTokenCredential:\n    def __init__(self, _app):\n        self.project_key = _app.config.get(PROJECT_KEY)\n        self.project_id = _app.config.get(PROJECT_ID)\n        self.project_domain = _app.config.get(PROJECT_DOMAIN)\n        self._cached_token = None\n    def generate_jwt_token(self, cookie: str, requester) -> ICatalystJwtObj:\n        resp = requester.request(\n                method=RequestMethod.GET,\n                url='https://' + self.project_domain +",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "AccessTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class AccessTokenCredential(Credential):\n    def __init__(self, token_obj: ICatalystTokenObj):\n        super().__init__()\n        self._token: str = _get_attr(token_obj, 'access_token')\n    def token(self):\n        return self._token\nclass TicketCredential(Credential):\n    def __init__(self, ticket_obj: ICatalystTicketObj):\n        super().__init__()\n        self._token: str = _get_attr(ticket_obj, 'ticket')",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "TicketCredential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class TicketCredential(Credential):\n    def __init__(self, ticket_obj: ICatalystTicketObj):\n        super().__init__()\n        self._token: str = _get_attr(ticket_obj, 'ticket')\n    def token(self):\n        return self._token\nclass CookieCredential(Credential):\n    def __init__(self, cookie_obj):\n        super().__init__()\n        cookie_str = _get_attr(cookie_obj, 'cookie')",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "CookieCredential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class CookieCredential(Credential):\n    def __init__(self, cookie_obj):\n        super().__init__()\n        cookie_str = _get_attr(cookie_obj, 'cookie')\n        csrf_token: str = ZCThreadUtil().get_value(APIConstants.CSRF_TOKEN_COOKIE)\n        if not csrf_token:\n            cookies_list: List = cookie_str.split(\"; \")\n            for cookie in cookies_list:\n                splitted_cookie: List = cookie.split(\"=\")\n                if splitted_cookie[0] == APIConstants.CSRF_TOKEN_COOKIE:",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "CatalystCredential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class CatalystCredential(Credential):\n    def __init__(self, user: str = None):\n        super().__init__()\n        thread_obj = ZCThreadUtil()\n        self._admin_cred: Union[AccessTokenCredential, TicketCredential] = None\n        self._user_cred: Union[AccessTokenCredential, TicketCredential, CookieCredential] = None\n        self._admin_token: str = thread_obj.get_value(APIConstants.ADMIN_CRED)\n        self._user_token: str = thread_obj.get_value(APIConstants.CLIENT_CRED)\n        self._cookie: str = thread_obj.get_value(APIConstants.COOKIE_CRED)\n        self._admin_cred_type = thread_obj.get_value(APIConstants.ADMIN_CRED_TYPE)",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ApplicationDefaultCredential",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "class ApplicationDefaultCredential(Credential):\n    def __init__(self):\n        super().__init__()\n        self._credential_obj = None\n        self._credential: Union[\n            AccessTokenCredential,\n            TicketCredential,\n            RefreshTokenCredential\n        ] = None\n        # load credentials from environment",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_CATALYST_AUTH_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "_CATALYST_AUTH_ENV_KEY = 'CATALYST_AUTH'\n_JWT_TOKEN_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.JWT_TOKEN,\n    APIConstants.SCOPES\n]\n_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_JWT_TOKEN_KEYS",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "_JWT_TOKEN_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.JWT_TOKEN,\n    APIConstants.SCOPES\n]\n_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN\n]",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_REFRESH_OBJ_KEYS",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN\n]\n_CATALYST_SCOPES = ['admin', 'user']\n_PORTAL_ID=os.getenv('CATALYST_PORTAL_DOMAIN')\nICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_CATALYST_SCOPES",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "_CATALYST_SCOPES = ['admin', 'user']\n_PORTAL_ID=os.getenv('CATALYST_PORTAL_DOMAIN')\nICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],\n    'jwt_token': str\n})\nICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystJwtObj",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],\n    'jwt_token': str\n})\nICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,\n    'refresh_token': str\n})",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystRefreshObj",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,\n    'refresh_token': str\n})\nICatalystTokenObj = TypedDict('ICatalystTokenObj', {\n    'access_token': str\n})\nICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystTokenObj",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystTokenObj = TypedDict('ICatalystTokenObj', {\n    'access_token': str\n})\nICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str\n})\n# Credential class for all credentials\nclass Credential(ABC):\n    @abstractmethod\n    def token(self):",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystTicketObj",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.credentials",
        "description": ".build.functions.exams.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str\n})\n# Credential class for all credentials\nclass Credential(ABC):\n    @abstractmethod\n    def token(self):\n        pass\n    def _switch_user(self, user=None):  # pylint: disable=unused-argument\n        return None",
        "detail": ".build.functions.exams.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystCronReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.cron",
        "description": ".build.functions.exams.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronReq(ICatalystCron):\n    pass\nclass ICatalystCronUpdateReq(ICatalystCron):\n    id: str  # pylint: disable=invalid-name\nclass ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:",
        "detail": ".build.functions.exams.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystCronUpdateReq",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.cron",
        "description": ".build.functions.exams.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronUpdateReq(ICatalystCron):\n    id: str  # pylint: disable=invalid-name\nclass ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)",
        "detail": ".build.functions.exams.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystCronRes",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.cron",
        "description": ".build.functions.exams.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CRON",
        "detail": ".build.functions.exams.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "Cron",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.cron",
        "description": ".build.functions.exams.zcatalyst_sdk.cron",
        "peekOfCode": "class Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CRON\n    def get_all_cron(self) -> List[ICatalystCronRes]:\n        resp = self._requester.request(\n            method=RequestMethod.GET,\n            path='/cron',",
        "detail": ".build.functions.exams.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystMailResp",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.email",
        "description": ".build.functions.exams.zcatalyst_sdk.email",
        "peekOfCode": "class ICatalystMailResp(ICatalystMail):\n    project_details: Optional[ICatalystProject]\nclass Email(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.MAIL\n    def send_mail(self, mail_obj: ICatalystMail) -> ICatalystMailResp:\n        validator.is_non_empty_dict(mail_obj, 'mail_obj', CatalystMailError)",
        "detail": ".build.functions.exams.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "Email",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.email",
        "description": ".build.functions.exams.zcatalyst_sdk.email",
        "peekOfCode": "class Email(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.MAIL\n    def send_mail(self, mail_obj: ICatalystMail) -> ICatalystMailResp:\n        validator.is_non_empty_dict(mail_obj, 'mail_obj', CatalystMailError)\n        mail_data = self._generate_data(mail_obj)\n        resp = self._requester.request(",
        "detail": ".build.functions.exams.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "_MAIL_OBJ_DICT",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.email",
        "description": ".build.functions.exams.zcatalyst_sdk.email",
        "peekOfCode": "_MAIL_OBJ_DICT = {\n    'from_email': str,\n    'to_email': list,\n    'subject': str,\n    'content': str,\n    'cc': list,\n    'bcc': list,\n    'reply_to': list,\n    'html_mode': bool,\n    'display_name': str,",
        "detail": ".build.functions.exams.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "CatalystError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystError(Exception):\n    def __init__(self, code, message, value=None, status_code = None):\n        self._code = code\n        self._message = message\n        self._http_status_code = status_code\n        self._value = value\n        Exception.__init__(self, self.to_string())\n    @property\n    def code(self):\n        return self._code",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCredentialError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCredentialError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAppError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAppError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAppError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)\n    @property\n    def status_code(self):\n        return self.http_status_code",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAPIError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)\n    @property\n    def status_code(self):\n        return self.http_status_code\nclass CatalystCacheError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCacheError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCacheError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDatastoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystDatastoreError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystDatastoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystFunctionError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystMailError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystFilestoreError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAuthenticationError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystZCQLError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCronError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCircuitError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystConnectorError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystPushNotificationError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystSearchError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystZiaError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "BrowserLogicError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "QuickMLError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystStratusError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystPipelineError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystNoSqlError",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystDeprecationWarning",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "description": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.exams.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "Functions",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.functions",
        "description": ".build.functions.exams.zcatalyst_sdk.functions",
        "peekOfCode": "class Functions(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.FUNCTION\n    def execute(self, func_id: Union[str, int], args: Dict = None):\n        validator.is_non_empty_string_or_number(func_id, 'func_id', CatalystFunctionError)\n        if args is not None and not isinstance(args, dict):\n            raise CatalystFunctionError(",
        "detail": ".build.functions.exams.zcatalyst_sdk.functions",
        "documentation": {}
    },
    {
        "label": "LogLevel",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.logger",
        "description": ".build.functions.exams.zcatalyst_sdk.logger",
        "peekOfCode": "class LogLevel:\n    DEBUG = 10\n    INFO = 20\n    WARNING = 30\n    ERROR = 40\n    CRITICAL = 50\n    LEVELS = {\n        DEBUG: 'DEBUG',\n        INFO: 'INFO',\n        WARNING: 'WARNING',",
        "detail": ".build.functions.exams.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.logger",
        "description": ".build.functions.exams.zcatalyst_sdk.logger",
        "peekOfCode": "class Logger:\n    def __init__(self,\n        name: str = None,\n        log_level=LogLevel.WARNING,\n        log_format='{timestamp} [{level}] {message}'\n    ):\n        self.name = name\n        self.log_level = log_level\n        self.log_format = log_format\n    def set_level(self, level: int):",
        "detail": ".build.functions.exams.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.logger",
        "description": ".build.functions.exams.zcatalyst_sdk.logger",
        "peekOfCode": "def get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.exams.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "_global_logger",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.logger",
        "description": ".build.functions.exams.zcatalyst_sdk.logger",
        "peekOfCode": "_global_logger = Logger()\n_logger_registry = {}\ndef get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.exams.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "_logger_registry",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.logger",
        "description": ".build.functions.exams.zcatalyst_sdk.logger",
        "peekOfCode": "_logger_registry = {}\ndef get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.exams.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.pipeline",
        "description": ".build.functions.exams.zcatalyst_sdk.pipeline",
        "peekOfCode": "class Pipeline(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.PIPELINE\n    def get_pipeline_details(self, pipeline_id: str) -> PipelineDetails:\n        \"\"\"Get the details of the pipelines.\n        Args:\n            pipeline_id (str): Id to get the details of the pipeline.",
        "detail": ".build.functions.exams.zcatalyst_sdk.pipeline",
        "documentation": {}
    },
    {
        "label": "QuickML",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.quick_ml",
        "description": ".build.functions.exams.zcatalyst_sdk.quick_ml",
        "peekOfCode": "class QuickML(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.QUICK_ML\n    def predict(\n        self,\n        end_point_key: str,\n        input_data: Dict[str,Union[str, int]]",
        "detail": ".build.functions.exams.zcatalyst_sdk.quick_ml",
        "documentation": {}
    },
    {
        "label": "Search",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.search",
        "description": ".build.functions.exams.zcatalyst_sdk.search",
        "peekOfCode": "class Search(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.SEARCH\n    def execute_search_query(\n        self,\n        query: ICatalystSearchQuery\n    ) -> Dict[str, List[Dict[str, Any]]]:",
        "detail": ".build.functions.exams.zcatalyst_sdk.search",
        "documentation": {}
    },
    {
        "label": "SmartBrowz",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.smart_browz",
        "description": ".build.functions.exams.zcatalyst_sdk.smart_browz",
        "peekOfCode": "class SmartBrowz(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.SMART_BROWZ\n    def convert_to_pdf(\n        self,\n        source: str,\n        pdf_options: PdfOptions  = None,",
        "detail": ".build.functions.exams.zcatalyst_sdk.smart_browz",
        "documentation": {}
    },
    {
        "label": "is_valid_email",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_valid_email(email):\n    \"\"\"\n    validates the given value is a email\n    Args:\n        email: The value to validate.\n    Returns:\n        bool: Whether the value is a valid email or not.\n    \"\"\"\n    regex = r'^[^@]+@[^@]+$'\n    if re.fullmatch(regex, email):",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_bool",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_bool(value):\n    \"\"\"\n    validates the given value is a boolean\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a boolean or not.\n    \"\"\"\n    return isinstance(value, bool)\ndef _is_number(value):",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_string",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_string(value):\n    \"\"\"\n    validates the given value is a string\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a string or not.\n    \"\"\"\n    return isinstance(value, str)\ndef is_list(value):",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_list",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_list(value):\n    \"\"\"\n    validates the given value is a list\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a list or not.\n    \"\"\"\n    return isinstance(value, list)\ndef is_dict(value):",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_dict",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_dict(value):\n    \"\"\"\n    validates the given value is a dict\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a dict or not.\n    \"\"\"\n    return isinstance(value, dict)\ndef is_set(value):",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_set",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_set(value):\n    \"\"\"\n    validates the given value is a set\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a set or not.\n    \"\"\"\n    return isinstance(value, set)\ndef is_tuple(value):",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_tuple",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_tuple(value):\n    \"\"\"\n    validates the given value is a tuple\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a tuple or not.\n    \"\"\"\n    return isinstance(value, tuple)\ndef is_buffered_reader(value):",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_buffered_reader",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_buffered_reader(value):\n    \"\"\"\n    validates the given value is a buffered reader or not\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a buffered reader or not.\n    \"\"\"\n    return isinstance(value, BufferedReader)\ndef is_non_empty_string(",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_string",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_string(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty string\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_string_or_number",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_string_or_number(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty string or number\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_parsable_number",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_parsable_number(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a parsable number\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_parsable_integer",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_parsable_integer(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a parsable integer\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_list",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_list(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty list\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_tuple",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_tuple(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty tuple\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_dict",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_dict(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty dict\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_keys_present",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_keys_present(\n    obj: dict,\n    keys: List[str],\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates a dict has given keys. Note: single level\n    Args:\n        obj: The obj to validate.",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_deprecated_key_present",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_deprecated_key_present(\n    obj: dict,\n    depkey: str,\n    actkey: Optional[str] = None,\n    delet : bool = False,\n    warn: bool = False\n):\n    \"\"\"\n    validates a dict has deprecated key. Note: single level\n    Args:",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_valid_url",
        "kind": 2,
        "importPath": ".build.functions.exams.zcatalyst_sdk.validator",
        "description": ".build.functions.exams.zcatalyst_sdk.validator",
        "peekOfCode": "def is_valid_url(url):\n    \"\"\"\n    validates the given value is a valid url\n    Args:\n        email: The value to validate.\n    Returns:\n        bool: Whether the value is a valid url or not.\n    \"\"\"\n    regex = \"\"\"^https?:\\\\/\\\\/(?:www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\n            \\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)$\"\"\"",
        "detail": ".build.functions.exams.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "Zcql",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.zcql",
        "description": ".build.functions.exams.zcatalyst_sdk.zcql",
        "peekOfCode": "class Zcql(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.ZCQL\n    def execute_query(self, query: str) -> List[ZcqlQueryOutput]:\n        if not query or not isinstance(query, str):\n            raise CatalystZCQLError(\n                'INVALID_QUERY',",
        "detail": ".build.functions.exams.zcatalyst_sdk.zcql",
        "documentation": {}
    },
    {
        "label": "ZcqlQueryOutput",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.zcql",
        "description": ".build.functions.exams.zcatalyst_sdk.zcql",
        "peekOfCode": "ZcqlQueryOutput = TypedDict('ZcqlQueryOutput', {'table_name': Dict})\nclass Zcql(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.ZCQL\n    def execute_query(self, query: str) -> List[ZcqlQueryOutput]:\n        if not query or not isinstance(query, str):\n            raise CatalystZCQLError(",
        "detail": ".build.functions.exams.zcatalyst_sdk.zcql",
        "documentation": {}
    },
    {
        "label": "Zia",
        "kind": 6,
        "importPath": ".build.functions.exams.zcatalyst_sdk.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.zia",
        "peekOfCode": "class Zia(Component):\n    def __init__(self, app):\n        self._app = app\n        self._requester = AuthorizedHttpClient(app)\n    def get_component_name(self):\n        return Components.ZIA\n    def detect_object(self, file: BufferedReader) -> ICatalystZiaObject:\n        self._is_valid_file_type(file)\n        resp = self._requester.request(\n            method=RequestMethod.POST,",
        "detail": ".build.functions.exams.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystOCROptions",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystOCROptions = TypedDict(\n    \"ICatalystOCROptions\",\n    {\"language\": Optional[str], \"model_type\": Optional[str]},\n    total=False,\n)\nICatalystBarCodeOptions = TypedDict(\n    \"ICatalystBarCodeOptions\", {\"format\": Optional[str]}\n)\nICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}",
        "detail": ".build.functions.exams.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystBarCodeOptions",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystBarCodeOptions = TypedDict(\n    \"ICatalystBarCodeOptions\", {\"format\": Optional[str]}\n)\nICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}\n)\nICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],",
        "detail": ".build.functions.exams.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystImageModerationOpts",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}\n)\nICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],\n        \"emotion\": Optional[bool],\n        \"age\": Optional[bool],\n        \"gender\": Optional[bool],",
        "detail": ".build.functions.exams.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystFaceAnalysisOptions",
        "kind": 5,
        "importPath": ".build.functions.exams.zcatalyst_sdk.zia",
        "description": ".build.functions.exams.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],\n        \"emotion\": Optional[bool],\n        \"age\": Optional[bool],\n        \"gender\": Optional[bool],\n    },\n    total=False,\n)",
        "detail": ".build.functions.exams.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": ".build.functions.exams.main",
        "description": ".build.functions.exams.main",
        "peekOfCode": "def handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")\n            if not exam:\n                return make_response(jsonify({\n                    \"error\": \"exam object missing\"",
        "detail": ".build.functions.exams.main",
        "documentation": {}
    },
    {
        "label": "EXAMS_TABLE",
        "kind": 5,
        "importPath": ".build.functions.exams.main",
        "description": ".build.functions.exams.main",
        "peekOfCode": "EXAMS_TABLE = \"exams\"\nRESULTS_TABLE = \"exam_results\"\nSTUDENTS_TABLE = \"students\"\nYELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":",
        "detail": ".build.functions.exams.main",
        "documentation": {}
    },
    {
        "label": "RESULTS_TABLE",
        "kind": 5,
        "importPath": ".build.functions.exams.main",
        "description": ".build.functions.exams.main",
        "peekOfCode": "RESULTS_TABLE = \"exam_results\"\nSTUDENTS_TABLE = \"students\"\nYELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()",
        "detail": ".build.functions.exams.main",
        "documentation": {}
    },
    {
        "label": "STUDENTS_TABLE",
        "kind": 5,
        "importPath": ".build.functions.exams.main",
        "description": ".build.functions.exams.main",
        "peekOfCode": "STUDENTS_TABLE = \"students\"\nYELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")",
        "detail": ".build.functions.exams.main",
        "documentation": {}
    },
    {
        "label": "YELLOW",
        "kind": 5,
        "importPath": ".build.functions.exams.main",
        "description": ".build.functions.exams.main",
        "peekOfCode": "YELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")\n            if not exam:",
        "detail": ".build.functions.exams.main",
        "documentation": {}
    },
    {
        "label": "RESET",
        "kind": 5,
        "importPath": ".build.functions.exams.main",
        "description": ".build.functions.exams.main",
        "peekOfCode": "RESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")\n            if not exam:\n                return make_response(jsonify({",
        "detail": ".build.functions.exams.main",
        "documentation": {}
    },
    {
        "label": "_Sentinel",
        "kind": 6,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "class _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(\n            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)\n        )\nelif sys.version_info >= (3, 9):",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_ExtensionsSpecialForm",
        "kind": 6,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):\n    def __repr__(self):\n        return 'typing_extensions.' + self._name\nFinal = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.\n    # See https://bugs.python.org/issue46342",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_DefaultMixin",
        "kind": 6,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "class _DefaultMixin:\n    \"\"\"Mixin for TypeVarLike defaults.\"\"\"\n    __slots__ = ()\n    __init__ = _set_default\n# Classes using this metaclass must provide a _backported_typevarlike ClassVar\nclass _TypeVarLikeMeta(type):\n    def __instancecheck__(cls, __instance: Any) -> bool:\n        return isinstance(__instance, cls._backported_typevarlike)\nif _PEP_696_IMPLEMENTED:\n    from typing import TypeVar",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_TypeVarLikeMeta",
        "kind": 6,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "class _TypeVarLikeMeta(type):\n    def __instancecheck__(cls, __instance: Any) -> bool:\n        return isinstance(__instance, cls._backported_typevarlike)\nif _PEP_696_IMPLEMENTED:\n    from typing import TypeVar\nelse:\n    # Add default and infer_variance parameters from PEP 696 and 695\n    class TypeVar(metaclass=_TypeVarLikeMeta):\n        \"\"\"Type variable.\"\"\"\n        _backported_typevarlike = typing.TypeVar",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_SpecialForm",
        "kind": 6,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "class _SpecialForm(typing._Final, _root=True):\n    __slots__ = ('_name', '__doc__', '_getitem')\n    def __init__(self, getitem):\n        self._getitem = getitem\n        self._name = getitem.__name__\n        self.__doc__ = getitem.__doc__\n    def __getattr__(self, item):\n        if item in {'__name__', '__qualname__'}:\n            return self._name\n        raise AttributeError(item)",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "IntVar",
        "kind": 2,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "def IntVar(name):\n    return typing.TypeVar(name)\n# A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8\nif sys.version_info >= (3, 10, 1):\n    Literal = typing.Literal\nelse:\n    def _flatten_literal_params(parameters):\n        \"\"\"An internal helper for Literal creation: flatten Literals among parameters\"\"\"\n        params = []\n        for p in parameters:",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "__all__ = [\n    # Super-special typing primitives.\n    'Any',\n    'ClassVar',\n    'Concatenate',\n    'Final',\n    'LiteralString',\n    'ParamSpec',\n    'ParamSpecArgs',\n    'ParamSpecKwargs',",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "PEP_560",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "PEP_560 = True\nGenericMeta = type\n_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "GenericMeta",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "GenericMeta = type\n_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PEP_696_IMPLEMENTED",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_marker",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(\n            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)\n        )\nelif sys.version_info >= (3, 9):\n    def _should_collect_from_parameters(t):\n        return isinstance(t, (typing._GenericAlias, _types.GenericAlias))\nelse:",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "NoReturn = typing.NoReturn\n# Some unconstrained type variables.  These are used by the container types.\n# (These are not for export.)\nT = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "T = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "KT",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "KT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "VT",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "VT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_co",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "T_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_contra",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "T_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)\n        def __repr__(self):",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "ClassVar = typing.ClassVar\nclass _ExtensionsSpecialForm(typing._SpecialForm, _root=True):\n    def __repr__(self):\n        return 'typing_extensions.' + self._name\nFinal = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Final",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Final = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.\n    # See https://bugs.python.org/issue46342\n    def final(f):\n        \"\"\"This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_overload_dummy",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_overload_dummy = typing._overload_dummy\nif hasattr(typing, \"get_overloads\"):  # 3.11+\n    overload = typing.overload\n    get_overloads = typing.get_overloads\n    clear_overloads = typing.clear_overloads\nelse:\n    # {module: {qualname: {firstlineno: func}}}\n    _overload_registry = collections.defaultdict(\n        functools.partial(collections.defaultdict, dict)\n    )",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Type",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Type = typing.Type\n# Various ABCs mimicking those in collections.abc.\n# A few are simply re-exported for completeness.\nAwaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Awaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Coroutine",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Coroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterable",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "AsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "AsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Deque",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Deque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "DefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "OrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Counter",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Counter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "ChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Text",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Text = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(\n        typing, \"_SpecialGenericAlias\", typing._GenericAlias",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "TYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(\n        typing, \"_SpecialGenericAlias\", typing._GenericAlias\n    )",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PROTO_ALLOWLIST",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_PROTO_ALLOWLIST = {\n    'collections.abc': [\n        'Callable', 'Awaitable', 'Iterable', 'Iterator', 'AsyncIterable',\n        'Hashable', 'Sized', 'Container', 'Collection', 'Reversible', 'Buffer',\n    ],\n    'contextlib': ['AbstractContextManager', 'AbstractAsyncContextManager'],\n    'typing_extensions': ['Buffer'],\n}\n_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {\n    \"__match_args__\", \"__protocol_attrs__\", \"__non_callable_proto_members__\",",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_EXCLUDED_ATTRS",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {\n    \"__match_args__\", \"__protocol_attrs__\", \"__non_callable_proto_members__\",\n    \"__final__\",\n}\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object\n        if base.__name__ in {'Protocol', 'Generic'}:\n            continue\n        annotations = getattr(base, '__annotations__', {})",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "runtime",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "runtime = runtime_checkable\n# Our version of runtime-checkable protocols is faster on Python 3.8-3.11\nif sys.version_info >= (3, 12):\n    SupportsInt = typing.SupportsInt\n    SupportsFloat = typing.SupportsFloat\n    SupportsComplex = typing.SupportsComplex\n    SupportsBytes = typing.SupportsBytes\n    SupportsIndex = typing.SupportsIndex\n    SupportsAbs = typing.SupportsAbs\n    SupportsRound = typing.SupportsRound",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PEP_728_IMPLEMENTED",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_PEP_728_IMPLEMENTED = False\nif _PEP_728_IMPLEMENTED:\n    # The standard library TypedDict in Python 3.8 does not store runtime information\n    # about which (if any) keys are optional.  See https://bugs.python.org/issue38834\n    # The standard library TypedDict in Python 3.9.0/1 does not honour the \"total\"\n    # keyword with old-style TypedDict().  See https://bugs.python.org/issue42059\n    # The standard library TypedDict below Python 3.11 does not store runtime\n    # information about optional and required keys when using Required or NotRequired.\n    # Generic TypedDicts are also impossible using typing.TypedDict on Python <3.11.\n    # Aaaand on 3.12 we add __orig_bases__ to TypedDict",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_UNPACK_DOC",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_UNPACK_DOC = \"\"\"\\\nType unpack operator.\nThe type unpack operator takes the child types from some container type,\nsuch as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For\nexample:\n  # For some generic class `Foo`:\n  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]\n  Ts = TypeVarTuple('Ts')\n  # Specifies that `Bar` is generic in an arbitrary number of types.\n  # (Think of `Ts` as a tuple of an arbitrary number of individual",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_TYPEVARTUPLE_TYPES",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_TYPEVARTUPLE_TYPES = {TypeVarTuple, getattr(typing, \"TypeVarTuple\", None)}\ndef _is_unpacked_typevartuple(x) -> bool:\n    if get_origin(x) is not Unpack:\n        return False\n    args = get_args(x)\n    return (\n        bool(args)\n        and len(args) == 1\n        and type(args[0]) in _TYPEVARTUPLE_TYPES\n    )",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_CapsuleType",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "_CapsuleType = getattr(_types, \"CapsuleType\", None)\nif _CapsuleType is None:\n    try:\n        import _socket\n    except ImportError:\n        pass\n    else:\n        _CAPI = getattr(_socket, \"CAPI\", None)\n        if _CAPI is not None:\n            _CapsuleType = type(_CAPI)",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "AbstractSet = typing.AbstractSet\nAnyStr = typing.AnyStr\nBinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "AnyStr = typing.AnyStr\nBinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "BinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Callable",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Callable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Collection",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Collection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Container = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Dict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ForwardRef",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "ForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "FrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Generic",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Generic = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Hashable",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Hashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "IO",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "IO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ItemsView",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "ItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Iterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Iterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "KeysView",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "KeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "List = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Mapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MappingView",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "MappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Match = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "MutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "MutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "MutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Optional",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Optional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Pattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Reversible",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Reversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Sequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Set = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Sized",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Sized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "TextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Tuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Union",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "Union = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "ValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "cast",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "cast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "no_type_check",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "no_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "no_type_check_decorator",
        "kind": 5,
        "importPath": ".build.functions.exams.typing_extensions",
        "description": ".build.functions.exams.typing_extensions",
        "peekOfCode": "no_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.exams.typing_extensions",
        "documentation": {}
    },
    {
        "label": "exit_cacert_ctx",
        "kind": 2,
        "importPath": ".build.functions.school.certifi.core",
        "description": ".build.functions.school.certifi.core",
        "peekOfCode": "def exit_cacert_ctx() -> None:\n    _CACERT_CTX.__exit__(None, None, None)  # type: ignore[union-attr]\nif sys.version_info >= (3, 11):\n    from importlib.resources import as_file, files\n    _CACERT_CTX = None\n    _CACERT_PATH = None\n    def where() -> str:\n        # This is slightly terrible, but we want to delay extracting the file\n        # in cases where we're inside of a zipimport situation until someone\n        # actually calls where(), but we don't want to re-extract the file",
        "detail": ".build.functions.school.certifi.core",
        "documentation": {}
    },
    {
        "label": "from_bytes",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.api",
        "description": ".build.functions.school.charset_normalizer.api",
        "peekOfCode": "def from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.school.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "from_fp",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.api",
        "description": ".build.functions.school.charset_normalizer.api",
        "peekOfCode": "def from_fp(\n    fp: BinaryIO,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.school.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "from_path",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.api",
        "description": ".build.functions.school.charset_normalizer.api",
        "peekOfCode": "def from_path(\n    path: str | bytes | PathLike,  # type: ignore[type-arg]\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.school.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "is_binary",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.api",
        "description": ".build.functions.school.charset_normalizer.api",
        "peekOfCode": "def is_binary(\n    fp_or_path_or_payload: PathLike | str | BinaryIO | bytes,  # type: ignore[type-arg]\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.school.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.api",
        "description": ".build.functions.school.charset_normalizer.api",
        "peekOfCode": "logger = logging.getLogger(\"charset_normalizer\")\nexplain_handler = logging.StreamHandler()\nexplain_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s | %(levelname)s | %(message)s\")\n)\ndef from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,",
        "detail": ".build.functions.school.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "explain_handler",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.api",
        "description": ".build.functions.school.charset_normalizer.api",
        "peekOfCode": "explain_handler = logging.StreamHandler()\nexplain_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s | %(levelname)s | %(message)s\")\n)\ndef from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,\n    cp_isolation: list[str] | None = None,",
        "detail": ".build.functions.school.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "encoding_unicode_range",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def encoding_unicode_range(iana_name: str) -> list[str]:\n    \"\"\"\n    Return associated unicode ranges in a single byte code page.\n    \"\"\"\n    if is_multi_byte_encoding(iana_name):\n        raise OSError(\"Function not supported on multi-byte code page\")\n    decoder = importlib.import_module(f\"encodings.{iana_name}\").IncrementalDecoder\n    p: IncrementalDecoder = decoder(errors=\"ignore\")\n    seen_ranges: dict[str, int] = {}\n    character_count: int = 0",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "unicode_range_languages",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def unicode_range_languages(primary_range: str) -> list[str]:\n    \"\"\"\n    Return inferred languages used with a unicode range.\n    \"\"\"\n    languages: list[str] = []\n    for language, characters in FREQUENCIES.items():\n        for character in characters:\n            if unicode_range(character) == primary_range:\n                languages.append(language)\n                break",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "encoding_languages",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def encoding_languages(iana_name: str) -> list[str]:\n    \"\"\"\n    Single-byte encoding language association. Some code page are heavily linked to particular language(s).\n    This function does the correspondence.\n    \"\"\"\n    unicode_ranges: list[str] = encoding_unicode_range(iana_name)\n    primary_range: str | None = None\n    for specified_range in unicode_ranges:\n        if \"Latin\" not in specified_range:\n            primary_range = specified_range",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "mb_encoding_languages",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def mb_encoding_languages(iana_name: str) -> list[str]:\n    \"\"\"\n    Multi-byte encoding language association. Some code page are heavily linked to particular language(s).\n    This function does the correspondence.\n    \"\"\"\n    if (\n        iana_name.startswith(\"shift_\")\n        or iana_name.startswith(\"iso2022_jp\")\n        or iana_name.startswith(\"euc_j\")\n        or iana_name == \"cp932\"",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "get_target_features",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def get_target_features(language: str) -> tuple[bool, bool]:\n    \"\"\"\n    Determine main aspects from a supported language if it contains accents and if is pure Latin.\n    \"\"\"\n    target_have_accents: bool = False\n    target_pure_latin: bool = True\n    for character in FREQUENCIES[language]:\n        if not target_have_accents and is_accentuated(character):\n            target_have_accents = True\n        if target_pure_latin and is_latin(character) is False:",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "alphabet_languages",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def alphabet_languages(\n    characters: list[str], ignore_non_latin: bool = False\n) -> list[str]:\n    \"\"\"\n    Return associated languages associated to given characters.\n    \"\"\"\n    languages: list[tuple[str, float]] = []\n    source_have_accents = any(is_accentuated(character) for character in characters)\n    for language, language_characters in FREQUENCIES.items():\n        target_have_accents, target_pure_latin = get_target_features(language)",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "characters_popularity_compare",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def characters_popularity_compare(\n    language: str, ordered_characters: list[str]\n) -> float:\n    \"\"\"\n    Determine if a ordered characters list (by occurrence from most appearance to rarest) match a particular language.\n    The result is a ratio between 0. (absolutely no correspondence) and 1. (near perfect fit).\n    Beware that is function is not strict on the match in order to ease the detection. (Meaning close match is 1.)\n    \"\"\"\n    if language not in FREQUENCIES:\n        raise ValueError(f\"{language} not available\")",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "alpha_unicode_split",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def alpha_unicode_split(decoded_sequence: str) -> list[str]:\n    \"\"\"\n    Given a decoded text sequence, return a list of str. Unicode range / alphabet separation.\n    Ex. a text containing English/Latin with a bit a Hebrew will return two items in the resulting list;\n    One containing the latin letters and the other hebrew.\n    \"\"\"\n    layers: dict[str, str] = {}\n    for character in decoded_sequence:\n        if character.isalpha() is False:\n            continue",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "merge_coherence_ratios",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def merge_coherence_ratios(results: list[CoherenceMatches]) -> CoherenceMatches:\n    \"\"\"\n    This function merge results previously given by the function coherence_ratio.\n    The return type is the same as coherence_ratio.\n    \"\"\"\n    per_language_ratios: dict[str, list[float]] = {}\n    for result in results:\n        for sub_result in result:\n            language, ratio = sub_result\n            if language not in per_language_ratios:",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "filter_alt_coherence_matches",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def filter_alt_coherence_matches(results: CoherenceMatches) -> CoherenceMatches:\n    \"\"\"\n    We shall NOT return \"English\" in CoherenceMatches because it is an alternative\n    of \"English\". This function only keeps the best match and remove the em-dash in it.\n    \"\"\"\n    index_results: dict[str, list[float]] = dict()\n    for result in results:\n        language, ratio = result\n        no_em_name: str = language.replace(\"\", \"\")\n        if no_em_name not in index_results:",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "coherence_ratio",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.cd",
        "description": ".build.functions.school.charset_normalizer.cd",
        "peekOfCode": "def coherence_ratio(\n    decoded_sequence: str, threshold: float = 0.1, lg_inclusion: str | None = None\n) -> CoherenceMatches:\n    \"\"\"\n    Detect ANY language that can be identified in given sequence. The sequence will be analysed by layers.\n    A layer = Character extraction by alphabets/ranges.\n    \"\"\"\n    results: list[tuple[str, float]] = []\n    ignore_non_latin: bool = False\n    sufficient_match_count: int = 0",
        "detail": ".build.functions.school.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "RE_POSSIBLE_ENCODING_INDICATION",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.constant",
        "description": ".build.functions.school.charset_normalizer.constant",
        "peekOfCode": "RE_POSSIBLE_ENCODING_INDICATION = re_compile(\n    r\"(?:(?:encoding)|(?:charset)|(?:coding))(?:[\\:= ]{1,10})(?:[\\\"\\']?)([a-zA-Z0-9\\-_]+)(?:[\\\"\\']?)\",\n    IGNORECASE,\n)\nIANA_NO_ALIASES = [\n    \"cp720\",\n    \"cp737\",\n    \"cp856\",\n    \"cp874\",\n    \"cp875\",",
        "detail": ".build.functions.school.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "IANA_NO_ALIASES",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.constant",
        "description": ".build.functions.school.charset_normalizer.constant",
        "peekOfCode": "IANA_NO_ALIASES = [\n    \"cp720\",\n    \"cp737\",\n    \"cp856\",\n    \"cp874\",\n    \"cp875\",\n    \"cp1006\",\n    \"koi8_r\",\n    \"koi8_t\",\n    \"koi8_u\",",
        "detail": ".build.functions.school.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_CHINESE_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.constant",
        "description": ".build.functions.school.charset_normalizer.constant",
        "peekOfCode": "COMMON_CHINESE_CHARACTERS = \"\"\nCOMMON_JAPANESE_CHARACTERS = \"\"\nCOMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,",
        "detail": ".build.functions.school.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_JAPANESE_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.constant",
        "description": ".build.functions.school.charset_normalizer.constant",
        "peekOfCode": "COMMON_JAPANESE_CHARACTERS = \"\"\nCOMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]",
        "detail": ".build.functions.school.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_KOREAN_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.constant",
        "description": ".build.functions.school.charset_normalizer.constant",
        "peekOfCode": "COMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]\n    )",
        "detail": ".build.functions.school.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_CJK_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.constant",
        "description": ".build.functions.school.charset_normalizer.constant",
        "peekOfCode": "COMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]\n    )\n)\nKO_NAMES: set[str] = {\"johab\", \"cp949\", \"euc_kr\"}",
        "detail": ".build.functions.school.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "detect",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.legacy",
        "description": ".build.functions.school.charset_normalizer.legacy",
        "peekOfCode": "def detect(\n    byte_str: bytes, should_rename_legacy: bool = False, **kwargs: Any\n) -> ResultDict:\n    \"\"\"\n    chardet legacy method\n    Detect the encoding of the given byte string. It should be mostly backward-compatible.\n    Encoding name will match Chardet own writing whenever possible. (Not on encoding name unsupported by it)\n    This function is deprecated and should be used to migrate your project easily, consult the documentation for\n    further information. Not planned for removal.\n    :param byte_str:     The byte sequence to examine.",
        "detail": ".build.functions.school.charset_normalizer.legacy",
        "documentation": {}
    },
    {
        "label": "MessDetectorPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class MessDetectorPlugin:\n    \"\"\"\n    Base abstract class used for mess detection plugins.\n    All detectors MUST extend and implement given methods.\n    \"\"\"\n    def eligible(self, character: str) -> bool:\n        \"\"\"\n        Determine if given character should be fed in.\n        \"\"\"\n        raise NotImplementedError  # pragma: nocover",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "TooManySymbolOrPunctuationPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class TooManySymbolOrPunctuationPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._punctuation_count: int = 0\n        self._symbol_count: int = 0\n        self._character_count: int = 0\n        self._last_printable_char: str | None = None\n        self._frenzy_symbol_in_word: bool = False\n    def eligible(self, character: str) -> bool:\n        return character.isprintable()\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "TooManyAccentuatedPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class TooManyAccentuatedPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._accentuated_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return character.isalpha()\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if is_accentuated(character):\n            self._accentuated_count += 1",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "UnprintablePlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class UnprintablePlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._unprintable_count: int = 0\n        self._character_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return True\n    def feed(self, character: str) -> None:\n        if is_unprintable(character):\n            self._unprintable_count += 1\n        self._character_count += 1",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuspiciousDuplicateAccentPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class SuspiciousDuplicateAccentPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._successive_count: int = 0\n        self._character_count: int = 0\n        self._last_latin_character: str | None = None\n    def eligible(self, character: str) -> bool:\n        return character.isalpha() and is_latin(character)\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if (",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuspiciousRange",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class SuspiciousRange(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._suspicious_successive_range_count: int = 0\n        self._character_count: int = 0\n        self._last_printable_seen: str | None = None\n    def eligible(self, character: str) -> bool:\n        return character.isprintable()\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if (",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuperWeirdWordPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class SuperWeirdWordPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._word_count: int = 0\n        self._bad_word_count: int = 0\n        self._foreign_long_count: int = 0\n        self._is_current_word_bad: bool = False\n        self._foreign_long_watch: bool = False\n        self._character_count: int = 0\n        self._bad_character_count: int = 0\n        self._buffer: str = \"\"",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "CjkUncommonPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class CjkUncommonPlugin(MessDetectorPlugin):\n    \"\"\"\n    Detect messy CJK text that probably means nothing.\n    \"\"\"\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._uncommon_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return is_cjk(character)\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "ArchaicUpperLowerPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class ArchaicUpperLowerPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._buf: bool = False\n        self._character_count_since_last_sep: int = 0\n        self._successive_upper_lower_count: int = 0\n        self._successive_upper_lower_count_final: int = 0\n        self._character_count: int = 0\n        self._last_alpha_seen: str | None = None\n        self._current_ascii_only: bool = True\n    def eligible(self, character: str) -> bool:",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "ArabicIsolatedFormPlugin",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "class ArabicIsolatedFormPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._isolated_form_count: int = 0\n    def reset(self) -> None:  # Abstract\n        self._character_count = 0\n        self._isolated_form_count = 0\n    def eligible(self, character: str) -> bool:\n        return is_arabic(character)\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "is_suspiciously_successive_range",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "def is_suspiciously_successive_range(\n    unicode_range_a: str | None, unicode_range_b: str | None\n) -> bool:\n    \"\"\"\n    Determine if two Unicode range seen next to each other can be considered as suspicious.\n    \"\"\"\n    if unicode_range_a is None or unicode_range_b is None:\n        return True\n    if unicode_range_a == unicode_range_b:\n        return False",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "mess_ratio",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.md",
        "description": ".build.functions.school.charset_normalizer.md",
        "peekOfCode": "def mess_ratio(\n    decoded_sequence: str, maximum_threshold: float = 0.2, debug: bool = False\n) -> float:\n    \"\"\"\n    Compute a mess ratio given a decoded bytes sequence. The maximum threshold does stop the computation earlier.\n    \"\"\"\n    detectors: list[MessDetectorPlugin] = [\n        md_class() for md_class in MessDetectorPlugin.__subclasses__()\n    ]\n    length: int = len(decoded_sequence) + 1",
        "detail": ".build.functions.school.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "CharsetMatch",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.models",
        "description": ".build.functions.school.charset_normalizer.models",
        "peekOfCode": "class CharsetMatch:\n    def __init__(\n        self,\n        payload: bytes,\n        guessed_encoding: str,\n        mean_mess_ratio: float,\n        has_sig_or_bom: bool,\n        languages: CoherenceMatches,\n        decoded_payload: str | None = None,\n        preemptive_declaration: str | None = None,",
        "detail": ".build.functions.school.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CharsetMatches",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.models",
        "description": ".build.functions.school.charset_normalizer.models",
        "peekOfCode": "class CharsetMatches:\n    \"\"\"\n    Container with every CharsetMatch items ordered by default from most probable to the less one.\n    Act like a list(iterable) but does not implements all related methods.\n    \"\"\"\n    def __init__(self, results: list[CharsetMatch] | None = None):\n        self._results: list[CharsetMatch] = sorted(results) if results else []\n    def __iter__(self) -> Iterator[CharsetMatch]:\n        yield from self._results\n    def __getitem__(self, item: int | str) -> CharsetMatch:",
        "detail": ".build.functions.school.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CliDetectionResult",
        "kind": 6,
        "importPath": ".build.functions.school.charset_normalizer.models",
        "description": ".build.functions.school.charset_normalizer.models",
        "peekOfCode": "class CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,\n        alphabets: list[str],\n        has_sig_or_bom: bool,",
        "detail": ".build.functions.school.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CoherenceMatch",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.models",
        "description": ".build.functions.school.charset_normalizer.models",
        "peekOfCode": "CoherenceMatch = Tuple[str, float]\nCoherenceMatches = List[CoherenceMatch]\nclass CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,",
        "detail": ".build.functions.school.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CoherenceMatches",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.models",
        "description": ".build.functions.school.charset_normalizer.models",
        "peekOfCode": "CoherenceMatches = List[CoherenceMatch]\nclass CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,\n        alphabets: list[str],",
        "detail": ".build.functions.school.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "is_accentuated",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_accentuated(character: str) -> bool:\n    try:\n        description: str = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return (\n        \"WITH GRAVE\" in description\n        or \"WITH ACUTE\" in description\n        or \"WITH CEDILLA\" in description\n        or \"WITH DIAERESIS\" in description",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "remove_accent",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def remove_accent(character: str) -> str:\n    decomposed: str = unicodedata.decomposition(character)\n    if not decomposed:\n        return character\n    codes: list[str] = decomposed.split(\" \")\n    return chr(int(codes[0], 16))\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef unicode_range(character: str) -> str | None:\n    \"\"\"\n    Retrieve the Unicode range official name from a single character.",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "unicode_range",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def unicode_range(character: str) -> str | None:\n    \"\"\"\n    Retrieve the Unicode range official name from a single character.\n    \"\"\"\n    character_ord: int = ord(character)\n    for range_name, ord_range in UNICODE_RANGES_COMBINED.items():\n        if character_ord in ord_range:\n            return range_name\n    return None\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_latin",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_latin(character: str) -> bool:\n    try:\n        description: str = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"LATIN\" in description\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_punctuation(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"P\" in character_category:",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_punctuation",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_punctuation(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"P\" in character_category:\n        return True\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Punctuation\" in character_range\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_symbol(character: str) -> bool:",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_symbol",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_symbol(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"S\" in character_category or \"N\" in character_category:\n        return True\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Forms\" in character_range and character_category != \"Lo\"\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_emoticon(character: str) -> bool:",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_emoticon",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_emoticon(character: str) -> bool:\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Emoticons\" in character_range or \"Pictographs\" in character_range\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_separator(character: str) -> bool:\n    if character.isspace() or character in {\"\", \"+\", \"<\", \">\"}:\n        return True\n    character_category: str = unicodedata.category(character)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_separator",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_separator(character: str) -> bool:\n    if character.isspace() or character in {\"\", \"+\", \"<\", \">\"}:\n        return True\n    character_category: str = unicodedata.category(character)\n    return \"Z\" in character_category or character_category in {\"Po\", \"Pd\", \"Pc\"}\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_case_variable(character: str) -> bool:\n    return character.islower() != character.isupper()\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk(character: str) -> bool:",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_case_variable",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_case_variable(character: str) -> bool:\n    return character.islower() != character.isupper()\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"CJK\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cjk",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_cjk(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"CJK\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_hiragana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_hiragana",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_hiragana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"HIRAGANA\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_katakana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_katakana",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_katakana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"KATAKANA\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_hangul(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_hangul",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_hangul(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"HANGUL\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_thai(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_thai",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_thai(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"THAI\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_arabic(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_arabic",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_arabic(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"ARABIC\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_arabic_isolated_form(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_arabic_isolated_form",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_arabic_isolated_form(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"ARABIC\" in character_name and \"ISOLATED FORM\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk_uncommon(character: str) -> bool:\n    return character not in COMMON_CJK_CHARACTERS\n@lru_cache(maxsize=len(UNICODE_RANGES_COMBINED))",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cjk_uncommon",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_cjk_uncommon(character: str) -> bool:\n    return character not in COMMON_CJK_CHARACTERS\n@lru_cache(maxsize=len(UNICODE_RANGES_COMBINED))\ndef is_unicode_range_secondary(range_name: str) -> bool:\n    return any(keyword in range_name for keyword in UNICODE_SECONDARY_RANGE_KEYWORD)\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_unicode_range_secondary",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_unicode_range_secondary(range_name: str) -> bool:\n    return any(keyword in range_name for keyword in UNICODE_SECONDARY_RANGE_KEYWORD)\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False\n        and character != \"\\x1a\"  # Why? Its the ASCII substitute character.\n        and character != \"\\ufeff\"  # bug discovered in Python,\n        # Zero Width No-Break Space located in \tArabic Presentation Forms-B, Unicode 1.1 not acknowledged as space.",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_unprintable",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False\n        and character != \"\\x1a\"  # Why? Its the ASCII substitute character.\n        and character != \"\\ufeff\"  # bug discovered in Python,\n        # Zero Width No-Break Space located in \tArabic Presentation Forms-B, Unicode 1.1 not acknowledged as space.\n    )\ndef any_specified_encoding(sequence: bytes, search_zone: int = 8192) -> str | None:\n    \"\"\"",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "any_specified_encoding",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def any_specified_encoding(sequence: bytes, search_zone: int = 8192) -> str | None:\n    \"\"\"\n    Extract using ASCII-only decoder any specified encoding in the first n-bytes.\n    \"\"\"\n    if not isinstance(sequence, bytes):\n        raise TypeError\n    seq_len: int = len(sequence)\n    results: list[str] = findall(\n        RE_POSSIBLE_ENCODING_INDICATION,\n        sequence[: min(seq_len, search_zone)].decode(\"ascii\", errors=\"ignore\"),",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_multi_byte_encoding",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_multi_byte_encoding(name: str) -> bool:\n    \"\"\"\n    Verify is a specific encoding is a multi byte one based on it IANA name\n    \"\"\"\n    return name in {\n        \"utf_8\",\n        \"utf_8_sig\",\n        \"utf_16\",\n        \"utf_16_be\",\n        \"utf_16_le\",",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "identify_sig_or_bom",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def identify_sig_or_bom(sequence: bytes) -> tuple[str | None, bytes]:\n    \"\"\"\n    Identify and extract SIG/BOM in given sequence.\n    \"\"\"\n    for iana_encoding in ENCODING_MARKS:\n        marks: bytes | list[bytes] = ENCODING_MARKS[iana_encoding]\n        if isinstance(marks, bytes):\n            marks = [marks]\n        for mark in marks:\n            if sequence.startswith(mark):",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "should_strip_sig_or_bom",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def should_strip_sig_or_bom(iana_encoding: str) -> bool:\n    return iana_encoding not in {\"utf_16\", \"utf_32\"}\ndef iana_name(cp_name: str, strict: bool = True) -> str:\n    \"\"\"Returns the Python normalized encoding name (Not the IANA official name).\"\"\"\n    cp_name = cp_name.lower().replace(\"-\", \"_\")\n    encoding_alias: str\n    encoding_iana: str\n    for encoding_alias, encoding_iana in aliases.items():\n        if cp_name in [encoding_alias, encoding_iana]:\n            return encoding_iana",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "iana_name",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def iana_name(cp_name: str, strict: bool = True) -> str:\n    \"\"\"Returns the Python normalized encoding name (Not the IANA official name).\"\"\"\n    cp_name = cp_name.lower().replace(\"-\", \"_\")\n    encoding_alias: str\n    encoding_iana: str\n    for encoding_alias, encoding_iana in aliases.items():\n        if cp_name in [encoding_alias, encoding_iana]:\n            return encoding_iana\n    if strict:\n        raise ValueError(f\"Unable to retrieve IANA for '{cp_name}'\")",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "cp_similarity",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def cp_similarity(iana_name_a: str, iana_name_b: str) -> float:\n    if is_multi_byte_encoding(iana_name_a) or is_multi_byte_encoding(iana_name_b):\n        return 0.0\n    decoder_a = importlib.import_module(f\"encodings.{iana_name_a}\").IncrementalDecoder\n    decoder_b = importlib.import_module(f\"encodings.{iana_name_b}\").IncrementalDecoder\n    id_a: IncrementalDecoder = decoder_a(errors=\"ignore\")\n    id_b: IncrementalDecoder = decoder_b(errors=\"ignore\")\n    character_match_count: int = 0\n    for i in range(255):\n        to_be_decoded: bytes = bytes([i])",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cp_similar",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def is_cp_similar(iana_name_a: str, iana_name_b: str) -> bool:\n    \"\"\"\n    Determine if two code page are at least 80% similar. IANA_SUPPORTED_SIMILAR dict was generated using\n    the function cp_similarity.\n    \"\"\"\n    return (\n        iana_name_a in IANA_SUPPORTED_SIMILAR\n        and iana_name_b in IANA_SUPPORTED_SIMILAR[iana_name_a]\n    )\ndef set_logging_handler(",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "set_logging_handler",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def set_logging_handler(\n    name: str = \"charset_normalizer\",\n    level: int = logging.INFO,\n    format_string: str = \"%(asctime)s | %(levelname)s | %(message)s\",\n) -> None:\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(format_string))\n    logger.addHandler(handler)",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "cut_sequence_chunks",
        "kind": 2,
        "importPath": ".build.functions.school.charset_normalizer.utils",
        "description": ".build.functions.school.charset_normalizer.utils",
        "peekOfCode": "def cut_sequence_chunks(\n    sequences: bytes,\n    encoding_iana: str,\n    offsets: range,\n    chunk_size: int,\n    bom_or_sig_available: bool,\n    strip_sig_or_bom: bool,\n    sig_payload: bytes,\n    is_multi_byte_decoder: bool,\n    decoded_payload: str | None = None,",
        "detail": ".build.functions.school.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.version",
        "description": ".build.functions.school.charset_normalizer.version",
        "peekOfCode": "__version__ = \"3.4.4\"\nVERSION = __version__.split(\".\")",
        "detail": ".build.functions.school.charset_normalizer.version",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": ".build.functions.school.charset_normalizer.version",
        "description": ".build.functions.school.charset_normalizer.version",
        "peekOfCode": "VERSION = __version__.split(\".\")",
        "detail": ".build.functions.school.charset_normalizer.version",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": ".build.functions.school.idna.codec",
        "description": ".build.functions.school.idna.codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        return encode(data), len(data)\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))",
        "detail": ".build.functions.school.idna.codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": ".build.functions.school.idna.codec",
        "description": ".build.functions.school.idna.codec",
        "peekOfCode": "class IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = b\"\"\n        if labels:\n            if not labels[-1]:",
        "detail": ".build.functions.school.idna.codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": ".build.functions.school.idna.codec",
        "description": ".build.functions.school.idna.codec",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return (\"\", 0)\n        if not isinstance(data, str):\n            data = str(data, \"ascii\")\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = \"\"",
        "detail": ".build.functions.school.idna.codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": ".build.functions.school.idna.codec",
        "description": ".build.functions.school.idna.codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    pass\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,",
        "detail": ".build.functions.school.idna.codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": ".build.functions.school.idna.codec",
        "description": ".build.functions.school.idna.codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    pass\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,  # type: ignore\n        incrementalencoder=IncrementalEncoder,",
        "detail": ".build.functions.school.idna.codec",
        "documentation": {}
    },
    {
        "label": "search_function",
        "kind": 2,
        "importPath": ".build.functions.school.idna.codec",
        "description": ".build.functions.school.idna.codec",
        "peekOfCode": "def search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,  # type: ignore\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,",
        "detail": ".build.functions.school.idna.codec",
        "documentation": {}
    },
    {
        "label": "_unicode_dots_re",
        "kind": 5,
        "importPath": ".build.functions.school.idna.codec",
        "description": ".build.functions.school.idna.codec",
        "peekOfCode": "_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        return encode(data), len(data)\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":",
        "detail": ".build.functions.school.idna.codec",
        "documentation": {}
    },
    {
        "label": "ToASCII",
        "kind": 2,
        "importPath": ".build.functions.school.idna.compat",
        "description": ".build.functions.school.idna.compat",
        "peekOfCode": "def ToASCII(label: str) -> bytes:\n    return encode(label)\ndef ToUnicode(label: Union[bytes, bytearray]) -> str:\n    return decode(label)\ndef nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.school.idna.compat",
        "documentation": {}
    },
    {
        "label": "ToUnicode",
        "kind": 2,
        "importPath": ".build.functions.school.idna.compat",
        "description": ".build.functions.school.idna.compat",
        "peekOfCode": "def ToUnicode(label: Union[bytes, bytearray]) -> str:\n    return decode(label)\ndef nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.school.idna.compat",
        "documentation": {}
    },
    {
        "label": "nameprep",
        "kind": 2,
        "importPath": ".build.functions.school.idna.compat",
        "description": ".build.functions.school.idna.compat",
        "peekOfCode": "def nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.school.idna.compat",
        "documentation": {}
    },
    {
        "label": "IDNAError",
        "kind": 6,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "class IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "IDNABidiError",
        "kind": 6,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "class IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "InvalidCodepoint",
        "kind": 6,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "class InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "InvalidCodepointContext",
        "kind": 6,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "class InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):\n            raise ValueError(\"Unknown character in unicodedata\")\n    return v\ndef _is_script(cp: str, script: str) -> bool:",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_label_length",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def valid_label_length(label: Union[bytes, str]) -> bool:\n    if len(label) > 63:\n        return False\n    return True\ndef valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_string_length",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == \"\":",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "check_bidi",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == \"\":\n            # String likely comes from a newer version of Unicode\n            raise IDNABidiError(\"Unknown directionality in label {} at position {}\".format(repr(label), idx))\n        if direction in [\"R\", \"AL\", \"AN\"]:\n            bidi_label = True",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "check_initial_combiner",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def check_initial_combiner(label: str) -> bool:\n    if unicodedata.category(label[0])[0] == \"M\":\n        raise IDNAError(\"Label begins with an illegal combining character\")\n    return True\ndef check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == \"--\":\n        raise IDNAError(\"Label has disallowed hyphens in 3rd and 4th position\")\n    if label[0] == \"-\" or label[-1] == \"-\":\n        raise IDNAError(\"Label must not start or end with a hyphen\")\n    return True",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "check_hyphen_ok",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == \"--\":\n        raise IDNAError(\"Label has disallowed hyphens in 3rd and 4th position\")\n    if label[0] == \"-\" or label[-1] == \"-\":\n        raise IDNAError(\"Label must not start or end with a hyphen\")\n    return True\ndef check_nfc(label: str) -> None:\n    if unicodedata.normalize(\"NFC\", label) != label:\n        raise IDNAError(\"Label must be in Normalization Form C\")\ndef valid_contextj(label: str, pos: int) -> bool:",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "check_nfc",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def check_nfc(label: str) -> None:\n    if unicodedata.normalize(\"NFC\", label) != label:\n        raise IDNAError(\"Label must be in Normalization Form C\")\ndef valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x200C:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        ok = False",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_contextj",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x200C:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        ok = False\n        for i in range(pos - 1, -1, -1):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord(\"T\"):",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_contexto",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def valid_contexto(label: str, pos: int, exception: bool = False) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x00B7:\n        if 0 < pos < len(label) - 1:\n            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:\n                return True\n        return False\n    elif cp_value == 0x0375:\n        if pos < len(label) - 1 and len(label) > 1:\n            return _is_script(label[pos + 1], \"Greek\")",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "check_label",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def check_label(label: Union[str, bytes, bytearray]) -> None:\n    if isinstance(label, (bytes, bytearray)):\n        label = label.decode(\"utf-8\")\n    if len(label) == 0:\n        raise IDNAError(\"Empty Label\")\n    check_nfc(label)\n    check_hyphen_ok(label)\n    check_initial_combiner(label)\n    for pos, cp in enumerate(label):\n        cp_value = ord(cp)",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "alabel",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def alabel(label: str) -> bytes:\n    try:\n        label_bytes = label.encode(\"ascii\")\n        ulabel(label_bytes)\n        if not valid_label_length(label_bytes):\n            raise IDNAError(\"Label too long\")\n        return label_bytes\n    except UnicodeEncodeError:\n        pass\n    check_label(label)",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "ulabel",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def ulabel(label: Union[str, bytes, bytearray]) -> str:\n    if not isinstance(label, (bytes, bytearray)):\n        try:\n            label_bytes = label.encode(\"ascii\")\n        except UnicodeEncodeError:\n            check_label(label)\n            return label\n    else:\n        label_bytes = bytes(label)\n    label_bytes = label_bytes.lower()",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "uts46_remap",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:\n    \"\"\"Re-map the characters in the string according to UTS46 processing.\"\"\"\n    from .uts46data import uts46data\n    output = \"\"\n    for pos, char in enumerate(domain):\n        code_point = ord(char)\n        try:\n            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, \"Z\")) - 1]\n            status = uts46row[1]\n            replacement: Optional[str] = None",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def encode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n    transitional: bool = False,\n) -> bytes:\n    if not isinstance(s, str):\n        try:\n            s = str(s, \"ascii\")",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "def decode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n) -> str:\n    try:\n        if not isinstance(s, str):\n            s = str(s, \"ascii\")\n    except UnicodeDecodeError:",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "_virama_combining_class",
        "kind": 5,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "_virama_combining_class = 9\n_alabel_prefix = b\"xn--\"\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "_alabel_prefix",
        "kind": 5,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "_alabel_prefix = b\"xn--\"\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "_unicode_dots_re",
        "kind": 5,
        "importPath": ".build.functions.school.idna.core",
        "description": ".build.functions.school.idna.core",
        "peekOfCode": "_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass",
        "detail": ".build.functions.school.idna.core",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.school.idna.idnadata",
        "description": ".build.functions.school.idna.idnadata",
        "peekOfCode": "__version__ = \"16.0.0\"\nscripts = {\n    \"Greek\": (\n        0x37000000374,\n        0x37500000378,\n        0x37A0000037E,\n        0x37F00000380,\n        0x38400000385,\n        0x38600000387,\n        0x3880000038B,",
        "detail": ".build.functions.school.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "scripts",
        "kind": 5,
        "importPath": ".build.functions.school.idna.idnadata",
        "description": ".build.functions.school.idna.idnadata",
        "peekOfCode": "scripts = {\n    \"Greek\": (\n        0x37000000374,\n        0x37500000378,\n        0x37A0000037E,\n        0x37F00000380,\n        0x38400000385,\n        0x38600000387,\n        0x3880000038B,\n        0x38C0000038D,",
        "detail": ".build.functions.school.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "joining_types",
        "kind": 5,
        "importPath": ".build.functions.school.idna.idnadata",
        "description": ".build.functions.school.idna.idnadata",
        "peekOfCode": "joining_types = {\n    0xAD: 84,\n    0x300: 84,\n    0x301: 84,\n    0x302: 84,\n    0x303: 84,\n    0x304: 84,\n    0x305: 84,\n    0x306: 84,\n    0x307: 84,",
        "detail": ".build.functions.school.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "codepoint_classes",
        "kind": 5,
        "importPath": ".build.functions.school.idna.idnadata",
        "description": ".build.functions.school.idna.idnadata",
        "peekOfCode": "codepoint_classes = {\n    \"PVALID\": (\n        0x2D0000002E,\n        0x300000003A,\n        0x610000007B,\n        0xDF000000F7,\n        0xF800000100,\n        0x10100000102,\n        0x10300000104,\n        0x10500000106,",
        "detail": ".build.functions.school.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "intranges_from_list",
        "kind": 2,
        "importPath": ".build.functions.school.idna.intranges",
        "description": ".build.functions.school.idna.intranges",
        "peekOfCode": "def intranges_from_list(list_: List[int]) -> Tuple[int, ...]:\n    \"\"\"Represent a list of integers as a sequence of ranges:\n    ((start_0, end_0), (start_1, end_1), ...), such that the original\n    integers are exactly those x such that start_i <= x < end_i for some i.\n    Ranges are encoded as single integers (start << 32 | end), not as tuples.\n    \"\"\"\n    sorted_list = sorted(list_)\n    ranges = []\n    last_write = -1\n    for i in range(len(sorted_list)):",
        "detail": ".build.functions.school.idna.intranges",
        "documentation": {}
    },
    {
        "label": "intranges_contain",
        "kind": 2,
        "importPath": ".build.functions.school.idna.intranges",
        "description": ".build.functions.school.idna.intranges",
        "peekOfCode": "def intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:\n    \"\"\"Determine if `int_` falls into one of the ranges in `ranges`.\"\"\"\n    tuple_ = _encode_range(int_, 0)\n    pos = bisect.bisect_left(ranges, tuple_)\n    # we could be immediately ahead of a tuple (start, end)\n    # with start < int_ <= end\n    if pos > 0:\n        left, right = _decode_range(ranges[pos - 1])\n        if left <= int_ < right:\n            return True",
        "detail": ".build.functions.school.idna.intranges",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.school.idna.package_data",
        "description": ".build.functions.school.idna.package_data",
        "peekOfCode": "__version__ = \"3.11\"",
        "detail": ".build.functions.school.idna.package_data",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.school.idna.uts46data",
        "description": ".build.functions.school.idna.uts46data",
        "peekOfCode": "__version__ = \"16.0.0\"\ndef _seg_0() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x0, \"V\"),\n        (0x1, \"V\"),\n        (0x2, \"V\"),\n        (0x3, \"V\"),\n        (0x4, \"V\"),\n        (0x5, \"V\"),\n        (0x6, \"V\"),",
        "detail": ".build.functions.school.idna.uts46data",
        "documentation": {}
    },
    {
        "label": "uts46data",
        "kind": 5,
        "importPath": ".build.functions.school.idna.uts46data",
        "description": ".build.functions.school.idna.uts46data",
        "peekOfCode": "uts46data = tuple(\n    _seg_0()\n    + _seg_1()\n    + _seg_2()\n    + _seg_3()\n    + _seg_4()\n    + _seg_5()\n    + _seg_6()\n    + _seg_7()\n    + _seg_8()",
        "detail": ".build.functions.school.idna.uts46data",
        "documentation": {}
    },
    {
        "label": "to_native_string",
        "kind": 2,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "def to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        out = string.decode(encoding)\n    return out",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "unicode_is_ascii",
        "kind": 2,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode(\"ascii\")\n        return True",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_NAME_RE_BYTE",
        "kind": 5,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_NAME_RE_BYTE = re.compile(rb\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_NAME_RE_STR = re.compile(r\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_NAME_RE_STR",
        "kind": 5,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_NAME_RE_STR = re.compile(r\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_VALUE_RE_BYTE",
        "kind": 5,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_VALUE_RE_STR",
        "kind": 5,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_HEADER_VALIDATORS_STR",
        "kind": 5,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_HEADER_VALIDATORS_BYTE",
        "kind": 5,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "HEADER_VALIDATORS",
        "kind": 5,
        "importPath": ".build.functions.school.requests._internal_utils",
        "description": ".build.functions.school.requests._internal_utils",
        "peekOfCode": "HEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):",
        "detail": ".build.functions.school.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "BaseAdapter",
        "kind": 6,
        "importPath": ".build.functions.school.requests.adapters",
        "description": ".build.functions.school.requests.adapters",
        "peekOfCode": "class BaseAdapter:\n    \"\"\"The Base Transport Adapter\"\"\"\n    def __init__(self):\n        super().__init__()\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.",
        "detail": ".build.functions.school.requests.adapters",
        "documentation": {}
    },
    {
        "label": "HTTPAdapter",
        "kind": 6,
        "importPath": ".build.functions.school.requests.adapters",
        "description": ".build.functions.school.requests.adapters",
        "peekOfCode": "class HTTPAdapter(BaseAdapter):\n    \"\"\"The built-in HTTP Adapter for urllib3.\n    Provides a general-case interface for Requests sessions to contact HTTP and\n    HTTPS urls by implementing the Transport Adapter interface. This class will\n    usually be created by the :class:`Session <Session>` class under the\n    covers.\n    :param pool_connections: The number of urllib3 connection pools to cache.\n    :param pool_maxsize: The maximum number of connections to save in the pool.\n    :param max_retries: The maximum number of retries each connection\n        should attempt. Note, this applies only to failed DNS lookups, socket",
        "detail": ".build.functions.school.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOLBLOCK",
        "kind": 5,
        "importPath": ".build.functions.school.requests.adapters",
        "description": ".build.functions.school.requests.adapters",
        "peekOfCode": "DEFAULT_POOLBLOCK = False\nDEFAULT_POOLSIZE = 10\nDEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":",
        "detail": ".build.functions.school.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOLSIZE",
        "kind": 5,
        "importPath": ".build.functions.school.requests.adapters",
        "description": ".build.functions.school.requests.adapters",
        "peekOfCode": "DEFAULT_POOLSIZE = 10\nDEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}",
        "detail": ".build.functions.school.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RETRIES",
        "kind": 5,
        "importPath": ".build.functions.school.requests.adapters",
        "description": ".build.functions.school.requests.adapters",
        "peekOfCode": "DEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}\n    pool_kwargs = {}",
        "detail": ".build.functions.school.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOL_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.school.requests.adapters",
        "description": ".build.functions.school.requests.adapters",
        "peekOfCode": "DEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}\n    pool_kwargs = {}\n    parsed_request_url = urlparse(request.url)",
        "detail": ".build.functions.school.requests.adapters",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def request(method, url, **kwargs):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n    :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "get",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def get(url, params=None, **kwargs):\n    r\"\"\"Sends a GET request.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"get\", url, params=params, **kwargs)",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def options(url, **kwargs):\n    r\"\"\"Sends an OPTIONS request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"options\", url, **kwargs)\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "head",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n        `allow_redirects` is not provided, it will be set to `False` (as\n        opposed to the default :meth:`request` behavior).\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    kwargs.setdefault(\"allow_redirects\", False)",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "post",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def post(url, data=None, json=None, **kwargs):\n    r\"\"\"Sends a POST request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "put",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def put(url, data=None, **kwargs):\n    r\"\"\"Sends a PUT request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "patch",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def patch(url, data=None, **kwargs):\n    r\"\"\"Sends a PATCH request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "delete",
        "kind": 2,
        "importPath": ".build.functions.school.requests.api",
        "description": ".build.functions.school.requests.api",
        "peekOfCode": "def delete(url, **kwargs):\n    r\"\"\"Sends a DELETE request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"delete\", url, **kwargs)",
        "detail": ".build.functions.school.requests.api",
        "documentation": {}
    },
    {
        "label": "AuthBase",
        "kind": 6,
        "importPath": ".build.functions.school.requests.auth",
        "description": ".build.functions.school.requests.auth",
        "peekOfCode": "class AuthBase:\n    \"\"\"Base class that all auth implementations derive from\"\"\"\n    def __call__(self, r):\n        raise NotImplementedError(\"Auth hooks must be callable.\")\nclass HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    def __eq__(self, other):",
        "detail": ".build.functions.school.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPBasicAuth",
        "kind": 6,
        "importPath": ".build.functions.school.requests.auth",
        "description": ".build.functions.school.requests.auth",
        "peekOfCode": "class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),",
        "detail": ".build.functions.school.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPProxyAuth",
        "kind": 6,
        "importPath": ".build.functions.school.requests.auth",
        "description": ".build.functions.school.requests.auth",
        "peekOfCode": "class HTTPProxyAuth(HTTPBasicAuth):\n    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n    def __call__(self, r):\n        r.headers[\"Proxy-Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r\nclass HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password",
        "detail": ".build.functions.school.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPDigestAuth",
        "kind": 6,
        "importPath": ".build.functions.school.requests.auth",
        "description": ".build.functions.school.requests.auth",
        "peekOfCode": "class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n    def init_per_thread_state(self):\n        # Ensure state is initialized just once per-thread\n        if not hasattr(self._thread_local, \"init\"):",
        "detail": ".build.functions.school.requests.auth",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE_FORM_URLENCODED",
        "kind": 5,
        "importPath": ".build.functions.school.requests.auth",
        "description": ".build.functions.school.requests.auth",
        "peekOfCode": "CONTENT_TYPE_FORM_URLENCODED = \"application/x-www-form-urlencoded\"\nCONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility",
        "detail": ".build.functions.school.requests.auth",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE_MULTI_PART",
        "kind": 5,
        "importPath": ".build.functions.school.requests.auth",
        "description": ".build.functions.school.requests.auth",
        "peekOfCode": "CONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility\n    # for things like ints. This will be removed in 3.0.0.",
        "detail": ".build.functions.school.requests.auth",
        "documentation": {}
    },
    {
        "label": "chardet",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "chardet = _resolve_char_detection()\n# -------\n# Pythons\n# -------\n# Syntax sugar.\n_ver = sys.version_info\n#: Python 2.x?\nis_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "_ver",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "_ver = sys.version_info\n#: Python 2.x?\nis_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "is_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "is_py3",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "is_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json\nif has_simplejson:\n    from simplejson import JSONDecodeError",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "has_simplejson",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "has_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json\nif has_simplejson:\n    from simplejson import JSONDecodeError\nelse:\n    from json import JSONDecodeError",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "builtin_str",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "builtin_str = str\nstr = str\nbytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "str = str\nbytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "bytes",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "bytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "basestring",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "basestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "numeric_types",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "numeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "integer_types",
        "kind": 5,
        "importPath": ".build.functions.school.requests.compat",
        "description": ".build.functions.school.requests.compat",
        "peekOfCode": "integer_types = (int,)",
        "detail": ".build.functions.school.requests.compat",
        "documentation": {}
    },
    {
        "label": "MockRequest",
        "kind": 6,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "class MockRequest:\n    \"\"\"Wraps a `requests.Request` to mimic a `urllib2.Request`.\n    The code in `http.cookiejar.CookieJar` expects this interface in order to correctly\n    manage cookie policies, i.e., determine whether a cookie can be set, given the\n    domains of the request and the cookie.\n    The original request object is read-only. The client is responsible for collecting\n    the new headers via `get_new_headers()` and interpreting them appropriately. You\n    probably want `get_cookie_header`, defined below.\n    \"\"\"\n    def __init__(self, request):",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "MockResponse",
        "kind": 6,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "class MockResponse:\n    \"\"\"Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n    ...what? Basically, expose the parsed HTTP headers from the server response\n    the way `http.cookiejar` expects to see them.\n    \"\"\"\n    def __init__(self, headers):\n        \"\"\"Make a MockResponse for `cookiejar` to read.\n        :param headers: a httplib.HTTPMessage or analogous carrying the headers\n        \"\"\"\n        self._headers = headers",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "CookieConflictError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "class CookieConflictError(RuntimeError):\n    \"\"\"There are two cookies that meet the criteria specified in the cookie jar.\n    Use .get and .set and include domain and path args in order to be more specific.\n    \"\"\"\nclass RequestsCookieJar(cookielib.CookieJar, MutableMapping):\n    \"\"\"Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\n    interface.\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "RequestsCookieJar",
        "kind": 6,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "class RequestsCookieJar(cookielib.CookieJar, MutableMapping):\n    \"\"\"Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\n    interface.\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n    Requests does not use the dict interface internally; it's just for\n    compatibility with external client code. All requests code should work\n    out of the box with externally provided instances of ``CookieJar``, e.g.\n    ``LWPCookieJar`` and ``FileCookieJar``.",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "extract_cookies_to_jar",
        "kind": 2,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "def extract_cookies_to_jar(jar, request, response):\n    \"\"\"Extract the cookies from the response into a CookieJar.\n    :param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n    :param request: our own requests.Request object\n    :param response: urllib3.HTTPResponse object\n    \"\"\"\n    if not (hasattr(response, \"_original_response\") and response._original_response):\n        return\n    # the _original_response field is the wrapped httplib.HTTPResponse object,\n    req = MockRequest(request)",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "get_cookie_header",
        "kind": 2,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "def get_cookie_header(jar, request):\n    \"\"\"\n    Produce an appropriate Cookie header string to be sent with `request`, or None.\n    :rtype: str\n    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get(\"Cookie\")\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "remove_cookie_by_name",
        "kind": 2,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "def remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.\n    Wraps CookieJar.clear(), is O(n).\n    \"\"\"\n    clearables = []\n    for cookie in cookiejar:\n        if cookie.name != name:\n            continue\n        if domain is not None and domain != cookie.domain:\n            continue",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "create_cookie",
        "kind": 2,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "def create_cookie(name, value, **kwargs):\n    \"\"\"Make a cookie from underspecified parameters.\n    By default, the pair of `name` and `value` will be set for the domain ''\n    and sent on every request (this is sometimes called a \"supercookie\").\n    \"\"\"\n    result = {\n        \"version\": 0,\n        \"name\": name,\n        \"value\": value,\n        \"port\": None,",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "morsel_to_cookie",
        "kind": 2,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "def morsel_to_cookie(morsel):\n    \"\"\"Convert a Morsel object into a Cookie containing the one k/v pair.\"\"\"\n    expires = None\n    if morsel[\"max-age\"]:\n        try:\n            expires = int(time.time() + int(morsel[\"max-age\"]))\n        except ValueError:\n            raise TypeError(f\"max-age: {morsel['max-age']} must be integer\")\n    elif morsel[\"expires\"]:\n        time_template = \"%a, %d-%b-%Y %H:%M:%S GMT\"",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "cookiejar_from_dict",
        "kind": 2,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :param cookiejar: (optional) A cookiejar to add the cookies to.\n    :param overwrite: (optional) If False, will not replace cookies\n        already in the jar with new ones.\n    :rtype: CookieJar\n    \"\"\"\n    if cookiejar is None:\n        cookiejar = RequestsCookieJar()",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "merge_cookies",
        "kind": 2,
        "importPath": ".build.functions.school.requests.cookies",
        "description": ".build.functions.school.requests.cookies",
        "peekOfCode": "def merge_cookies(cookiejar, cookies):\n    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n    :param cookiejar: CookieJar object to add the cookies to.\n    :param cookies: Dictionary or CookieJar object to be added.\n    :rtype: CookieJar\n    \"\"\"\n    if not isinstance(cookiejar, cookielib.CookieJar):\n        raise ValueError(\"You can only merge into CookieJar\")\n    if isinstance(cookies, dict):\n        cookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)",
        "detail": ".build.functions.school.requests.cookies",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class RequestException(IOError):\n    \"\"\"There was an ambiguous exception that occurred while handling your\n    request.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize RequestException with `request` and `response` objects.\"\"\"\n        response = kwargs.pop(\"response\", None)\n        self.response = response\n        self.request = kwargs.pop(\"request\", None)\n        if response is not None and not self.request and hasattr(response, \"request\"):",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidJSONError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class InvalidJSONError(RequestException):\n    \"\"\"A JSON error occurred.\"\"\"\nclass JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n    \"\"\"Couldn't decode the text into json\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Construct the JSONDecodeError instance first with all\n        args. Then use it's args to construct the IOError so that\n        the json specific args aren't used as IOError specific args\n        and the error message from JSONDecodeError is preserved.",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n    \"\"\"Couldn't decode the text into json\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Construct the JSONDecodeError instance first with all\n        args. Then use it's args to construct the IOError so that\n        the json specific args aren't used as IOError specific args\n        and the error message from JSONDecodeError is preserved.\n        \"\"\"\n        CompatJSONDecodeError.__init__(self, *args)",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class HTTPError(RequestException):\n    \"\"\"An HTTP error occurred.\"\"\"\nclass ConnectionError(RequestException):\n    \"\"\"A Connection error occurred.\"\"\"\nclass ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class ConnectionError(RequestException):\n    \"\"\"A Connection error occurred.\"\"\"\nclass ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"\nclass ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"\nclass ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.\n    Requests that produced this error are safe to retry.\n    \"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeout",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.\n    Requests that produced this error are safe to retry.\n    \"\"\"\nclass ReadTimeout(Timeout):\n    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"\nclass URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeout",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class ReadTimeout(Timeout):\n    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"\nclass URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "URLRequired",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "TooManyRedirects",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "MissingSchema",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidSchema",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidURL",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidProxyURL",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ChunkedEncodingError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ContentDecodingError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "StreamConsumedError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RetryError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "UnrewindableBodyError",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestsWarning",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "FileModeWarning",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestsDependencyWarning",
        "kind": 6,
        "importPath": ".build.functions.school.requests.exceptions",
        "description": ".build.functions.school.requests.exceptions",
        "peekOfCode": "class RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.school.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "info",
        "kind": 2,
        "importPath": ".build.functions.school.requests.help",
        "description": ".build.functions.school.requests.help",
        "peekOfCode": "def info():\n    \"\"\"Generate information for a bug report.\"\"\"\n    try:\n        platform_info = {\n            \"system\": platform.system(),\n            \"release\": platform.release(),\n        }\n    except OSError:\n        platform_info = {\n            \"system\": \"Unknown\",",
        "detail": ".build.functions.school.requests.help",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".build.functions.school.requests.help",
        "description": ".build.functions.school.requests.help",
        "peekOfCode": "def main():\n    \"\"\"Pretty-print the bug information as JSON.\"\"\"\n    print(json.dumps(info(), sort_keys=True, indent=2))\nif __name__ == \"__main__\":\n    main()",
        "detail": ".build.functions.school.requests.help",
        "documentation": {}
    },
    {
        "label": "default_hooks",
        "kind": 2,
        "importPath": ".build.functions.school.requests.hooks",
        "description": ".build.functions.school.requests.hooks",
        "peekOfCode": "def default_hooks():\n    return {event: [] for event in HOOKS}\n# TODO: response is the only one\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]",
        "detail": ".build.functions.school.requests.hooks",
        "documentation": {}
    },
    {
        "label": "dispatch_hook",
        "kind": 2,
        "importPath": ".build.functions.school.requests.hooks",
        "description": ".build.functions.school.requests.hooks",
        "peekOfCode": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if _hook_data is not None:",
        "detail": ".build.functions.school.requests.hooks",
        "documentation": {}
    },
    {
        "label": "HOOKS",
        "kind": 5,
        "importPath": ".build.functions.school.requests.hooks",
        "description": ".build.functions.school.requests.hooks",
        "peekOfCode": "HOOKS = [\"response\"]\ndef default_hooks():\n    return {event: [] for event in HOOKS}\n# TODO: response is the only one\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):",
        "detail": ".build.functions.school.requests.hooks",
        "documentation": {}
    },
    {
        "label": "RequestEncodingMixin",
        "kind": 6,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "class RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:\n            path = \"/\"\n        url.append(path)",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "RequestHooksMixin",
        "kind": 6,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "class RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n    def deregister_hook(self, event, hook):",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "Request",
        "kind": 6,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "class Request(RequestHooksMixin):\n    \"\"\"A user-created :class:`Request <Request>` object.\n    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n    :param method: HTTP method to use.\n    :param url: URL to send.\n    :param headers: dictionary of headers to send.\n    :param files: dictionary of {filename: fileobject} files to multipart upload.\n    :param data: the body to attach to the request. If a dictionary or\n        list of tuples ``[(key, value)]`` is provided, form-encoding will\n        take place.",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "PreparedRequest",
        "kind": 6,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n    \"\"\"The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\n    containing the exact bytes that will be sent to the server.\n    Instances are generated from a :class:`Request <Request>` object, and\n    should not be instantiated manually; doing so may produce undesirable\n    effects.\n    Usage::\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "class Response:\n    \"\"\"The :class:`Response <Response>` object, which contains a\n    server's response to an HTTP request.\n    \"\"\"\n    __attrs__ = [\n        \"_content\",\n        \"status_code\",\n        \"headers\",\n        \"url\",\n        \"history\",",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "REDIRECT_STATI",
        "kind": 5,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "REDIRECT_STATI = (\n    codes.moved,  # 301\n    codes.found,  # 302\n    codes.other,  # 303\n    codes.temporary_redirect,  # 307\n    codes.permanent_redirect,  # 308\n)\nDEFAULT_REDIRECT_LIMIT = 30\nCONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "DEFAULT_REDIRECT_LIMIT",
        "kind": 5,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "DEFAULT_REDIRECT_LIMIT = 30\nCONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "CONTENT_CHUNK_SIZE",
        "kind": 5,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "CONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "ITER_CHUNK_SIZE",
        "kind": 5,
        "importPath": ".build.functions.school.requests.models",
        "description": ".build.functions.school.requests.models",
        "peekOfCode": "ITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:\n            path = \"/\"",
        "detail": ".build.functions.school.requests.models",
        "documentation": {}
    },
    {
        "label": "SessionRedirectMixin",
        "kind": 6,
        "importPath": ".build.functions.school.requests.sessions",
        "description": ".build.functions.school.requests.sessions",
        "peekOfCode": "class SessionRedirectMixin:\n    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:",
        "detail": ".build.functions.school.requests.sessions",
        "documentation": {}
    },
    {
        "label": "Session",
        "kind": 6,
        "importPath": ".build.functions.school.requests.sessions",
        "description": ".build.functions.school.requests.sessions",
        "peekOfCode": "class Session(SessionRedirectMixin):\n    \"\"\"A Requests session.\n    Provides cookie persistence, connection-pooling, and configuration.\n    Basic Usage::\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n    Or as a context manager::\n      >>> with requests.Session() as s:",
        "detail": ".build.functions.school.requests.sessions",
        "documentation": {}
    },
    {
        "label": "merge_setting",
        "kind": 2,
        "importPath": ".build.functions.school.requests.sessions",
        "description": ".build.functions.school.requests.sessions",
        "peekOfCode": "def merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"Determines appropriate setting for a given request, taking into account\n    the explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n    if session_setting is None:\n        return request_setting\n    if request_setting is None:\n        return session_setting\n    # Bypass if not a dictionary (e.g. verify)",
        "detail": ".build.functions.school.requests.sessions",
        "documentation": {}
    },
    {
        "label": "merge_hooks",
        "kind": 2,
        "importPath": ".build.functions.school.requests.sessions",
        "description": ".build.functions.school.requests.sessions",
        "peekOfCode": "def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n    \"\"\"Properly merges both requests and session hooks.\n    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get(\"response\") == []:\n        return request_hooks\n    if request_hooks is None or request_hooks.get(\"response\") == []:\n        return session_hooks\n    return merge_setting(request_hooks, session_hooks, dict_class)",
        "detail": ".build.functions.school.requests.sessions",
        "documentation": {}
    },
    {
        "label": "session",
        "kind": 2,
        "importPath": ".build.functions.school.requests.sessions",
        "description": ".build.functions.school.requests.sessions",
        "peekOfCode": "def session():\n    \"\"\"\n    Returns a :class:`Session` for context-management.\n    .. deprecated:: 1.0.0\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n    :rtype: Session\n    \"\"\"\n    return Session()",
        "detail": ".build.functions.school.requests.sessions",
        "documentation": {}
    },
    {
        "label": "_codes",
        "kind": 5,
        "importPath": ".build.functions.school.requests.status_codes",
        "description": ".build.functions.school.requests.status_codes",
        "peekOfCode": "_codes = {\n    # Informational.\n    100: (\"continue\",),\n    101: (\"switching_protocols\",),\n    102: (\"processing\", \"early-hints\"),\n    103: (\"checkpoint\",),\n    122: (\"uri_too_long\", \"request_uri_too_long\"),\n    200: (\"ok\", \"okay\", \"all_ok\", \"all_okay\", \"all_good\", \"\\\\o/\", \"\"),\n    201: (\"created\",),\n    202: (\"accepted\",),",
        "detail": ".build.functions.school.requests.status_codes",
        "documentation": {}
    },
    {
        "label": "codes",
        "kind": 5,
        "importPath": ".build.functions.school.requests.status_codes",
        "description": ".build.functions.school.requests.status_codes",
        "peekOfCode": "codes = LookupDict(name=\"status_codes\")\ndef _init():\n    for code, titles in _codes.items():\n        for title in titles:\n            setattr(codes, title, code)\n            if not title.startswith((\"\\\\\", \"/\")):\n                setattr(codes, title.upper(), code)\n    def doc(code):\n        names = \", \".join(f\"``{n}``\" for n in _codes[code])\n        return \"* %d: %s\" % (code, names)",
        "detail": ".build.functions.school.requests.status_codes",
        "documentation": {}
    },
    {
        "label": "CaseInsensitiveDict",
        "kind": 6,
        "importPath": ".build.functions.school.requests.structures",
        "description": ".build.functions.school.requests.structures",
        "peekOfCode": "class CaseInsensitiveDict(MutableMapping):\n    \"\"\"A case-insensitive ``dict``-like object.\n    Implements all methods and operations of\n    ``MutableMapping`` as well as dict's ``copy``. Also\n    provides ``lower_items``.\n    All keys are expected to be strings. The structure remembers the\n    case of the last key to be set, and ``iter(instance)``,\n    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``\n    will contain case-sensitive keys. However, querying and contains\n    testing is case insensitive::",
        "detail": ".build.functions.school.requests.structures",
        "documentation": {}
    },
    {
        "label": "LookupDict",
        "kind": 6,
        "importPath": ".build.functions.school.requests.structures",
        "description": ".build.functions.school.requests.structures",
        "peekOfCode": "class LookupDict(dict):\n    \"\"\"Dictionary lookup object.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        super().__init__()\n    def __repr__(self):\n        return f\"<lookup '{self.name}'>\"\n    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n        return self.__dict__.get(key, None)",
        "detail": ".build.functions.school.requests.structures",
        "documentation": {}
    },
    {
        "label": "dict_to_sequence",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def dict_to_sequence(d):\n    \"\"\"Returns an internal sequence dictionary update.\"\"\"\n    if hasattr(d, \"items\"):\n        d = d.items()\n    return d\ndef super_len(o):\n    total_length = None\n    current_position = 0\n    if not is_urllib3_1 and isinstance(o, str):\n        # urllib3 2.x+ treats all strings as utf-8 instead",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "super_len",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def super_len(o):\n    total_length = None\n    current_position = 0\n    if not is_urllib3_1 and isinstance(o, str):\n        # urllib3 2.x+ treats all strings as utf-8 instead\n        # of latin-1 (iso-8859-1) like http.client.\n        o = o.encode(\"utf-8\")\n    if hasattr(o, \"__len__\"):\n        total_length = len(o)\n    elif hasattr(o, \"len\"):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_netrc_auth",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n    netrc_file = os.environ.get(\"NETRC\")\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n        netrc_locations = (f\"~/{f}\" for f in NETRC_FILES)\n    try:\n        from netrc import NetrcParseError, netrc\n        netrc_path = None",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "guess_filename",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def guess_filename(obj):\n    \"\"\"Tries to guess the filename of the given object.\"\"\"\n    name = getattr(obj, \"name\", None)\n    if name and isinstance(name, basestring) and name[0] != \"<\" and name[-1] != \">\":\n        return os.path.basename(name)\ndef extract_zipped_paths(path):\n    \"\"\"Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    \"\"\"",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "extract_zipped_paths",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def extract_zipped_paths(path):\n    \"\"\"Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    \"\"\"\n    if os.path.exists(path):\n        # this is already a valid path, no need to do anything further\n        return path\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "atomic_open",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def atomic_open(filename):\n    \"\"\"Write a file to the disk in an atomic fashion\"\"\"\n    tmp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))\n    try:\n        with os.fdopen(tmp_descriptor, \"wb\") as tmp_handler:\n            yield tmp_handler\n        os.replace(tmp_name, filename)\n    except BaseException:\n        os.remove(tmp_name)\n        raise",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "from_key_val_list",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def from_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. Unless it can not be represented as such, return an\n    OrderedDict, e.g.,\n    ::\n        >>> from_key_val_list([('key', 'val')])\n        OrderedDict([('key', 'val')])\n        >>> from_key_val_list('string')\n        Traceback (most recent call last):\n        ...",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "to_key_val_list",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def to_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. If it can be, return a list of tuples, e.g.,\n    ::\n        >>> to_key_val_list([('key', 'val')])\n        [('key', 'val')]\n        >>> to_key_val_list({'key': 'val'})\n        [('key', 'val')]\n        >>> to_key_val_list('string')\n        Traceback (most recent call last):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_list_header",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def parse_list_header(value):\n    \"\"\"Parse lists as described by RFC 2068 Section 2.\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Quotes are removed automatically after parsing.\n    It basically works like :func:`parse_set_header` just that items\n    may appear multiple times and case sensitivity is preserved.\n    The return value is a standard :class:`list`:\n    >>> parse_list_header('token, \"quoted value\"')",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_dict_header",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def parse_dict_header(value):\n    \"\"\"Parse lists of key, value pairs as described by RFC 2068 Section 2 and\n    convert them into a python dict:\n    >>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n    >>> type(d) is dict\n    True\n    >>> sorted(d.items())\n    [('bar', 'as well'), ('foo', 'is a fish')]\n    If there is no value for a key it will be `None`:\n    >>> parse_dict_header('key_without_value')",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "unquote_header_value",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def unquote_header_value(value, is_filename=False):\n    r\"\"\"Unquotes a header value.  (Reversal of :func:`quote_header_value`).\n    This does not use the real unquoting but what browsers are actually\n    using for quoting.\n    :param value: the header value to unquote.\n    :rtype: str\n    \"\"\"\n    if value and value[0] == value[-1] == '\"':\n        # this is not the real unquoting, but fixing this so that the\n        # RFC is met will result in bugs with internet explorer and",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "dict_from_cookiejar",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def dict_from_cookiejar(cj):\n    \"\"\"Returns a key/value dictionary from a CookieJar.\n    :param cj: CookieJar object to extract cookies from.\n    :rtype: dict\n    \"\"\"\n    cookie_dict = {cookie.name: cookie.value for cookie in cj}\n    return cookie_dict\ndef add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cj: CookieJar to insert cookies into.",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "add_dict_to_cookiejar",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cj: CookieJar to insert cookies into.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :rtype: CookieJar\n    \"\"\"\n    return cookiejar_from_dict(cookie_dict, cj)\ndef get_encodings_from_content(content):\n    \"\"\"Returns encodings from given content string.\n    :param content: bytestring to extract encodings from.",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_encodings_from_content",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def get_encodings_from_content(content):\n    \"\"\"Returns encodings from given content string.\n    :param content: bytestring to extract encodings from.\n    \"\"\"\n    warnings.warn(\n        (\n            \"In requests 3.0, get_encodings_from_content will be removed. For \"\n            \"more information, please see the discussion on issue #2266. (This\"\n            \" warning should only appear once.)\"\n        ),",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_encoding_from_headers",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def get_encoding_from_headers(headers):\n    \"\"\"Returns encodings from given HTTP Header Dict.\n    :param headers: dictionary to extract encoding from.\n    :rtype: str\n    \"\"\"\n    content_type = headers.get(\"content-type\")\n    if not content_type:\n        return None\n    content_type, params = _parse_content_type_header(content_type)\n    if \"charset\" in params:",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "stream_decode_response_unicode",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes an iterator.\"\"\"\n    if r.encoding is None:\n        yield from iterator\n        return\n    decoder = codecs.getincrementaldecoder(r.encoding)(errors=\"replace\")\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "iter_slices",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def iter_slices(string, slice_length):\n    \"\"\"Iterate over slices of a string.\"\"\"\n    pos = 0\n    if slice_length is None or slice_length <= 0:\n        slice_length = len(string)\n    while pos < len(string):\n        yield string[pos : pos + slice_length]\n        pos += slice_length\ndef get_unicode_from_response(r):\n    \"\"\"Returns the requested content back in unicode.",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_unicode_from_response",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def get_unicode_from_response(r):\n    \"\"\"Returns the requested content back in unicode.\n    :param r: Response object to get unicode content from.\n    Tried:\n    1. charset from content-type\n    2. fall back and replace all unicode characters\n    :rtype: str\n    \"\"\"\n    warnings.warn(\n        (",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "unquote_unreserved",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def unquote_unreserved(uri):\n    \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n    :rtype: str\n    \"\"\"\n    parts = uri.split(\"%\")\n    for i in range(1, len(parts)):\n        h = parts[i][0:2]\n        if len(h) == 2 and h.isalnum():\n            try:",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "requote_uri",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def requote_uri(uri):\n    \"\"\"Re-quote the given URI.\n    This function passes the given URI through an unquote/quote cycle to\n    ensure that it is fully and consistently quoted.\n    :rtype: str\n    \"\"\"\n    safe_with_percent = \"!#$%&'()*+,/:;=?@[]~\"\n    safe_without_percent = \"!#$&'()*+,/:;=?@[]~\"\n    try:\n        # Unquote only the unreserved characters",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "address_in_network",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n    :rtype: bool\n    \"\"\"\n    ipaddr = struct.unpack(\"=L\", socket.inet_aton(ip))[0]\n    netaddr, bits = net.split(\"/\")\n    netmask = struct.unpack(\"=L\", socket.inet_aton(dotted_netmask(int(bits))))[0]\n    network = struct.unpack(\"=L\", socket.inet_aton(netaddr))[0] & netmask",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "dotted_netmask",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def dotted_netmask(mask):\n    \"\"\"Converts mask from /xx format to xxx.xxx.xxx.xxx\n    Example: if mask is 24 function returns 255.255.255.0\n    :rtype: str\n    \"\"\"\n    bits = 0xFFFFFFFF ^ (1 << 32 - mask) - 1\n    return socket.inet_ntoa(struct.pack(\">I\", bits))\ndef is_ipv4_address(string_ip):\n    \"\"\"\n    :rtype: bool",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "is_ipv4_address",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def is_ipv4_address(string_ip):\n    \"\"\"\n    :rtype: bool\n    \"\"\"\n    try:\n        socket.inet_aton(string_ip)\n    except OSError:\n        return False\n    return True\ndef is_valid_cidr(string_network):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_cidr",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def is_valid_cidr(string_network):\n    \"\"\"\n    Very simple check of the cidr format in no_proxy variable.\n    :rtype: bool\n    \"\"\"\n    if string_network.count(\"/\") == 1:\n        try:\n            mask = int(string_network.split(\"/\")[1])\n        except ValueError:\n            return False",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "set_environ",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def set_environ(env_name, value):\n    \"\"\"Set the environment variable 'env_name' to 'value'\n    Save previous value, yield, and then restore the previous value stored in\n    the environment variable 'env_name'.\n    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "should_bypass_proxies",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def should_bypass_proxies(url, no_proxy):\n    \"\"\"\n    Returns whether we should bypass proxies or not.\n    :rtype: bool\n    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    def get_proxy(key):\n        return os.environ.get(key) or os.environ.get(key.upper())\n    # First check whether no_proxy is defined. If it is, check that the URL",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_environ_proxies",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def get_environ_proxies(url, no_proxy=None):\n    \"\"\"\n    Return a dict of environment proxies.\n    :rtype: dict\n    \"\"\"\n    if should_bypass_proxies(url, no_proxy=no_proxy):\n        return {}\n    else:\n        return getproxies()\ndef select_proxy(url, proxies):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "select_proxy",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def select_proxy(url, proxies):\n    \"\"\"Select a proxy for the url, if applicable.\n    :param url: The url being for the request\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get(\"all\"))\n    proxy_keys = [",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "resolve_proxies",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def resolve_proxies(request, proxies, trust_env=True):\n    \"\"\"This method takes proxy information from a request and configuration\n    input to resolve a mapping of target proxies. This will consider settings\n    such as NO_PROXY to strip proxy configurations.\n    :param request: Request or PreparedRequest\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    :param trust_env: Boolean declaring whether to trust environment configs\n    :rtype: dict\n    \"\"\"\n    proxies = proxies if proxies is not None else {}",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "default_user_agent",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def default_user_agent(name=\"python-requests\"):\n    \"\"\"\n    Return a string representing the default user agent.\n    :rtype: str\n    \"\"\"\n    return f\"{name}/{__version__}\"\ndef default_headers():\n    \"\"\"\n    :rtype: requests.structures.CaseInsensitiveDict\n    \"\"\"",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "default_headers",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def default_headers():\n    \"\"\"\n    :rtype: requests.structures.CaseInsensitiveDict\n    \"\"\"\n    return CaseInsensitiveDict(\n        {\n            \"User-Agent\": default_user_agent(),\n            \"Accept-Encoding\": DEFAULT_ACCEPT_ENCODING,\n            \"Accept\": \"*/*\",\n            \"Connection\": \"keep-alive\",",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_header_links",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def parse_header_links(value):\n    \"\"\"Return a list of parsed link headers proxies.\n    i.e. Link: <http:/.../front.jpeg>; rel=front; type=\"image/jpeg\",<http://.../back.jpeg>; rel=back;type=\"image/jpeg\"\n    :rtype: list\n    \"\"\"\n    links = []\n    replace_chars = \" '\\\"\"\n    value = value.strip(replace_chars)\n    if not value:\n        return links",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "guess_json_utf",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]\n    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):\n        return \"utf-32\"  # BOM included",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "prepend_scheme_if_needed",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def prepend_scheme_if_needed(url, new_scheme):\n    \"\"\"Given a URL that may or may not have a scheme, prepend the given scheme.\n    Does not replace a present scheme with the one provided as an argument.\n    :rtype: str\n    \"\"\"\n    parsed = parse_url(url)\n    scheme, auth, host, port, path, query, fragment = parsed\n    # A defect in urlparse determines that there isn't a netloc present in some\n    # urls. We previously assumed parsing was overly cautious, and swapped the\n    # netloc and path. Due to a lack of tests on the original defect, this is",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_auth_from_url",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n    :rtype: (str,str)\n    \"\"\"\n    parsed = urlparse(url)\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = (\"\", \"\")",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "check_header_validity",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def check_header_validity(header):\n    \"\"\"Verifies that header parts don't contain leading whitespace\n    reserved characters, or return characters.\n    :param header: tuple, in the format (name, value).\n    \"\"\"\n    name, value = header\n    _validate_header_part(header, name, 0)\n    _validate_header_part(header, value, 1)\ndef _validate_header_part(header, header_part, header_validator_index):\n    if isinstance(header_part, str):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "urldefragauth",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def urldefragauth(url):\n    \"\"\"\n    Given a url remove the fragment and the authentication part.\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, params, query, fragment = urlparse(url)\n    # see func:`prepend_scheme_if_needed`\n    if not netloc:\n        netloc, path = path, netloc\n    netloc = netloc.rsplit(\"@\", 1)[-1]",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "rewind_body",
        "kind": 2,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "def rewind_body(prepared_request):\n    \"\"\"Move file pointer back to its recorded starting position\n    so it can be read again on redirect.\n    \"\"\"\n    body_seek = getattr(prepared_request.body, \"seek\", None)\n    if body_seek is not None and isinstance(\n        prepared_request._body_position, integer_types\n    ):\n        try:\n            body_seek(prepared_request._body_position)",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "NETRC_FILES",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "NETRC_FILES = (\".netrc\", \"_netrc\")\nDEFAULT_CA_BUNDLE_PATH = certs.where()\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CA_BUNDLE_PATH",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "DEFAULT_CA_BUNDLE_PATH = certs.where()\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PORTS",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "DEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:\n            import winreg",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ACCEPT_ENCODING",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "DEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:\n            import winreg\n        except ImportError:\n            return False",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "UNRESERVED_SET",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "UNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\"\n)\ndef unquote_unreserved(uri):\n    \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n    :rtype: str\n    \"\"\"\n    parts = uri.split(\"%\")\n    for i in range(1, len(parts)):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "_null = \"\\x00\".encode(\"ascii\")  # encoding to ASCII for Python 3\n_null2 = _null * 2\n_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null2",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "_null2 = _null * 2\n_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null3",
        "kind": 5,
        "importPath": ".build.functions.school.requests.utils",
        "description": ".build.functions.school.requests.utils",
        "peekOfCode": "_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]\n    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):",
        "detail": ".build.functions.school.requests.utils",
        "documentation": {}
    },
    {
        "label": "EmscriptenHTTPConnection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.connection",
        "description": ".build.functions.school.urllib3.contrib.emscripten.connection",
        "peekOfCode": "class EmscriptenHTTPConnection:\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]\n    default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n    timeout: None | (float)\n    host: str\n    port: int\n    blocksize: int\n    source_address: tuple[str, int] | None\n    socket_options: _TYPE_SOCKET_OPTIONS | None\n    proxy: Url | None",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.connection",
        "documentation": {}
    },
    {
        "label": "EmscriptenHTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.connection",
        "description": ".build.functions.school.urllib3.contrib.emscripten.connection",
        "peekOfCode": "class EmscriptenHTTPSConnection(EmscriptenHTTPConnection):\n    default_port = port_by_scheme[\"https\"]\n    # all this is basically ignored, as browser handles https\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None\n    cert_file: str | None\n    key_file: str | None\n    key_password: str | None",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.connection",
        "documentation": {}
    },
    {
        "label": "_RequestError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request\n        self.response = response",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_StreamingError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _StreamingError(_RequestError):\n    pass\nclass _TimeoutError(_RequestError):\n    pass\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_TimeoutError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _TimeoutError(_RequestError):\n    pass\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_ReadStream",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,\n        worker: JsProxy,\n        connection_id: int,\n        request: EmscriptenRequest,\n    ):",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_StreamingFetcher",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _StreamingFetcher:\n    def __init__(self) -> None:\n        # make web-worker and data buffer on startup\n        self.streaming_ready = False\n        streaming_worker_code = (\n            files(__package__)\n            .joinpath(\"emscripten_fetch_worker.js\")\n            .read_text(encoding=\"utf-8\")\n        )\n        js_data_blob = js.Blob.new(",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_JSPIReadStream",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _JSPIReadStream(io.RawIOBase):\n    \"\"\"\n    A read stream that uses pyodide.ffi.run_sync to read from a JavaScript fetch\n    response. This requires support for WebAssembly JavaScript Promise Integration\n    in the containing browser, and for pyodide to be launched via runPythonAsync.\n    :param js_read_stream:\n        The JavaScript stream reader\n    :param timeout:\n        Timeout in seconds\n    :param request:",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_in_browser_main_thread",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_in_browser_main_thread() -> bool:\n    return hasattr(js, \"window\") and hasattr(js, \"self\") and js.self == js.window\ndef is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_cross_origin_isolated",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\ndef is_worker_available() -> bool:",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_in_node",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\ndef is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n_fetcher: _StreamingFetcher | None = None",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_worker_available",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n_fetcher: _StreamingFetcher | None = None\nif is_worker_available() and (\n    (is_cross_origin_isolated() and not is_in_browser_main_thread())\n    and (not is_in_node())\n):\n    _fetcher = _StreamingFetcher()\nelse:\n    _fetcher = None",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_streaming_request",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if has_jspi():\n        return send_jspi_request(request, True)\n    elif is_in_node():\n        raise _RequestError(\n            message=NODE_JSPI_ERROR,\n            request=request,\n            response=None,\n        )\n    if _fetcher and streaming_ready():",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_request",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_request(request: EmscriptenRequest) -> EmscriptenResponse:\n    if has_jspi():\n        return send_jspi_request(request, False)\n    elif is_in_node():\n        raise _RequestError(\n            message=NODE_JSPI_ERROR,\n            request=request,\n            response=None,\n        )\n    try:",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_jspi_request",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_jspi_request(\n    request: EmscriptenRequest, streaming: bool\n) -> EmscriptenResponse:\n    \"\"\"\n    Send a request using WebAssembly JavaScript Promise Integration\n    to wrap the asynchronous JavaScript fetch api (experimental).\n    :param request:\n        Request to send\n    :param streaming:\n        Whether to stream the response",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "has_jspi",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def has_jspi() -> bool:\n    \"\"\"\n    Return true if jspi can be used.\n    This requires both browser support and also WebAssembly\n    to be in the correct state - i.e. that the javascript\n    call into python was async not sync.\n    :return: True if jspi can be used.\n    :rtype: bool\n    \"\"\"\n    try:",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "streaming_ready",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def streaming_ready() -> bool | None:\n    if _fetcher:\n        return _fetcher.streaming_ready\n    else:\n        return None  # no fetcher, return None to signify that\nasync def wait_for_streaming_ready() -> bool:\n    if _fetcher:\n        await _fetcher.js_worker_ready_promise\n        return True\n    else:",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "HEADERS_TO_IGNORE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "HEADERS_TO_IGNORE = (\"user-agent\",)\nSUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "SUCCESS_HEADER",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "SUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "SUCCESS_EOF",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "SUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "ERROR_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "ERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "ERROR_EXCEPTION",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "ERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "NODE_JSPI_ERROR",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "NODE_JSPI_ERROR = (\n    \"urllib3 only works in Node.js with pyodide.runPythonAsync\"\n    \" and requires the flag --experimental-wasm-stack-switching in \"\n    \" versions of node <24.\"\n)\ndef send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if has_jspi():\n        return send_jspi_request(request, True)\n    elif is_in_node():\n        raise _RequestError(",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_SHOWN_TIMEOUT_WARNING",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "_SHOWN_TIMEOUT_WARNING = False\ndef _show_timeout_warning() -> None:\n    global _SHOWN_TIMEOUT_WARNING\n    if not _SHOWN_TIMEOUT_WARNING:\n        _SHOWN_TIMEOUT_WARNING = True\n        message = \"Warning: Timeout is not available on main browser thread\"\n        js.console.warn(message)\n_SHOWN_STREAMING_WARNING = False\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_SHOWN_STREAMING_WARNING",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "_SHOWN_STREAMING_WARNING = False\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING\n    if not _SHOWN_STREAMING_WARNING:\n        _SHOWN_STREAMING_WARNING = True\n        message = \"Can't stream HTTP requests because: \\n\"\n        if not is_cross_origin_isolated():\n            message += \"  Page is not cross-origin isolated\\n\"\n        if is_in_browser_main_thread():\n            message += \"  Python is running in main browser thread\\n\"",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "EmscriptenRequest",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.request",
        "description": ".build.functions.school.urllib3.contrib.emscripten.request",
        "peekOfCode": "class EmscriptenRequest:\n    method: str\n    url: str\n    params: dict[str, str] | None = None\n    body: _TYPE_BODY | None = None\n    headers: dict[str, str] = field(default_factory=dict)\n    timeout: float = 0\n    decode_content: bool = True\n    def set_header(self, name: str, value: str) -> None:\n        self.headers[name.capitalize()] = value",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.request",
        "documentation": {}
    },
    {
        "label": "EmscriptenResponse",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.response",
        "description": ".build.functions.school.urllib3.contrib.emscripten.response",
        "peekOfCode": "class EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "EmscriptenHttpResponseWrapper",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.response",
        "description": ".build.functions.school.urllib3.contrib.emscripten.response",
        "peekOfCode": "class EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,\n        connection: BaseHTTPConnection | BaseHTTPSConnection | None = None,\n    ):\n        self._pool = None  # set by pool class\n        self._body = None\n        self._response = internal_response",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.emscripten.response",
        "description": ".build.functions.school.urllib3.contrib.emscripten.response",
        "peekOfCode": "log = logging.getLogger(__name__)\n@dataclass\nclass EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,",
        "detail": ".build.functions.school.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "WrappedSocket",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "class WrappedSocket:\n    \"\"\"API-compatibility wrapper for Python OpenSSL's Connection-class.\"\"\"\n    def __init__(\n        self,\n        connection: OpenSSL.SSL.Connection,\n        socket: socket_cls,\n        suppress_ragged_eofs: bool = True,\n    ) -> None:\n        self.connection = connection\n        self.socket = socket",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "PyOpenSSLContext",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "class PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)\n        self._options = 0",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "inject_into_urllib3",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "def inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n    util.SSLContext = orig_util_SSLContext",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "extract_from_urllib3",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "def extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n    util.SSLContext = orig_util_SSLContext\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.IS_PYOPENSSL = False\n    util.ssl_.IS_PYOPENSSL = False\ndef _validate_dependencies_met() -> None:\n    \"\"\"\n    Verifies that PyOpenSSL's package-level dependencies have been met.\n    Throws `ImportError` if they are not met.",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "get_subj_alt_name",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "def get_subj_alt_name(peer_cert: X509) -> list[tuple[str, str]]:\n    \"\"\"\n    Given an PyOpenSSL certificate, provides all the subject alternative names.\n    \"\"\"\n    cert = peer_cert.to_cryptography()\n    # We want to find the SAN extension. Ask Cryptography to locate it (it's\n    # faster than looping in Python)\n    try:\n        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value\n    except x509.ExtensionNotFound:",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "__all__ = [\"inject_into_urllib3\", \"extract_from_urllib3\"]\n# Map from urllib3 to PyOpenSSL compatible parameter-values.\n_openssl_versions: dict[int, int] = {\n    util.ssl_.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    util.ssl_.PROTOCOL_TLS_CLIENT: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,\n}\nif hasattr(ssl, \"PROTOCOL_TLSv1_1\") and hasattr(OpenSSL.SSL, \"TLSv1_1_METHOD\"):\n    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD\nif hasattr(ssl, \"PROTOCOL_TLSv1_2\") and hasattr(OpenSSL.SSL, \"TLSv1_2_METHOD\"):",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_stdlib_to_openssl_verify",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "_stdlib_to_openssl_verify = {\n    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,\n    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,\n    ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER\n    + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,\n}\n_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_openssl_to_stdlib_verify",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(\n    OpenSSL.SSL, \"OP_NO_SSLv3\", 0\n)\n_OP_NO_TLSv1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1\", 0)\n_OP_NO_TLSv1_1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_1\", 0)\n_OP_NO_TLSv1_2: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_2\", 0)\n_OP_NO_TLSv1_3: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_3\", 0)",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "SSL_WRITE_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "SSL_WRITE_BLOCKSIZE = 16384\norig_util_SSLContext = util.ssl_.SSLContext\nlog = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "orig_util_SSLContext",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "orig_util_SSLContext = util.ssl_.SSLContext\nlog = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "WrappedSocket.makefile",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.contrib.pyopenssl",
        "description": ".build.functions.school.urllib3.contrib.pyopenssl",
        "peekOfCode": "WrappedSocket.makefile = socket_cls.makefile  # type: ignore[attr-defined]\nclass PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)",
        "detail": ".build.functions.school.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_TYPE_SOCKS_OPTIONS",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.socks",
        "description": ".build.functions.school.urllib3.contrib.socks",
        "peekOfCode": "class _TYPE_SOCKS_OPTIONS(typing.TypedDict):\n    socks_version: int\n    proxy_host: str | None\n    proxy_port: str | None\n    username: str | None\n    password: str | None\n    rdns: bool\nclass SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.",
        "detail": ".build.functions.school.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSConnection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.socks",
        "description": ".build.functions.school.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.\n    \"\"\"\n    def __init__(\n        self,\n        _socks_options: _TYPE_SOCKS_OPTIONS,\n        *args: typing.Any,\n        **kwargs: typing.Any,\n    ) -> None:",
        "detail": ".build.functions.school.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.socks",
        "description": ".build.functions.school.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection):\n    pass\nclass SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.",
        "detail": ".build.functions.school.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.socks",
        "description": ".build.functions.school.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {",
        "detail": ".build.functions.school.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPSConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.socks",
        "description": ".build.functions.school.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,",
        "detail": ".build.functions.school.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSProxyManager",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.contrib.socks",
        "description": ".build.functions.school.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,\n    }\n    def __init__(",
        "detail": ".build.functions.school.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "_LockedObject",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "class _LockedObject(typing.Generic[T]):\n    \"\"\"\n    A wrapper class that hides a specific object behind a lock.\n    The goal here is to provide a simple way to protect access to an object\n    that cannot safely be simultaneously accessed from multiple threads. The\n    intended use of this class is simple: take hold of it with a context\n    manager, which returns the protected object.\n    \"\"\"\n    __slots__ = (\n        \"lock\",",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "HTTP2Connection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "class HTTP2Connection(HTTPSConnection):\n    def __init__(\n        self, host: str, port: int | None = None, **kwargs: typing.Any\n    ) -> None:\n        self._h2_conn = self._new_h2_conn()\n        self._h2_stream: int | None = None\n        self._headers: list[tuple[bytes, bytes]] = []\n        if \"proxy\" in kwargs or \"proxy_config\" in kwargs:  # Defensive:\n            raise NotImplementedError(\"Proxies aren't supported with HTTP/2\")\n        super().__init__(host, port, **kwargs)",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "HTTP2Response",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "class HTTP2Response(BaseHTTPResponse):\n    # TODO: This is a woefully incomplete response object, but works for non-streaming.\n    def __init__(\n        self,\n        status: int,\n        headers: HTTPHeaderDict,\n        request_url: str,\n        data: bytes,\n        decode_content: bool = False,  # TODO: support decoding\n    ) -> None:",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "orig_HTTPSConnection",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "orig_HTTPSConnection = HTTPSConnection\nT = typing.TypeVar(\"T\")\nlog = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "T = typing.TypeVar(\"T\")\nlog = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "log = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "RE_IS_LEGAL_HEADER_NAME",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "RE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.\n    This does not allow for the `:` character in the header name, so should not",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "RE_IS_ILLEGAL_HEADER_VALUE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.connection",
        "description": ".build.functions.school.urllib3.http2.connection",
        "peekOfCode": "RE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.\n    This does not allow for the `:` character in the header name, so should not\n    be used to validate pseudo-headers.",
        "detail": ".build.functions.school.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "_HTTP2ProbeCache",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.http2.probe",
        "description": ".build.functions.school.urllib3.http2.probe",
        "peekOfCode": "class _HTTP2ProbeCache:\n    __slots__ = (\n        \"_lock\",\n        \"_cache_locks\",\n        \"_cache_values\",\n    )\n    def __init__(self) -> None:\n        self._lock = threading.Lock()\n        self._cache_locks: dict[tuple[str, int], threading.RLock] = {}\n        self._cache_values: dict[tuple[str, int], bool | None] = {}",
        "detail": ".build.functions.school.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_HTTP2_PROBE_CACHE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.probe",
        "description": ".build.functions.school.urllib3.http2.probe",
        "peekOfCode": "_HTTP2_PROBE_CACHE = _HTTP2ProbeCache()\nset_and_release = _HTTP2_PROBE_CACHE.set_and_release\nacquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.school.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "set_and_release",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.probe",
        "description": ".build.functions.school.urllib3.http2.probe",
        "peekOfCode": "set_and_release = _HTTP2_PROBE_CACHE.set_and_release\nacquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.school.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "acquire_and_get",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.probe",
        "description": ".build.functions.school.urllib3.http2.probe",
        "peekOfCode": "acquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.school.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_values",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.probe",
        "description": ".build.functions.school.urllib3.http2.probe",
        "peekOfCode": "_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.school.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_reset",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.probe",
        "description": ".build.functions.school.urllib3.http2.probe",
        "peekOfCode": "_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.school.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.http2.probe",
        "description": ".build.functions.school.urllib3.http2.probe",
        "peekOfCode": "__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.school.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "is_connection_dropped",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.connection",
        "description": ".build.functions.school.urllib3.util.connection",
        "peekOfCode": "def is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n# This function is copied from socket.py in the Python 2.7 standard\n# library test suite. Added to its signature is only `socket_options`.\n# One additional modification is that we avoid binding to IPv6 servers\n# discovered in DNS if the system doesn't have IPv6 functionality.",
        "detail": ".build.functions.school.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "create_connection",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.connection",
        "description": ".build.functions.school.urllib3.util.connection",
        "peekOfCode": "def create_connection(\n    address: tuple[str, int],\n    timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n    source_address: tuple[str, int] | None = None,\n    socket_options: _TYPE_SOCKET_OPTIONS | None = None,\n) -> socket.socket:\n    \"\"\"Connect to *address* and return the socket object.\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance",
        "detail": ".build.functions.school.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "allowed_gai_family",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.connection",
        "description": ".build.functions.school.urllib3.util.connection",
        "peekOfCode": "def allowed_gai_family() -> socket.AddressFamily:\n    \"\"\"This function is designed to work in the context of\n    getaddrinfo, where family=socket.AF_UNSPEC is the default and\n    will perform a DNS search for both IPv6 and IPv4 records.\"\"\"\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family\ndef _has_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"",
        "detail": ".build.functions.school.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "_TYPE_SOCKET_OPTIONS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.connection",
        "description": ".build.functions.school.urllib3.util.connection",
        "peekOfCode": "_TYPE_SOCKET_OPTIONS = list[tuple[int, int, typing.Union[int, bytes]]]\nif typing.TYPE_CHECKING:\n    from .._base_connection import BaseHTTPConnection\ndef is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n# This function is copied from socket.py in the Python 2.7 standard",
        "detail": ".build.functions.school.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "HAS_IPV6",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.connection",
        "description": ".build.functions.school.urllib3.util.connection",
        "peekOfCode": "HAS_IPV6 = _has_ipv6(\"::1\")",
        "detail": ".build.functions.school.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "connection_requires_http_tunnel",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.proxy",
        "description": ".build.functions.school.urllib3.util.proxy",
        "peekOfCode": "def connection_requires_http_tunnel(\n    proxy_url: Url | None = None,\n    proxy_config: ProxyConfig | None = None,\n    destination_scheme: str | None = None,\n) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:",
        "detail": ".build.functions.school.urllib3.util.proxy",
        "documentation": {}
    },
    {
        "label": "_TYPE_FAILEDTELL",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "class _TYPE_FAILEDTELL(Enum):\n    token = 0\n_FAILEDTELL: Final[_TYPE_FAILEDTELL] = _TYPE_FAILEDTELL.token\n_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "ChunksAndContentLength",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "class ChunksAndContentLength(typing.NamedTuple):\n    chunks: typing.Iterable[bytes] | None\n    content_length: int | None\ndef body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n    A 'Content-Length' of 'None' indicates the length of the body",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "make_headers",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "def make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"\n    Shortcuts for generating request headers.",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "set_file_position",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "def set_file_position(\n    body: typing.Any, pos: _TYPE_BODY_POSITION | None\n) -> _TYPE_BODY_POSITION | None:\n    \"\"\"\n    If a position is provided, move file to that point.\n    Otherwise, we'll attempt to record a position for future use.\n    \"\"\"\n    if pos is not None:\n        rewind_body(body, pos)\n    elif getattr(body, \"tell\", None) is not None:",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "rewind_body",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "def rewind_body(body: typing.IO[typing.AnyStr], body_pos: _TYPE_BODY_POSITION) -> None:\n    \"\"\"\n    Attempt to rewind body to a certain position.\n    Primarily used for request redirects and retries.\n    :param body:\n        File-like object that supports seek.\n    :param int pos:\n        Position to seek to in file.\n    \"\"\"\n    body_seek = getattr(body, \"seek\", None)",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "body_to_chunks",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "def body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n    A 'Content-Length' of 'None' indicates the length of the body\n    can't be determined so should use 'Transfer-Encoding: chunked'\n    for framing instead.\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "SKIP_HEADER",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "SKIP_HEADER = \"@@@SKIP_HEADER@@@\"\nSKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "SKIPPABLE_HEADERS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "SKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "ACCEPT_ENCODING",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "ACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:\n    ACCEPT_ENCODING += \",br\"",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "_TYPE_BODY_POSITION",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "_METHODS_NOT_EXPECTING_BODY",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.request",
        "description": ".build.functions.school.urllib3.util.request",
        "peekOfCode": "_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "is_fp_closed",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.response",
        "description": ".build.functions.school.urllib3.util.response",
        "peekOfCode": "def is_fp_closed(obj: object) -> bool:\n    \"\"\"\n    Checks whether a given file-like object is closed.\n    :param obj:\n        The file-like object to check.\n    \"\"\"\n    try:\n        # Check `isclosed()` first, in case Python3 doesn't set `closed`.\n        # GH Issue #928\n        return obj.isclosed()  # type: ignore[no-any-return, attr-defined]",
        "detail": ".build.functions.school.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "assert_header_parsing",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.response",
        "description": ".build.functions.school.urllib3.util.response",
        "peekOfCode": "def assert_header_parsing(headers: httplib.HTTPMessage) -> None:\n    \"\"\"\n    Asserts whether all headers have been successfully parsed.\n    Extracts encountered errors from the result of parsing headers.\n    Only works on Python 3.\n    :param http.client.HTTPMessage headers: Headers to verify.\n    :raises urllib3.exceptions.HeaderParsingError:\n        If parsing errors are found.\n    \"\"\"\n    # This will fail silently if we pass in the wrong kind of parameter.",
        "detail": ".build.functions.school.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "is_response_to_head",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.response",
        "description": ".build.functions.school.urllib3.util.response",
        "peekOfCode": "def is_response_to_head(response: httplib.HTTPResponse) -> bool:\n    \"\"\"\n    Checks whether the request of a response has been a HEAD-request.\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    \"\"\"\n    # FIXME: Can we do this somehow without accessing private httplib _method?\n    method_str = response._method  # type: str  # type: ignore[attr-defined]\n    return method_str.upper() == \"HEAD\"",
        "detail": ".build.functions.school.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "RequestHistory",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.retry",
        "description": ".build.functions.school.urllib3.util.retry",
        "peekOfCode": "class RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\nclass Retry:\n    \"\"\"Retry configuration.\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.",
        "detail": ".build.functions.school.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.retry",
        "description": ".build.functions.school.urllib3.util.retry",
        "peekOfCode": "class Retry:\n    \"\"\"Retry configuration.\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n    Retries can be defined as a default for a pool:\n    .. code-block:: python\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request(\"GET\", \"https://example.com/\")\n    Or per-request (which overrides the default for the pool):",
        "detail": ".build.functions.school.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.retry",
        "description": ".build.functions.school.urllib3.util.retry",
        "peekOfCode": "log = logging.getLogger(__name__)\n# Data structure for representing the metadata of requests that result in a retry.\nclass RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\nclass Retry:\n    \"\"\"Retry configuration.",
        "detail": ".build.functions.school.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry.DEFAULT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.retry",
        "description": ".build.functions.school.urllib3.util.retry",
        "peekOfCode": "Retry.DEFAULT = Retry(3)",
        "detail": ".build.functions.school.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "assert_fingerprint",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n    if cert is None:\n        raise SSLError(\"No certificate for the peer.\")",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "resolve_cert_reqs",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def resolve_cert_reqs(candidate: None | int | str) -> VerifyMode:\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "resolve_ssl_version",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def resolve_ssl_version(candidate: None | int | str) -> int:\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "create_urllib3_context",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def create_urllib3_context(\n    ssl_version: int | None = None,\n    cert_reqs: int | None = None,\n    options: int | None = None,\n    ciphers: str | None = None,\n    ssl_minimum_version: int | None = None,\n    ssl_maximum_version: int | None = None,\n    verify_flags: int | None = None,\n) -> ssl.SSLContext:\n    \"\"\"Creates and configures an :class:`ssl.SSLContext` instance for use with urllib3.",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = None,\n    certfile: str | None = None,\n    cert_reqs: int | None = None,\n    ca_certs: str | None = None,\n    server_hostname: str | None = None,\n    ssl_version: int | None = None,\n    ciphers: str | None = None,\n    ssl_context: ssl.SSLContext | None = None,",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "is_ipaddress",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "def is_ipaddress(hostname: str | bytes) -> bool:\n    \"\"\"Detects whether the hostname given is an IPv4 or IPv6 address.\n    Also detects IPv6 addresses with Zone IDs.\n    :param str hostname: Hostname to examine.\n    :return: True if the hostname is an IP address, False otherwise.\n    \"\"\"\n    if isinstance(hostname, bytes):\n        # IDN A-label bytes are ASCII compatible.\n        hostname = hostname.decode(\"ascii\")\n    return bool(_IPV4_RE.match(hostname) or _BRACELESS_IPV6_ADDRZ_RE.match(hostname))",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "SSLContext",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "SSLContext = None\nSSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "SSLTransport",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "SSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "HAS_NEVER_CHECK_COMMON_NAME",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "HAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "IS_PYOPENSSL",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "IS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ALPN_PROTOCOLS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "ALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "_TYPE_VERSION_INFO",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "HASHFUNC_MAP",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "HASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,\n) -> bool:\n    \"\"\"Return True for CPython 3.9.3+ or 3.10+ and PyPy 7.3.8+ where",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "_TYPE_PEER_CERT_RET",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_",
        "description": ".build.functions.school.urllib3.util.ssl_",
        "peekOfCode": "_TYPE_PEER_CERT_RET = typing.Union[\"_TYPE_PEER_CERT_RET_DICT\", bytes, None]\ndef assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n    if cert is None:",
        "detail": ".build.functions.school.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "CertificateError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "peekOfCode": "class CertificateError(ValueError):\n    pass\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:",
        "detail": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "match_hostname",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "peekOfCode": "def match_hostname(\n    cert: _TYPE_PEER_CERT_RET_DICT | None,\n    hostname: str,\n    hostname_checks_common_name: bool = False,\n) -> None:\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n    CertificateError is raised on failure. On success, the function\n    returns nothing.",
        "detail": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "peekOfCode": "__version__ = \"3.5.0.1\"\nclass CertificateError(ValueError):\n    pass\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []",
        "detail": ".build.functions.school.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "SSLTransport",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.ssltransport",
        "description": ".build.functions.school.urllib3.util.ssltransport",
        "peekOfCode": "class SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"\n    @staticmethod\n    def _validate_ssl_context_for_tls_in_tls(ssl_context: ssl.SSLContext) -> None:",
        "detail": ".build.functions.school.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_WriteBuffer",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssltransport",
        "description": ".build.functions.school.urllib3.util.ssltransport",
        "peekOfCode": "_WriteBuffer = typing.Union[bytearray, memoryview]\n_ReturnValue = typing.TypeVar(\"_ReturnValue\")\nSSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.",
        "detail": ".build.functions.school.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_ReturnValue",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssltransport",
        "description": ".build.functions.school.urllib3.util.ssltransport",
        "peekOfCode": "_ReturnValue = typing.TypeVar(\"_ReturnValue\")\nSSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "SSL_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.ssltransport",
        "description": ".build.functions.school.urllib3.util.ssltransport",
        "peekOfCode": "SSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"\n    @staticmethod",
        "detail": ".build.functions.school.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_TYPE_DEFAULT",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.timeout",
        "description": ".build.functions.school.urllib3.util.timeout",
        "peekOfCode": "class _TYPE_DEFAULT(Enum):\n    # This value should never be passed to socket.settimeout() so for safety we use a -1.\n    # socket.settimout() raises a ValueError for negative values.\n    token = -1\n_DEFAULT_TIMEOUT: Final[_TYPE_DEFAULT] = _TYPE_DEFAULT.token\n_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\nclass Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python",
        "detail": ".build.functions.school.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.timeout",
        "description": ".build.functions.school.urllib3.util.timeout",
        "peekOfCode": "class Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python\n        import urllib3\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n        http = urllib3.PoolManager(timeout=timeout)\n        resp = http.request(\"GET\", \"https://example.com/\")\n        print(resp.status)\n    Or per-request (which overrides the default for the pool):",
        "detail": ".build.functions.school.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "_TYPE_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.timeout",
        "description": ".build.functions.school.urllib3.util.timeout",
        "peekOfCode": "_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\nclass Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python\n        import urllib3\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n        http = urllib3.PoolManager(timeout=timeout)\n        resp = http.request(\"GET\", \"https://example.com/\")\n        print(resp.status)",
        "detail": ".build.functions.school.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "Url",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "class Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),\n            (\"query\", typing.Optional[str]),",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "def parse_url(url: str) -> Url:\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 and RFC 6874 compliant.\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n    Partly backwards-compatible with :mod:`urllib.parse`.\n    Example:",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_NORMALIZABLE_SCHEMES",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_NORMALIZABLE_SCHEMES = (\"http\", \"https\", None)\n# Almost all of these patterns were derived from the\n# 'rfc3986' module: https://github.com/python-hyper/rfc3986\n_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_PERCENT_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_SCHEME_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_URI_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV4_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HEX_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_LS32_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_subs",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_variations",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",\n    # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_UNRESERVED_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\\-~\"\n_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_ZONE_ID_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_ADDRZ_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_REG_NAME_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_TARGET_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV4_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_ADDRZ_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_BRACELESS_IPV6_ADDRZ_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_ZONE_ID_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HOST_PORT_PAT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HOST_PORT_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_UNRESERVED_CHARS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_SUB_DELIM_CHARS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_USERINFO_CHARS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_PATH_CHARS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_QUERY_CHARS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.url",
        "description": ".build.functions.school.urllib3.util.url",
        "peekOfCode": "_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),",
        "detail": ".build.functions.school.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.util",
        "description": ".build.functions.school.urllib3.util.util",
        "peekOfCode": "def to_bytes(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> bytes:\n    if isinstance(x, bytes):\n        return x\n    elif not isinstance(x, str):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.encode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.encode()",
        "detail": ".build.functions.school.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "to_str",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.util",
        "description": ".build.functions.school.urllib3.util.util",
        "peekOfCode": "def to_str(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> str:\n    if isinstance(x, str):\n        return x\n    elif not isinstance(x, bytes):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.decode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.decode()",
        "detail": ".build.functions.school.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "reraise",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.util",
        "description": ".build.functions.school.urllib3.util.util",
        "peekOfCode": "def reraise(\n    tp: type[BaseException] | None,\n    value: BaseException,\n    tb: TracebackType | None = None,\n) -> typing.NoReturn:\n    try:\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:",
        "detail": ".build.functions.school.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "select_wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.wait",
        "description": ".build.functions.school.urllib3.util.wait",
        "peekOfCode": "def select_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    rcheck = []\n    wcheck = []",
        "detail": ".build.functions.school.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "poll_wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.wait",
        "description": ".build.functions.school.urllib3.util.wait",
        "peekOfCode": "def poll_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    mask = 0\n    if read:",
        "detail": ".build.functions.school.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.wait",
        "description": ".build.functions.school.urllib3.util.wait",
        "peekOfCode": "def wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    # We delay choosing which implementation to use until the first time we're\n    # called. We could do it at import time, but then we might make the wrong\n    # decision if someone goes wild with monkeypatching select.poll after\n    # we're imported.",
        "detail": ".build.functions.school.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_read",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.wait",
        "description": ".build.functions.school.urllib3.util.wait",
        "peekOfCode": "def wait_for_read(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for reading to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, read=True, timeout=timeout)\ndef wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)",
        "detail": ".build.functions.school.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_write",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.util.wait",
        "description": ".build.functions.school.urllib3.util.wait",
        "peekOfCode": "def wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)",
        "detail": ".build.functions.school.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.util.wait",
        "description": ".build.functions.school.urllib3.util.wait",
        "peekOfCode": "__all__ = [\"wait_for_read\", \"wait_for_write\"]\n# How should we wait on sockets?\n#\n# There are two types of APIs you can use for waiting on sockets: the fancy\n# modern stateful APIs like epoll/kqueue, and the older stateless APIs like\n# select/poll. The stateful APIs are more efficient when you have a lots of\n# sockets to keep track of, because you can set them up once and then use them\n# lots of times. But we only ever want to wait on a single socket at a time\n# and don't want to keep track of state, so the stateless APIs are actually\n# more efficient. So we want to use select() or poll().",
        "detail": ".build.functions.school.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "ProxyConfig",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3._base_connection",
        "description": ".build.functions.school.urllib3._base_connection",
        "peekOfCode": "class ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str",
        "detail": ".build.functions.school.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_ResponseOptions",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3._base_connection",
        "description": ".build.functions.school.urllib3._base_connection",
        "peekOfCode": "class _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str\n    preload_content: bool\n    decode_content: bool\n    enforce_content_length: bool\nif typing.TYPE_CHECKING:\n    import ssl",
        "detail": ".build.functions.school.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_TYPE_BODY",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._base_connection",
        "description": ".build.functions.school.urllib3._base_connection",
        "peekOfCode": "_TYPE_BODY = typing.Union[bytes, typing.IO[typing.Any], typing.Iterable[bytes], str]\nclass ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str",
        "detail": ".build.functions.school.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_Sentinel",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "class _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "RecentlyUsedContainer",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "class RecentlyUsedContainer(typing.Generic[_KT, _VT], typing.MutableMapping[_KT, _VT]):\n    \"\"\"\n    Provides a thread-safe dict-like container which maintains up to\n    ``maxsize`` keys while throwing away the least-recently-used keys beyond\n    ``maxsize``.\n    :param maxsize:\n        Maximum number of recent elements to retain.\n    :param dispose_func:\n        Every time an item is evicted from the container,\n        ``dispose_func(value)`` is called.  Callback which will get called",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "HTTPHeaderDictItemView",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "class HTTPHeaderDictItemView(set[tuple[str, str]]):\n    \"\"\"\n    HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of\n    address.\n    If we directly try to get an item with a particular name, we will get a string\n    back that is the concatenated version of all the values:\n    >>> d['X-Header-Name']\n    'Value1, Value2, Value3'\n    However, if we iterate over an HTTPHeaderDict's items, we will optionally combine\n    these values based on whether combine=True was called when building up the dictionary",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "HTTPHeaderDict",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "class HTTPHeaderDict(typing.MutableMapping[str, str]):\n    \"\"\"\n    :param headers:\n        An iterable of field-value pairs. Must not contain multiple field names\n        when compared case-insensitively.\n    :param kwargs:\n        Additional field-value pairs to pass in to ``dict.update``.\n    A ``dict`` like container for storing HTTP Headers.\n    Field names are stored and compared case-insensitively in compliance with\n    RFC 7230. Iteration provides the first case-sensitive key seen for each",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "ensure_can_construct_http_header_dict",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "def ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.\n        return typing.cast(typing.Mapping[str, str], potential)\n    elif isinstance(potential, typing.Iterable):",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "__all__ = [\"RecentlyUsedContainer\", \"HTTPHeaderDict\"]\n# Key type\n_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_KT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_VT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_DT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "ValidHTTPHeaderSource",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._collections",
        "description": ".build.functions.school.urllib3._collections",
        "peekOfCode": "ValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(\n    potential: object,",
        "detail": ".build.functions.school.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "RequestMethods",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3._request_methods",
        "description": ".build.functions.school.urllib3._request_methods",
        "peekOfCode": "class RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n    Provides behavior for making common types of HTTP request methods and\n    decides which type of request field encoding to use.\n    Specifically,\n    :meth:`.request_encode_url` is for sending requests whose fields are\n    encoded in the URL (such as GET, HEAD, DELETE).",
        "detail": ".build.functions.school.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._request_methods",
        "description": ".build.functions.school.urllib3._request_methods",
        "peekOfCode": "__all__ = [\"RequestMethods\"]\n_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.",
        "detail": ".build.functions.school.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "_TYPE_ENCODE_URL_FIELDS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._request_methods",
        "description": ".build.functions.school.urllib3._request_methods",
        "peekOfCode": "_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n    Provides behavior for making common types of HTTP request methods and",
        "detail": ".build.functions.school.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._version",
        "description": ".build.functions.school.urllib3._version",
        "peekOfCode": "__all__ = [\n    \"__version__\",\n    \"__version_tuple__\",\n    \"version\",\n    \"version_tuple\",\n    \"__commit_id__\",\n    \"commit_id\",\n]\nTYPE_CHECKING = False\nif TYPE_CHECKING:",
        "detail": ".build.functions.school.urllib3._version",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._version",
        "description": ".build.functions.school.urllib3._version",
        "peekOfCode": "TYPE_CHECKING = False\nif TYPE_CHECKING:\n    from typing import Tuple\n    from typing import Union\n    VERSION_TUPLE = Tuple[Union[int, str], ...]\n    COMMIT_ID = Union[str, None]\nelse:\n    VERSION_TUPLE = object\n    COMMIT_ID = object\nversion: str",
        "detail": ".build.functions.school.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._version",
        "description": ".build.functions.school.urllib3._version",
        "peekOfCode": "__version__ = version = '2.6.3'\n__version_tuple__ = version_tuple = (2, 6, 3)\n__commit_id__ = commit_id = None",
        "detail": ".build.functions.school.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._version",
        "description": ".build.functions.school.urllib3._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (2, 6, 3)\n__commit_id__ = commit_id = None",
        "detail": ".build.functions.school.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__commit_id__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3._version",
        "description": ".build.functions.school.urllib3._version",
        "peekOfCode": "__commit_id__ = commit_id = None",
        "detail": ".build.functions.school.urllib3._version",
        "documentation": {}
    },
    {
        "label": "HTTPConnection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "class HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling\n      Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "HTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "class HTTPSConnection(HTTPConnection):\n    \"\"\"\n    Many of the parameters to this constructor are passed to the underlying SSL\n    socket by means of :py:func:`urllib3.util.ssl_wrap_socket`.\n    \"\"\"\n    default_port = port_by_scheme[\"https\"]  # type: ignore[misc]\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "_WrappedAndVerifiedSocket",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "class _WrappedAndVerifiedSocket(typing.NamedTuple):\n    \"\"\"\n    Wrapped socket and whether the connection is\n    verified after the TLS handshake\n    \"\"\"\n    socket: ssl.SSLSocket | SSLTransport\n    is_verified: bool\ndef _ssl_wrap_socket_and_match_hostname(\n    sock: socket.socket,\n    *,",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "DummyConnection",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "class DummyConnection:\n    \"\"\"Used to detect a failed ConnectionCls import.\"\"\"\nif not ssl:\n    HTTPSConnection = DummyConnection  # type: ignore[misc, assignment] # noqa: F811\nVerifiedHTTPSConnection = HTTPSConnection\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "ConnectionError = ConnectionError\nBrokenPipeError = BrokenPipeError\nlog = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "BrokenPipeError",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "BrokenPipeError = BrokenPipeError\nlog = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "log = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "port_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "port_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "RECENT_DATE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "RECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "_CONTAINS_CONTROL_CHAR_RE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "VerifiedHTTPSConnection",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connection",
        "description": ".build.functions.school.urllib3.connection",
        "peekOfCode": "VerifiedHTTPSConnection = HTTPSConnection\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"\n    return Url(scheme=scheme, host=conn.host, port=conn.port, path=path).url",
        "detail": ".build.functions.school.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.connectionpool",
        "description": ".build.functions.school.urllib3.connectionpool",
        "peekOfCode": "class ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.\n    \"\"\"\n    scheme: str | None = None",
        "detail": ".build.functions.school.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.connectionpool",
        "description": ".build.functions.school.urllib3.connectionpool",
        "peekOfCode": "class HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n    :param timeout:",
        "detail": ".build.functions.school.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPSConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.connectionpool",
        "description": ".build.functions.school.urllib3.connectionpool",
        "peekOfCode": "class HTTPSConnectionPool(HTTPConnectionPool):\n    \"\"\"\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.",
        "detail": ".build.functions.school.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "connection_from_url",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.connectionpool",
        "description": ".build.functions.school.urllib3.connectionpool",
        "peekOfCode": "def connection_from_url(url: str, **kw: typing.Any) -> HTTPConnectionPool:\n    \"\"\"\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n    :param \\\\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like",
        "detail": ".build.functions.school.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connectionpool",
        "description": ".build.functions.school.urllib3.connectionpool",
        "peekOfCode": "log = logging.getLogger(__name__)\n_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded",
        "detail": ".build.functions.school.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "_TYPE_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connectionpool",
        "description": ".build.functions.school.urllib3.connectionpool",
        "peekOfCode": "_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.",
        "detail": ".build.functions.school.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "_blocking_errnos",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.connectionpool",
        "description": ".build.functions.school.urllib3.connectionpool",
        "peekOfCode": "_blocking_errnos = {errno.EAGAIN, errno.EWOULDBLOCK}\nclass HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.",
        "detail": ".build.functions.school.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class HTTPError(Exception):\n    \"\"\"Base exception used by this module.\"\"\"\nclass HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPWarning",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "PoolError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)\nclass RequestError(PoolError):",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class RequestError(PoolError):\n    \"\"\"Base exception for PoolErrors that have associated URLs.\"\"\"\n    def __init__(self, pool: ConnectionPool, url: str | None, message: str) -> None:\n        self.url = url\n        super().__init__(pool, message)\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self.url, self._message)\nclass SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"\nclass ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n    # The original error is also available as __cause__.\n    original_error: Exception\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\nclass DecodeError(HTTPError):",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n    # The original error is also available as __cause__.\n    original_error: Exception\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\nclass DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\nclass ProtocolError(HTTPError):",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DecodeError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\nclass ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "MaxRetryError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n    \"\"\"\n    def __init__(\n        self, pool: ConnectionPool, url: str | None, reason: Exception | None = None",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HostChangedError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class HostChangedError(RequestError):\n    \"\"\"Raised when an existing pool gets a request for a foreign host.\"\"\"\n    def __init__(\n        self, pool: ConnectionPool, url: str, retries: Retry | int = 3\n    ) -> None:\n        message = f\"Tried to open a foreign host with url: {url}\"\n        super().__init__(pool, url, message)\n        self.retries = retries\nclass TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutStateError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"\nclass TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeoutError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        self._message = message\n        super().__init__(f\"{conn}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NewConnectionError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        self._message = message\n        super().__init__(f\"{conn}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)\n    @property",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NameResolutionError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class NameResolutionError(NewConnectionError):\n    \"\"\"Raised when host name resolution fails.\"\"\"\n    def __init__(self, host: str, conn: HTTPConnection, reason: socket.gaierror):\n        message = f\"Failed to resolve '{host}' ({reason})\"\n        self._host = host\n        self._reason = reason\n        super().__init__(conn, message)\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (self._host, None, self._reason)",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyPoolError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class EmptyPoolError(PoolError):\n    \"\"\"Raised when a pool runs out of connections and no more are allowed.\"\"\"\nclass FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "FullPoolError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ClosedPoolError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationValueError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "URLSchemeUnknown",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"\n        super().__init__(message)\n        self.scheme = scheme\nclass ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"\nclass SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SecurityWarning",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InsecureRequestWarning",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NotOpenSSLWarning",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SystemTimeWarning",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InsecurePlatformWarning",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DependencyWarning",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseNotChunked",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "BodyNotHttplibCompatible",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "IncompleteRead",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.\n    \"\"\"\n    partial: int  # type: ignore[assignment]\n    expected: int\n    def __init__(self, partial: int, expected: int) -> None:\n        self.partial = partial",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidChunkLength",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class InvalidChunkLength(HTTPError, httplib_IncompleteRead):\n    \"\"\"Invalid chunk length in a chunked response.\"\"\"\n    def __init__(self, response: HTTPResponse, length: bytes) -> None:\n        self.partial: int = response.tell()  # type: ignore[assignment]\n        self.expected: int | None = response.length_remaining\n        self.response = response\n        self.length = length\n    def __repr__(self) -> str:\n        return \"InvalidChunkLength(got length %r, %i bytes read)\" % (\n            self.length,",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class InvalidHeader(HTTPError):\n    \"\"\"The header provided was somehow invalid.\"\"\"\nclass ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxySchemeUnknown",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None\n        if scheme is None:\n            message = \"Proxy URL had no scheme, should start with http:// or https://\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxySchemeUnsupported",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class ProxySchemeUnsupported(ValueError):\n    \"\"\"Fetching HTTPS resources through HTTPS proxies is unsupported\"\"\"\nclass HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\nclass UnrewindableBodyError(HTTPError):",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HeaderParsingError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\nclass UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "UnrewindableBodyError",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "class UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "_TYPE_REDUCE_RESULT",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.exceptions",
        "description": ".build.functions.school.urllib3.exceptions",
        "peekOfCode": "ConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestField",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "class RequestField:\n    \"\"\"\n    A data container for request body parameters.\n    :param name:\n        The name of this request field. Must be unicode.\n    :param data:\n        The data/value body.\n    :param filename:\n        An optional filename of the request field. Must be unicode.\n    :param headers:",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "guess_content_type",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "def guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.\n    :param filename:\n        The filename to guess the \"Content-Type\" of using :mod:`mimetypes`.\n    :param default:\n        If no \"Content-Type\" can be guessed, default to `default`.\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param_rfc2231",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "def format_header_param_rfc2231(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Helper function to format and quote a single header parameter using the\n    strategy defined in RFC 2231.\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows\n    `RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_multipart_header_param",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "def format_multipart_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Format and quote a single multipart header parameter.\n    This follows the `WHATWG HTML Standard`_ as of 2021/06/10, matching\n    the behavior of current browser and curl versions. Values are\n    assumed to be UTF-8. The ``\\\\n``, ``\\\\r``, and ``\"`` characters are\n    percent encoded.\n    .. _WHATWG HTML Standard:\n        https://html.spec.whatwg.org/multipage/\n        form-control-infrastructure.html#multipart-form-data",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param_html5",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "def format_header_param_html5(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n    warnings.warn(\n        \"'format_header_param_html5' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "def format_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n    warnings.warn(\n        \"'format_header_param' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELD_VALUE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "_TYPE_FIELD_VALUE = typing.Union[str, bytes]\n_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    tuple[str, _TYPE_FIELD_VALUE],\n    tuple[str, _TYPE_FIELD_VALUE, str],\n]\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELD_VALUE_TUPLE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.fields",
        "description": ".build.functions.school.urllib3.fields",
        "peekOfCode": "_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    tuple[str, _TYPE_FIELD_VALUE],\n    tuple[str, _TYPE_FIELD_VALUE, str],\n]\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.",
        "detail": ".build.functions.school.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "choose_boundary",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.filepost",
        "description": ".build.functions.school.urllib3.filepost",
        "peekOfCode": "def choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.",
        "detail": ".build.functions.school.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "iter_field_objects",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.filepost",
        "description": ".build.functions.school.urllib3.filepost",
        "peekOfCode": "def iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.\n    \"\"\"\n    iterable: typing.Iterable[RequestField | tuple[str, _TYPE_FIELD_VALUE_TUPLE]]\n    if isinstance(fields, typing.Mapping):\n        iterable = fields.items()\n    else:",
        "detail": ".build.functions.school.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "encode_multipart_formdata",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.filepost",
        "description": ".build.functions.school.urllib3.filepost",
        "peekOfCode": "def encode_multipart_formdata(\n    fields: _TYPE_FIELDS, boundary: str | None = None\n) -> tuple[bytes, str]:\n    \"\"\"\n    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n    :param fields:\n        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n        Values are processed by :func:`urllib3.fields.RequestField.from_tuples`.\n    :param boundary:\n        If not specified, then a random boundary will be generated using",
        "detail": ".build.functions.school.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "writer",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.filepost",
        "description": ".build.functions.school.urllib3.filepost",
        "peekOfCode": "writer = codecs.lookup(\"utf-8\")[3]\n_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"",
        "detail": ".build.functions.school.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELDS_SEQUENCE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.filepost",
        "description": ".build.functions.school.urllib3.filepost",
        "peekOfCode": "_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.",
        "detail": ".build.functions.school.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELDS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.filepost",
        "description": ".build.functions.school.urllib3.filepost",
        "peekOfCode": "_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:",
        "detail": ".build.functions.school.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "PoolKey",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "class PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n    key_scheme: str\n    key_host: str\n    key_port: int | None\n    key_timeout: Timeout | float | int | None",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "PoolManager",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "class PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "ProxyManager",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "class ProxyManager(PoolManager):\n    \"\"\"\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n    :param proxy_url:\n        The URL of the proxy to be used.\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "proxy_from_url",
        "kind": 2,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "def proxy_from_url(url: str, **kw: typing.Any) -> ProxyManager:\n    return ProxyManager(proxy_url=url, **kw)",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "__all__ = [\"PoolManager\", \"ProxyManager\", \"proxy_from_url\"]\nlog = logging.getLogger(__name__)\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "log = logging.getLogger(__name__)\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "SSL_KEYWORDS",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "SSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",\n    \"ca_cert_dir\",",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "_DEFAULT_BLOCKSIZE = 16384\nclass PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n    key_scheme: str\n    key_host: str\n    key_port: int | None",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "key_fn_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "key_fn_by_scheme = {\n    \"http\": functools.partial(_default_key_normalizer, PoolKey),\n    \"https\": functools.partial(_default_key_normalizer, PoolKey),\n}\npool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "pool_classes_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.poolmanager",
        "description": ".build.functions.school.urllib3.poolmanager",
        "peekOfCode": "pool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n    :param headers:\n        Headers to include with all requests, unless other headers are given",
        "detail": ".build.functions.school.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "ContentDecoder",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class ContentDecoder:\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        raise NotImplementedError()\n    @property\n    def has_unconsumed_tail(self) -> bool:\n        raise NotImplementedError()\n    def flush(self) -> bytes:\n        raise NotImplementedError()\nclass DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "DeflateDecoder",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._first_try = True\n        self._first_try_data = b\"\"\n        self._unfed_data = b\"\"\n        self._obj = zlib.decompressobj()\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        data = self._unfed_data + data\n        self._unfed_data = b\"\"\n        if not data and not self._obj.unconsumed_tail:",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "GzipDecoderState",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class GzipDecoderState:\n    FIRST_MEMBER = 0\n    OTHER_MEMBERS = 1\n    SWALLOW_DATA = 2\nclass GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n        self._unconsumed_tail = b\"\"\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "GzipDecoder",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n        self._unconsumed_tail = b\"\"\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        ret = bytearray()\n        if self._state == GzipDecoderState.SWALLOW_DATA:\n            return bytes(ret)\n        if max_length == 0:",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "MultiDecoder",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class MultiDecoder(ContentDecoder):\n    \"\"\"\n    From RFC7231:\n        If one or more encodings have been applied to a representation, the\n        sender that applied the encodings MUST generate a Content-Encoding\n        header field that lists the content codings in the order in which\n        they were applied.\n    \"\"\"\n    # Maximum allowed number of chained HTTP encodings in the\n    # Content-Encoding header.",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "BytesQueueBuffer",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class BytesQueueBuffer:\n    \"\"\"Memory-efficient bytes buffer\n    To return decoded data in read() and still follow the BufferedIOBase API, we need a\n    buffer to always return the correct amount of bytes.\n    This buffer should be filled using calls to put()\n    Our maximum memory usage is determined by the sum of the size of:\n     * self.buffer, which contains the full data\n     * the largest chunk that we will copy in get()\n    \"\"\"\n    def __init__(self) -> None:",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "BaseHTTPResponse",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class BaseHTTPResponse(io.IOBase):\n    CONTENT_DECODERS = [\"gzip\", \"x-gzip\", \"deflate\"]\n    if brotli is not None:\n        CONTENT_DECODERS += [\"br\"]\n    if HAS_ZSTD:\n        CONTENT_DECODERS += [\"zstd\"]\n    REDIRECT_STATUSES = [301, 302, 303, 307, 308]\n    DECODER_ERROR_CLASSES: tuple[type[Exception], ...] = (IOError, zlib.error)\n    if brotli is not None:\n        DECODER_ERROR_CLASSES += (brotli.error,)",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "HTTPResponse",
        "kind": 6,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "class HTTPResponse(BaseHTTPResponse):\n    \"\"\"\n    HTTP Response container.\n    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\n    loaded and decoded on-demand when the ``data`` property is accessed.  This\n    class is also compatible with the Python standard library's :mod:`io`\n    module, and can hence be treated as a readable object in the context of that\n    framework.\n    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n    :param preload_content:",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.school.urllib3.response",
        "description": ".build.functions.school.urllib3.response",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass ContentDecoder:\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        raise NotImplementedError()\n    @property\n    def has_unconsumed_tail(self) -> bool:\n        raise NotImplementedError()\n    def flush(self) -> bytes:\n        raise NotImplementedError()\nclass DeflateDecoder(ContentDecoder):",
        "detail": ".build.functions.school.urllib3.response",
        "documentation": {}
    },
    {
        "label": "ICatalystCacheResp",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.cache._segment",
        "description": ".build.functions.school.zcatalyst_sdk.cache._segment",
        "peekOfCode": "class ICatalystCacheResp(ICatalystCache):\n    project_details: Optional[ICatalystProject]\nclass Segment(ParsableComponent):\n    def __init__(self, cache_instance, segment_details: Dict):\n        if segment_details:\n            validator.is_non_empty_dict(segment_details, 'segment_details', CatalystCacheError)\n        self._requester: AuthorizedHttpClient = cache_instance._requester\n        self._id = segment_details.get('id') if segment_details else None\n        self._segment_details = segment_details\n    def __repr__(self) -> str:",
        "detail": ".build.functions.school.zcatalyst_sdk.cache._segment",
        "documentation": {}
    },
    {
        "label": "Segment",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.cache._segment",
        "description": ".build.functions.school.zcatalyst_sdk.cache._segment",
        "peekOfCode": "class Segment(ParsableComponent):\n    def __init__(self, cache_instance, segment_details: Dict):\n        if segment_details:\n            validator.is_non_empty_dict(segment_details, 'segment_details', CatalystCacheError)\n        self._requester: AuthorizedHttpClient = cache_instance._requester\n        self._id = segment_details.get('id') if segment_details else None\n        self._segment_details = segment_details\n    def __repr__(self) -> str:\n        return str(self.to_dict())\n    def get_component_name(self):",
        "detail": ".build.functions.school.zcatalyst_sdk.cache._segment",
        "documentation": {}
    },
    {
        "label": "Connector",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.connection._connector",
        "description": ".build.functions.school.zcatalyst_sdk.connection._connector",
        "peekOfCode": "class Connector:\n    def __init__(self, connection_instance, connector_details: Dict[str, str]) -> None:\n        self._app = connection_instance._app\n        self._requester: HttpClient = connection_instance._requester\n        self.connector_name = connector_details.get(CONNECTOR_NAME)\n        self.auth_url = connector_details.get(AUTH_URL)\n        self.refresh_url = connector_details.get(REFRESH_URL)\n        self.refresh_token = connector_details.get(REFRESH_TOKEN)\n        self.client_id = connector_details.get(CLIENT_ID)\n        self.client_secret = connector_details.get(CLIENT_SECRET)",
        "detail": ".build.functions.school.zcatalyst_sdk.connection._connector",
        "documentation": {}
    },
    {
        "label": "BulkJob",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkJob(Component, ABC):\n    def __init__(self, table_instance, operation: str):\n        self._requester: AuthorizedHttpClient = table_instance._requester\n        self._identifier = table_instance._identifier\n        self._operation = operation\n    def get_component_name(self):\n        return Components.DATA_STORE\n    def get_status(self, job_id: Union[str, int]) -> ICatalystBulkJob:\n        validator.is_non_empty_string_or_number(job_id, 'job_id', CatalystDatastoreError)\n        resp = self._requester.request(",
        "detail": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "BulkRead",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkRead(BulkJob):\n    def __init__(self, table_instance):\n        super().__init__(table_instance, 'read')\n    def create_job(\n        self,\n        query: ICatalystBulkReadQuery = None,\n        callback: ICatalystBulkCallback = None\n    ) -> ICatalystBulkJob:\n        resp = self._requester.request(\n            method=RequestMethod.POST,",
        "detail": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "BulkWrite",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkWrite(BulkJob):\n    def __init__(self, table_instance):\n        super().__init__(table_instance, 'write')\n    def create_job(\n        self,\n        file_details: Union[CatalystBucketObject, str],\n        options: ICatalystBulkWriteInput = None,\n        callback: ICatalystBulkCallback = None\n    ) -> ICatalystBulkJob:\n        if options:",
        "detail": ".build.functions.school.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "Table",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "peekOfCode": "class Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)\n    def get_component_name(self):\n        return Components.DATA_STORE",
        "detail": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "ICatalystRowInput",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "peekOfCode": "ICatalystRowInput = TypedDict('ICatalystRowInput', {'ROWID': str})\nBulkOperation = Literal['read', 'write']\nclass Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)",
        "detail": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "BulkOperation",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "peekOfCode": "BulkOperation = Literal['read', 'write']\nclass Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)\n    def get_component_name(self):",
        "detail": ".build.functions.school.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "ICatalystFolderDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class ICatalystFolderDetails(ICatalystFolder):\n    created_time: Optional[str]\n    created_by: Optional[ICatalystSysUser]\n    project_details: Optional[ICatalystProject]\nclass ICatalystFileDetails(ICatalystFile, ICatalystGResponse):\n    pass\nclass Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester",
        "detail": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "ICatalystFileDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class ICatalystFileDetails(ICatalystFile, ICatalystGResponse):\n    pass\nclass Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester\n        self._folder_details = folder_details\n        self._id = folder_details.get('id')\n    def __repr__(self) -> str:\n        return str(self._folder_details)",
        "detail": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "Folder",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester\n        self._folder_details = folder_details\n        self._id = folder_details.get('id')\n    def __repr__(self) -> str:\n        return str(self._folder_details)\n    def get_component_name(self):\n        return Components.FILE_STORE",
        "detail": ".build.functions.school.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "Cron",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._cron",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._cron",
        "peekOfCode": "class Cron:\n    def __init__(self, job_scheduling_instance) -> None:\n        self._requester: AuthorizedHttpClient = job_scheduling_instance._requester\n    def get_component_name(self):\n        return Components.JOB_SCHEDULING\n    def get_all(self) -> List[ICatalystCronDetails]:\n        \"\"\"\n        Get a list of all static crons\n        Returns:\n            List[ICatalystCronDetails]: List of static cron details",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._cron",
        "documentation": {}
    },
    {
        "label": "CatalystJobSchedulingError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._exception",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._exception",
        "peekOfCode": "class CatalystJobSchedulingError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._exception",
        "documentation": {}
    },
    {
        "label": "Job",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._job",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._job",
        "peekOfCode": "class Job:\n    def __init__(self, job_scheduling_instance):\n        self._requester: AuthorizedHttpClient = job_scheduling_instance._requester\n    def get_job(self, job_id: str) -> ICatalystJobDetails:\n        \"\"\"\n        Get a job's details\n        Args:\n            job_id: Id of the job to be fetched\n        Returns:\n            ICatalystJobDetails: Details of job fetched with the job_id",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._job",
        "documentation": {}
    },
    {
        "label": "CapacityAttribute",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CapacityAttribute(Enum):\n    MEMORY = \"memory\"\n    NUMBER = \"number\"\nclass CronExecutionType(Enum):\n    PRE_DEFINED = \"pre-defined\"\n    DYNAMIC = \"dynamic\"\nclass CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "CronExecutionType",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CronExecutionType(Enum):\n    PRE_DEFINED = \"pre-defined\"\n    DYNAMIC = \"dynamic\"\nclass CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"\n    CRON_EXPRESSION = \"CronExpression\"\nclass TargetType(Enum):\n    FUNCTION = \"Function\"",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "CronType",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"\n    CRON_EXPRESSION = \"CronExpression\"\nclass TargetType(Enum):\n    FUNCTION = \"Function\"\n    CIRCUIT = \"Circuit\"\n    APPSAIL = \"AppSail\"\n    WEBHOOK = \"Webhook\"",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TargetType",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class TargetType(Enum):\n    FUNCTION = \"Function\"\n    CIRCUIT = \"Circuit\"\n    APPSAIL = \"AppSail\"\n    WEBHOOK = \"Webhook\"\nclass JobStatus(Enum):\n    SUBMITTED = \"Submitted\"\n    PENDING = \"Pending\"\n    RUNNING = \"Running\"\n    SUCCESSFUL = \"Successful\"",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "JobStatus",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class JobStatus(Enum):\n    SUBMITTED = \"Submitted\"\n    PENDING = \"Pending\"\n    RUNNING = \"Running\"\n    SUCCESSFUL = \"Successful\"\n    FAILURE = \"Failure\"\nclass RepetitionType(Enum):\n    EVERY = \"every\"\n    DAILY = \"daily\"\n    MONTHLY = \"monthly\"",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "RepetitionType",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class RepetitionType(Enum):\n    EVERY = \"every\"\n    DAILY = \"daily\"\n    MONTHLY = \"monthly\"\n    YEARLY = \"yearly\"\nclass ICatalystCapacityAttributes(TypedDict):\n    memory: int\n    number: int\nclass ICatalystJobTargetDetails(TypedDict):\n    id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCapacityAttributes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCapacityAttributes(TypedDict):\n    memory: int\n    number: int\nclass ICatalystJobTargetDetails(TypedDict):\n    id: str\n    target_name: str\n    details: Dict[str, Any]\nclass ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobTargetDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobTargetDetails(TypedDict):\n    id: str\n    target_name: str\n    details: Dict[str, Any]\nclass ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType\n    name: str\n    capacity: ICatalystCapacityAttributes\nclass ICatalystJobMetaConfig(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobpoolDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType\n    name: str\n    capacity: ICatalystCapacityAttributes\nclass ICatalystJobMetaConfig(TypedDict):\n    number_of_retires: int\n    retry_interval: int\nclass ICatalystJobBasic(TypedDict):\n    job_name: str",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobMetaConfig",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobMetaConfig(TypedDict):\n    number_of_retires: int\n    retry_interval: int\nclass ICatalystJobBasic(TypedDict):\n    job_name: str\n    job_config: Optional[ICatalystJobMetaConfig]\n    jobpool_id: str\n    jobpool_name: str\nclass ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobBasic",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobBasic(TypedDict):\n    job_name: str\n    job_config: Optional[ICatalystJobMetaConfig]\n    jobpool_id: str\n    jobpool_name: str\nclass ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]\n    target_id: str\n    params: Dict[str, str]\nclass ICatalystWebhookJob(ICatalystJobBasic):",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystFunctionJob",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]\n    target_id: str\n    params: Dict[str, str]\nclass ICatalystWebhookJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.WEBHOOK]\n    target_id: str\n    url: str\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystWebhookJob",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystWebhookJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.WEBHOOK]\n    target_id: str\n    url: str\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]\n    request_method: str\n    request_body: Optional[str]\nclass ICatalystAppSailJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.APPSAIL]",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystAppSailJob",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystAppSailJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.APPSAIL]\n    target_id: str\n    url: Optional[str]\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]\n    request_method: str\n    request_body: Optional[str]\nclass ICatalystCircuitJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.CIRCUIT]",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCircuitJob",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCircuitJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.CIRCUIT]\n    target_id: str\n    test_cases: Dict[str, Any]\n# pylint: disable=invalid-name\nTCatalystJobs = Union[\n    ICatalystFunctionJob, ICatalystWebhookJob, ICatalystAppSailJob, ICatalystCircuitJob\n]\nclass ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobMetaDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str\n    target_details: ICatalystJobTargetDetails\n    source_type: str\n    source_id: str\n    source_details: str\n    jobpool_details: ICatalystJobpoolDetails\n    target_type: TargetType\n    target_id: str\n    url: Optional[str]",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobDetails(ICatalystGResponse):\n    job_id: str\n    status: bool\n    job_status: JobStatus\n    capacity: ICatalystCapacityAttributes\n    job_meta_details: ICatalystJobMetaDetails\n    response_code: Optional[str]\n    start_time: str\n    end_time: str\n    execution_time: str",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronBasic",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronBasic(TypedDict):\n    cron_execution_type: CronExecutionType\n    cron_name: str\n    cron_status: bool\n    job_meta: TCatalystJobs\none_time_cron_detail = TypedDict(\n    \"one_time_cron_detail\", {\"time_of_execution\": str, \"timezone\": Optional[str]}\n)\nclass ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystOneTimeCron",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]\n    cron_detail: one_time_cron_detail\nevery_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystEveryCron",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystEveryCron(ICatalystCronBasic):\n    cron_type: Literal[\"Periodic\"]\n    cron_detail: every_cron_detail\n    end_time: Optional[str]\ndaily_cron_detail = TypedDict(\n    \"daily_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystDailyCron",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystDailyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: daily_cron_detail\n    end_time: Optional[str]\nmonthly_cron_detail = TypedDict(\n    \"monthly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"monthly\"],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystMonthlyCron",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystMonthlyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: monthly_cron_detail\n    end_time: Optional[str]\nyearly_cron_detail = TypedDict(\n    \"yearly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"yearly\"],\n        \"months\": List[int],\n        \"days\": Optional[List[int]],",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystYearlyCron",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystYearlyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: yearly_cron_detail\n    end_time: Optional[str]\nexpression_cron_detail = TypedDict(\n    \"expression_cron_detail\", {\"timezone\": Optional[str]}\n)\nclass ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronExpression",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str\n    cron_detail: expression_cron_detail\n    end_time: Optional[str]\n# pylint: disable=invalid-name\nTCatalystCron = Union[\n    ICatalystOneTimeCron,\n    ICatalystEveryCron,\n    ICatalystDailyCron,",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronDetails(ICatalystGResponse):\n    id: str\n    cron_name: str\n    description: Optional[str]\n    cron_type: CronType\n    cron_function_id: Optional[str]\n    cron_execution_type: CronExecutionType\n    cron_status: bool\n    start_time: str\n    end_time: str",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TCatalystJobs",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "TCatalystJobs = Union[\n    ICatalystFunctionJob, ICatalystWebhookJob, ICatalystAppSailJob, ICatalystCircuitJob\n]\nclass ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str\n    target_details: ICatalystJobTargetDetails\n    source_type: str\n    source_id: str\n    source_details: str\n    jobpool_details: ICatalystJobpoolDetails",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "one_time_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "one_time_cron_detail = TypedDict(\n    \"one_time_cron_detail\", {\"time_of_execution\": str, \"timezone\": Optional[str]}\n)\nclass ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]\n    cron_detail: one_time_cron_detail\nevery_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "every_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "every_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],\n        \"repetition_type\": Literal[\"every\"],\n    },\n)",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "daily_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "daily_cron_detail = TypedDict(\n    \"daily_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],\n        \"repetition_type\": Literal[\"daily\"],\n    },\n)",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "monthly_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "monthly_cron_detail = TypedDict(\n    \"monthly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"monthly\"],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],\n        \"week_day\": Optional[List[int]],\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "yearly_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "yearly_cron_detail = TypedDict(\n    \"yearly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"yearly\"],\n        \"months\": List[int],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],\n        \"week_day\": Optional[List[int]],\n        \"hour\": int,\n        \"minute\": int,",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "expression_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "expression_cron_detail = TypedDict(\n    \"expression_cron_detail\", {\"timezone\": Optional[str]}\n)\nclass ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str\n    cron_detail: expression_cron_detail\n    end_time: Optional[str]\n# pylint: disable=invalid-name\nTCatalystCron = Union[",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TCatalystCron",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "TCatalystCron = Union[\n    ICatalystOneTimeCron,\n    ICatalystEveryCron,\n    ICatalystDailyCron,\n    ICatalystMonthlyCron,\n    ICatalystYearlyCron,\n    ICatalystCronExpression,\n]\nclass ICatalystCronDetails(ICatalystGResponse):\n    id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TableItem",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql._table_items",
        "description": ".build.functions.school.zcatalyst_sdk.nosql._table_items",
        "peekOfCode": "class TableItem(Component):\n    \"\"\"This class used to perform NoSQL table operations.\n    Args:\n        Component (ABC): Class used to retrieve the component's name.\n    \"\"\"\n    def __init__(self, nosql_instance, table) -> None:\n        self._requester: AuthorizedHttpClient = nosql_instance._requester\n        if not is_non_empty_string_or_number(table, 'table_identifier'):\n            table = table['id']\n        self.base_path = f'/nosqltable/{table}'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql._table_items",
        "documentation": {}
    },
    {
        "label": "AttrBase",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttrBase:\n    \"\"\"This class used to construct the attribute condition dict.\"\"\"\n    operator = ''\n    def __init__(self, name, values):\n        self.name = name\n        self.value = values\n    def get_condition(self):\n        return {\n            'attribute': self.name,\n            'operator': self.operator,",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "FuncBase",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class FuncBase:\n    \"\"\"This class used to construct the function condition dict.\"\"\"\n    operator = ''\n    def __init__(self, name, value = None):\n        self.args = []\n        self.args.append({\n            'attribute_path': name\n        })\n        self.values = value\n    def get_condition(self):",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GroupBase",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GroupBase:\n    \"\"\"This class used to construct the group condition dict.\"\"\"\n    operator = ''\n    group= []\n    def __init__(self, value):\n        self.value = value\n    def get_grouped_values(self):\n        self.group.extend(self.value)\n    def get_condition(self):\n        self.get_grouped_values()",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Attr",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Attr:\n    \"\"\"Represents an NoSql attribute condition.\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def __and__(self, value):\n        raise CatalystNoSqlError('AND', self)\n    def __or__(self, value):\n        raise CatalystNoSqlError('OR', self)\n    def __invert__(self):\n        raise CatalystNoSqlError('NOT', self)",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Func",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Func:\n    \"\"\"Represents an NoSql function condition.\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def exists(self):\n        \"\"\"Creates a condition where the attribute exists.\"\"\"\n        return AttributeExists(self.name).get_condition()\n    def not_exists(self):\n        \"\"\"Creates a condition where the attribute does not exist.\"\"\"\n        return AttributeNotExists(self.name).get_condition()",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Group",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Group:\n    \"\"\"Represents an NoSql Group condition.\"\"\"\n    def __init__(self, value):\n        self.value = value\n    def with_and(self):\n        \"\"\"Creates a group condition where the condition and to the other condition\n        :param value: The condition that the other condition is group with AND operator.\n        \"\"\"\n        return And(self.value).get_condition()\n    def with_or(self):",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Key",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Key(Attr):\n    pass\nclass Equals(AttrBase):\n    operator = 'equals'\nclass NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Equals",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Equals(AttrBase):\n    operator = 'equals'\nclass NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "NotEquals",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "LessThan",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "LessThanEquals",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GreaterThan",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GreaterThanEquals",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Between",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "BeginsWith",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Contains",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "In",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeExists",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeNotExists",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeType",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "And",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Or",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class Item:\n    \"\"\"This class used to perform coversion between NoSQL and Python types.\n    Returns:\n        Item: Instance of the class.\n    \"\"\"\n    @staticmethod\n    def to_nosql(items):\n        \"\"\"Convert the given type to NoSQl typs.\n        Args:\n            items (dict): Items to converted in to NoSQL type.",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "NoSqlItemResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class NoSqlItemResponse():\n    \"\"\" NoSQL Table Response.\"\"\"\n    def __init__(self, res_data: NoSqlItem):\n        self.status = res_data.get('status')\n        self.item = res_data.get('item') and Item.to_python({ 'M': res_data.get('item')})\n        self.old_item = res_data.get('old_item') and \\\n            Item.to_python({ 'M' :res_data.get('old_item')})\n    def to_dict(self):\n        return {k: v for k, v in self.__dict__.items() if v is not None and v != self.status}\n    def __repr__(self):",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "NoSqlResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class NoSqlResponse():\n    \"\"\"NoSQL response for all operations performed in the NoSQL table.\"\"\"\n    def __init__(self, res_data: NoSqlItemRes) -> None:\n        self._res_data = res_data\n        self.size = res_data.get('size')\n        self.operation = res_data.get('operation')\n        self.start_key = res_data.get('start_key')\n        self.get = res_data.get('get') and \\\n            [NoSqlItemResponse(i).to_dict() for i in res_data.get('get')]\n        self.update = res_data.get('update') and \\",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "Binary",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify\n    binary data for item in NoSQL. It is essentially a wrapper around\n    binary. Unicode and Python 3 string types are not allowed.\n    \"\"\"\n    def __init__(self, value):\n        if not isinstance(value, BINARY_TYPES):\n            types = ', '.join([str(t) for t in BINARY_TYPES])\n            raise TypeError(f'Value must be of the following types: {types}')",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "TypeSerializer",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class TypeSerializer:\n    \"\"\"This class serializes Python data types to NoSQL types.\"\"\"\n    def serialize(self, value):\n        \"\"\"The method to serialize the Python data types.\n        :param value: A python value to be serialized to NoSQL. Here are\n            the various conversions:\n            Python                                  NoSQL\n            ------                                  --------\n            None                                    {'NULL': True}\n            True/False                              {'BOOL': True/False}",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "TypeDeserializer",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class TypeDeserializer:\n    \"\"\"This class deserializes NoSQL types to Python types.\"\"\"\n    def deserialize(self, value):\n        \"\"\"The method to deserialize the NoSQL data types.\n        :param value: A NoSQL value to be deserialized to a pythonic value.\n            Here are the various conversions:\n            NoSQL                                Python\n            --------                                ------\n            {'NULL': True}                          None\n            {'BOOL': True/False}                    True/False",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "STRING",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "STRING = 'S'\nNUMBER = 'N'\nBINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NUMBER",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NUMBER = 'N'\nBINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "STRING_SET",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "STRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NUMBER_SET",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY_SET",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NULL",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BOOLEAN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "MAP",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "MAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "LIST",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "LIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NOSQL_CONTEXT",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY_TYPES",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify\n    binary data for item in NoSQL. It is essentially a wrapper around\n    binary. Unicode and Python 3 string types are not allowed.\n    \"\"\"\n    def __init__(self, value):\n        if not isinstance(value, BINARY_TYPES):\n            types = ', '.join([str(t) for t in BINARY_TYPES])",
        "detail": ".build.functions.school.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "MobilePlatform",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.push_notification._mobile_notification",
        "description": ".build.functions.school.zcatalyst_sdk.push_notification._mobile_notification",
        "peekOfCode": "class MobilePlatform(Enum):\n    IOS = \"ios\"\n    ANDROID = \"android\"\nclass MobileNotification:\n    \"\"\"\n    Class that contains the APIs for mobile push notification\n    \"\"\"\n    def __init__(self, requester: AuthorizedHttpClient, app_id):\n        self._app_id = app_id\n        self._requester = requester",
        "detail": ".build.functions.school.zcatalyst_sdk.push_notification._mobile_notification",
        "documentation": {}
    },
    {
        "label": "MobileNotification",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.push_notification._mobile_notification",
        "description": ".build.functions.school.zcatalyst_sdk.push_notification._mobile_notification",
        "peekOfCode": "class MobileNotification:\n    \"\"\"\n    Class that contains the APIs for mobile push notification\n    \"\"\"\n    def __init__(self, requester: AuthorizedHttpClient, app_id):\n        self._app_id = app_id\n        self._requester = requester\n    def send_ios_notification(\n        self, notify_obj: ICatalystPushDetails, recipient: str\n    ) -> ICatalystMobileNotification:",
        "detail": ".build.functions.school.zcatalyst_sdk.push_notification._mobile_notification",
        "documentation": {}
    },
    {
        "label": "WebNotification",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.push_notification._web_notificaton",
        "description": ".build.functions.school.zcatalyst_sdk.push_notification._web_notificaton",
        "peekOfCode": "class WebNotification:\n    def __init__(self, notification_instance):\n        self._app = notification_instance._app\n        self._requester: AuthorizedHttpClient = notification_instance._requester\n    def send_notification(\n        self,\n        message: str,\n        recipients: List[str]\n    ) -> bool:\n        validator.is_non_empty_string(message, 'message', CatalystPushNotificationError)",
        "detail": ".build.functions.school.zcatalyst_sdk.push_notification._web_notificaton",
        "documentation": {}
    },
    {
        "label": "SignatureCache",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.stratus._auth_util",
        "description": ".build.functions.school.zcatalyst_sdk.stratus._auth_util",
        "peekOfCode": "class SignatureCache:\n    \"\"\"\n    Handles signature caching and retrieval for bucket authentication.\n    \"\"\"\n    bucket_signatures: Dict[str, Dict] = {}\n    @classmethod\n    def get_signature(cls, bucket_name: str) -> Optional[Dict]:\n        \"\"\"\n        Retrieve the cached signature for the specified bucket if valid.\n        \"\"\"",
        "detail": ".build.functions.school.zcatalyst_sdk.stratus._auth_util",
        "documentation": {}
    },
    {
        "label": "AuthUtil",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.stratus._auth_util",
        "description": ".build.functions.school.zcatalyst_sdk.stratus._auth_util",
        "peekOfCode": "class AuthUtil:\n    \"\"\"\n    Handles user authentication and signature retrieval for buckets.\n    \"\"\"\n    def __init__(self, bucket_name: str, requester: AuthorizedHttpClient) -> None:\n        self.bucket_name = bucket_name\n        self._requester = requester\n        self.user_type = requester._app.credential.current_user_type()\n        self.user_scope = requester._app.credential.current_user()\n    def get_user_type(self) -> str:",
        "detail": ".build.functions.school.zcatalyst_sdk.stratus._auth_util",
        "documentation": {}
    },
    {
        "label": "Bucket",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.stratus.bucket",
        "description": ".build.functions.school.zcatalyst_sdk.stratus.bucket",
        "peekOfCode": "class Bucket(ParsableComponent):\n    def __init__(self, stratus_instance, bucket_details: Dict):\n        validator.is_non_empty_dict(bucket_details, 'bucket_details', CatalystStratusError)\n        self._requester: AuthorizedHttpClient = stratus_instance._requester\n        self._bucket_name = bucket_details.get('bucket_name')\n        self.bucket_details = bucket_details\n        self._auth_util = AuthUtil(self._bucket_name, self._requester)\n        if self._requester._app.config.get(ENVIRONMENT) == 'Development':\n            self.bucket_domain = f'https://{self._bucket_name}-development{STRATUS_SUFFIX}'\n        else:",
        "detail": ".build.functions.school.zcatalyst_sdk.stratus.bucket",
        "documentation": {}
    },
    {
        "label": "StratusObject",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.stratus.object",
        "description": ".build.functions.school.zcatalyst_sdk.stratus.object",
        "peekOfCode": "class StratusObject(ParsableComponent):\n    def __init__(self, bucket_instance, object_details: Dict):\n        validator.is_non_empty_dict(object_details, 'object_details', CatalystStratusError)\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self._key = object_details.get('key')\n        self.object_details = object_details\n        self.req_params = {\n            'bucket_name': bucket_instance.get_name(),\n            'object_key': self._key\n        }",
        "detail": ".build.functions.school.zcatalyst_sdk.stratus.object",
        "documentation": {}
    },
    {
        "label": "MultipartUpload",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "class MultipartUpload():\n    def __init__(self, bucket_instance, key, upload_id):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.key = key\n        self.upload_id = upload_id\n    def upload_part(self,\n            body: Union[BufferedReader, bytes],\n            part_number: Union[str, int],\n            overwrite: Union[str, bool] = False",
        "detail": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "TransferManager",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "class TransferManager(Component):\n    def __init__(self, bucket_instance):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.bucket_domain = bucket_instance.bucket_domain\n    def get_component_name(self):\n        return Components.STRATUS\n    def create_multipart_instance(self,\n        key: str,\n        upload_id: str = None,",
        "detail": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "logger = get_logger()\nclass MultipartUpload():\n    def __init__(self, bucket_instance, key, upload_id):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.key = key\n        self.upload_id = upload_id\n    def upload_part(self,\n            body: Union[BufferedReader, bytes],\n            part_number: Union[str, int],",
        "detail": ".build.functions.school.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "NoSqlCrudOperation",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\nclass CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str\n    first_name: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystSysUser",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str\n    first_name: str\n    last_name: str\n    zuid: Optional[str]\n    is_confirmed: Optional[bool]\nclass CatalystProjectInfo(TypedDict):\n    id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystProjectInfo",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystProjectInfo(TypedDict):\n    id: str\n    project_name: str\n    project_type: str\nclass CatalystNoSqlKeyInfo(TypedDict):\n    column_name: str\n    data_type: str\nclass NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystNoSqlKeyInfo",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystNoSqlKeyInfo(TypedDict):\n    column_name: str\n    data_type: str\nclass NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    modified_by: CatalystSysUser\n    modified_time: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlTableResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str\n    partition_key: CatalystNoSqlKeyInfo\n    project_id: CatalystProjectInfo",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlIndexRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlIndexRes(TypedDict):\n    created_by: CatalystSysUser\n    created_time: str\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str\n    partition_key:CatalystNoSqlKeyInfo\n    project_id: CatalystProjectInfo\n    projected_attributes: ProjectedAttribute",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlTableResourceRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlTableResourceRes(TypedDict):\n    additional_sort_keys: List[NoSqlIndexRes]\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    global_index: List[NoSqlIndexRes]\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "UpdateCondion",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class UpdateCondion(TypedDict):\n    function_name: Literal['if_not_exists', 'add', 'subtract', 'append_list']\n    args: AttributePath\nclass NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion\n    attribute_path: List[str]\nclass NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItemUpdateAttributeOperation",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion\n    attribute_path: List[str]\nclass NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']\n    args: AttributePath\nclass NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlFunctionCondition",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']\n    args: AttributePath\nclass NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]\nclass NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlConditionFuncOperation",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]\nclass NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlAttributeCondition",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool\nNoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlGroupCondition",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool\nNoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItem",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]\n    create: List[NoSqlItem]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItemRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]\n    create: List[NoSqlItem]\n    delete: List[NoSqlItem]\n    get: List[NoSqlItem]\nNoSqlInsertItemReq = TypedDict('NoSqlInsertItemReq', {\n    'item': Dict[str, str],",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlFetchItemReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlFetchItemReq(TypedDict):\n    keys: List[Dict[str, str]]\n    required_attributes: List[str]\nclass NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\nclass NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlDeleteItemReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\nclass NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]\nclass NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlUpdateItemReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]\nclass NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition\n    other_condition: Optional[NoSqlCondition]\n    limit: int\n    forward_scan: bool",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlQueryItemReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition\n    other_condition: Optional[NoSqlCondition]\n    limit: int\n    forward_scan: bool\n    start_key: Dict[str, str]\n    additional_sort_keys: str\n    required_attributes: List[str]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlAttributeType",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlAttributeType = Literal['keys_only', 'all', 'include']\nNoSqlGroupOperator = Literal['AND', 'OR']\nNoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlGroupOperator",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlGroupOperator = Literal['AND', 'OR']\nNoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlUpdateOperation",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlOperator",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ItemType",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlSecondaryKeyCondition",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ReturnType",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\nclass CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ProjectedAttribute",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ProjectedAttribute = TypedDict('ProjectedAttribute', {\n    'type': str,\n})\nclass NoSqlIndexRes(TypedDict):\n    created_by: CatalystSysUser\n    created_time: str\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "AttributePath",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "AttributePath = TypedDict('AttributePath', {\n        'attribute_path': List[str]\n})\nclass UpdateCondion(TypedDict):\n    function_name: Literal['if_not_exists', 'add', 'subtract', 'append_list']\n    args: AttributePath\nclass NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlCondition",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlInsertItemReq",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlInsertItemReq = TypedDict('NoSqlInsertItemReq', {\n    'item': Dict[str, str],\n    'condition': Optional[NoSqlCondition],\n    'return': ReturnType\n}, total = False)\nclass NoSqlFetchItemReq(TypedDict):\n    keys: List[Dict[str, str]]\n    required_attributes: List[str]\nclass NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "PipelineDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.pipeline",
        "description": ".build.functions.school.zcatalyst_sdk.types.pipeline",
        "peekOfCode": "class PipelineDetails(TypedDict):\n    pipeline_id: str\n    name: str\n    description: str\n    project_details: ICatalystProject\n    created_time: str\n    created_by: ICatalystSysUser\n    modified_time: str\n    modified_by: ICatalystSysUser\n    git_account_id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.pipeline",
        "documentation": {}
    },
    {
        "label": "PipelineRun",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.pipeline",
        "description": ".build.functions.school.zcatalyst_sdk.types.pipeline",
        "peekOfCode": "class PipelineRun(TypedDict):\n    history_id: str\n    pipeline_id: str\n    event_time: str\n    event_details: Dict[str, str]\n    history_status: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.pipeline",
        "documentation": {}
    },
    {
        "label": "PdfOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class PdfOptions(TypedDict, total=False):\n    scale: Union[int,str]\n    display_header_footer: bool\n    header_template: str\n    password: str\n    footer_template: str\n    print_background: bool\n    landscape: bool\n    page_ranges: Union[int,str]\n    format: PdfFormats",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfPageOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name\n    viewport: PdfViewPort\n    javascript_enabled: bool\nclass ScreenShotOptions(TypedDict, total=False):\n    type: Literal['jpeg', 'png']\n    quality: Union[int, str]\n    full_page: bool\n    omit_background: bool",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "ScreenShotOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class ScreenShotOptions(TypedDict, total=False):\n    type: Literal['jpeg', 'png']\n    quality: Union[int, str]\n    full_page: bool\n    omit_background: bool\n    capture_beyond_viewport: bool\nclass ScreenShotPageOptions(TypedDict):\n    device: str\nclass NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "ScreenShotPageOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class ScreenShotPageOptions(TypedDict):\n    device: str\nclass NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]\n    wait_until: Literal['load', 'domcontentloaded', 'networkidle0', 'networkidle2']\nclass OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "NavigationOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]\n    wait_until: Literal['load', 'domcontentloaded', 'networkidle0', 'networkidle2']\nclass OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "OutputOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseSimilarCompanyReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseEnrichLeadReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,\n    'street':str,\n    'pincode':str\n}, total=False)",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseLead",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseLead(TypedDict, total = False):\n    organization_name: str\n    description: str\n    employee_count: str\n    revenue: str\n    organization_type: str\n    organization_status: str\n    email: List[str]\n    address: List[str]\n    contact: List[str]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseTechStack",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseTechStack(TypedDict, total = False):\n    organization_name: str\n    website: str\n    website_status: str\n    technographic_data: Dict[str, None]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfFormats",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfFormats = Literal[\n    'Letter', 'Legal', 'Tabloid', 'Ledger',\n    'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6'\n]\nPdfMargin = TypedDict('PdfMargin', {\n    'top': str,\n    'bottom': str,\n    'left': str,\n    'right': str\n}, total=False)",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfMargin",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfMargin = TypedDict('PdfMargin', {\n    'top': str,\n    'bottom': str,\n    'left': str,\n    'right': str\n}, total=False)\nclass PdfOptions(TypedDict, total=False):\n    scale: Union[int,str]\n    display_header_footer: bool\n    header_template: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "CssContent",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "CssContent = TypedDict('CssContent', {\n    'content': str\n})\nCssUrl = TypedDict('CssUrl', {\n    'url': str\n})\nJsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "CssUrl",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "CssUrl = TypedDict('CssUrl', {\n    'url': str\n})\nJsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "JsContent",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "JsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "JsUrl",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "JsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})\nclass PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfViewPort",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})\nclass PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name\n    viewport: PdfViewPort\n    javascript_enabled: bool\nclass ScreenShotOptions(TypedDict, total=False):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "OrgHeadquarters",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "OrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,\n    'street':str,\n    'pincode':str\n}, total=False)\nclass DataverseLead(TypedDict, total = False):\n    organization_name: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "BucketMeta",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class BucketMeta(TypedDict):\n    versioning: bool\n    caching: Cache\n    encryption: bool\n    audit_consent: bool\nclass StratusObjectDetails(TypedDict):\n    key_type: str\n    key: str\n    size: int\n    version_id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectDetails",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectDetails(TypedDict):\n    key_type: str\n    key: str\n    size: int\n    version_id: str\n    etag: str\n    content_type: str\n    last_modified: str\n    object_url: Optional[str]\nclass StratusObjectsRes(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectsRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectsRes(TypedDict):\n    key_count: int\n    max_keys: Optional[int]\n    truncated: str\n    next_continuation_token: Optional[str]\n    contents: List[StratusObjectDetails]\nclass DeleteObjectOptions(TypedDict):\n    key: str\n    version_id: str\nclass StratusBucket(ICatalystGResponse):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "DeleteObjectOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class DeleteObjectOptions(TypedDict):\n    key: str\n    version_id: str\nclass StratusBucket(ICatalystGResponse):\n    bucket_name: str\n    bucket_url: str\n    objects_count: str\n    size_in_bytes: str\n    bucket_meta: BucketMeta\nclass StratusObjectVersion(TypedDict, total = False):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusBucket",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusBucket(ICatalystGResponse):\n    bucket_name: str\n    bucket_url: str\n    objects_count: str\n    size_in_bytes: str\n    bucket_meta: BucketMeta\nclass StratusObjectVersion(TypedDict, total = False):\n    version_id: str\n    is_latest: Optional[bool]\n    last_modified: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectVersion",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectVersion(TypedDict, total = False):\n    version_id: str\n    is_latest: Optional[bool]\n    last_modified: str\n    size: str\n    etag: str\nclass ObjectVersionsRes(TypedDict):\n    key: str\n    versions_count: str\n    next_continuation_token: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "ObjectVersionsRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class ObjectVersionsRes(TypedDict):\n    key: str\n    versions_count: str\n    next_continuation_token: str\n    max_versions: str\n    is_truncated: Optional[bool]\n    version: List[StratusObjectVersion]\nclass BucketCorsResponse(TypedDict):\n    domain: str\n    allowed_methods: List[str]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "BucketCorsResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class BucketCorsResponse(TypedDict):\n    domain: str\n    allowed_methods: List[str]\nclass CopyObjectResponse(TypedDict):\n    key: str\n    copy_to: str\n    message: str\nclass RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "CopyObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class CopyObjectResponse(TypedDict):\n    key: str\n    copy_to: str\n    message: str\nclass RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str\n    message: str\nclass UnzipObjectResponse(TypedDict):\n    key: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "RenameObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str\n    message: str\nclass UnzipObjectResponse(TypedDict):\n    key: str\n    destination: str\n    message: str\n    task_id: str\nclass DeleteObjectPathResponse(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "UnzipObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class UnzipObjectResponse(TypedDict):\n    key: str\n    destination: str\n    message: str\n    task_id: str\nclass DeleteObjectPathResponse(TypedDict):\n    prefix: str\n    message: str\nclass InitiateMultipartUploadResponse(TypedDict):\n    bucket: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "DeleteObjectPathResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class DeleteObjectPathResponse(TypedDict):\n    prefix: str\n    message: str\nclass InitiateMultipartUploadResponse(TypedDict):\n    bucket: str\n    key: str\n    upload_id: int\n    status: str\nclass UploadedObjectPartRes(TypedDict):\n    part_number: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "InitiateMultipartUploadResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class InitiateMultipartUploadResponse(TypedDict):\n    bucket: str\n    key: str\n    upload_id: int\n    status: str\nclass UploadedObjectPartRes(TypedDict):\n    part_number: str\n    size: str\n    upload_at: str\nclass MultipartUploadSummaryRes(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "UploadedObjectPartRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class UploadedObjectPartRes(TypedDict):\n    part_number: str\n    size: str\n    upload_at: str\nclass MultipartUploadSummaryRes(TypedDict):\n    bucket: str\n    key: str\n    upload_id: str\n    parts: List[UploadedObjectPartRes]\nclass StratusSignature(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "MultipartUploadSummaryRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class MultipartUploadSummaryRes(TypedDict):\n    bucket: str\n    key: str\n    upload_id: str\n    parts: List[UploadedObjectPartRes]\nclass StratusSignature(TypedDict):\n    stsPolicy: str\n    stsSignature: str\nclass StratusPutObjectRes(TypedDict):\n    task_id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusSignature",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusSignature(TypedDict):\n    stsPolicy: str\n    stsSignature: str\nclass StratusPutObjectRes(TypedDict):\n    task_id: str\nclass PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusPutObjectRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusPutObjectRes(TypedDict):\n    task_id: str\nclass PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "PutObjectAsPartsOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusInitiateUploadOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "Cache",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "Cache = TypedDict('caching', {\n    'status': Union[str, bool]\n})\nStratusUploadOptions = TypedDict('StratusUploadOptions', {\n    'overwrite': Union[str, bool],\n    'ttl': str,\n    'compress': str,\n    'meta_data': Dict[str, str],\n    'content_type': str,\n    'extract_upload': Literal['true', 'false']",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusUploadOptions",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "StratusUploadOptions = TypedDict('StratusUploadOptions', {\n    'overwrite': Union[str, bool],\n    'ttl': str,\n    'compress': str,\n    'meta_data': Dict[str, str],\n    'content_type': str,\n    'extract_upload': Literal['true', 'false']\n}, total= False)\nStratusDownloadOptions = TypedDict('StratusDownloadOptions', {\n    'version_id': str,",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusDownloadOptions",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "peekOfCode": "StratusDownloadOptions = TypedDict('StratusDownloadOptions', {\n    'version_id': str,\n    'range': str\n}, total= False)\nclass BucketMeta(TypedDict):\n    versioning: bool\n    caching: Cache\n    encryption: bool\n    audit_consent: bool\nclass StratusObjectDetails(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "ObjectParams",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ObjectParams(TypedDict):\n    co_ordinates: List[int]\n    object_type: str\n    confidence: str\nclass ICatalystZiaObject(TypedDict):\n    object: List[ObjectParams]\nclass ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaObject",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaObject(TypedDict):\n    object: List[ObjectParams]\nclass ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaOCR",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaBarcode",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaModeration",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):\n    confidence: int\n    id: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaCom",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):\n    confidence: int\n    id: str\n    co_ordinates: List[int]\n    emotion: ICatalystZiaCom\n    age: ICatalystZiaCom\n    gender: ICatalystZiaCom",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "FaceParams",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class FaceParams(TypedDict):\n    confidence: int\n    id: str\n    co_ordinates: List[int]\n    emotion: ICatalystZiaCom\n    age: ICatalystZiaCom\n    gender: ICatalystZiaCom\n    landmarks: Optional[Dict[str, List[int]]]\nclass ICatalystZiaFace(TypedDict):\n    faces: List[FaceParams]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaFace",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaFace(TypedDict):\n    faces: List[FaceParams]\nclass ICatalystZiaFaceComparison(TypedDict):\n    confidence: Optional[int]\n    matched: bool\nclass ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaFaceComparison",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaFaceComparison(TypedDict):\n    confidence: Optional[int]\n    matched: bool\nclass ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaAutoML",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int\n    positive: int\nclass ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ConfidenceScores",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int\n    positive: int\nclass ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]\n    confidence_scores: ConfidenceScores\nclass ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaAnalytics",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]\n    confidence_scores: ConfidenceScores\nclass ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentenceAnalytics",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaKeywordAnalytics",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentimentAnalysis",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentimentAnalysisResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]\nclass ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaExtractedKeywords",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]\nclass ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaKeywordExtractionResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str\n    token: str\nclass ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNer",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str\n    token: str\nclass ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]\nclass ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNerGeneralEntities",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]\nclass ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities\nclass ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNERPredictionResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities\nclass ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaTextAnalyticsResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.types.zia",
        "description": ".build.functions.school.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.school.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "AcceptHeader",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialUser",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    HEAD = \"HEAD\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "RequestMethod",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    HEAD = \"HEAD\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"\nclass Components:\n    CACHE = \"Cache\"\n    FILE_STORE = \"FileStore\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "Components",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class Components:\n    CACHE = \"Cache\"\n    FILE_STORE = \"FileStore\"\n    MAIL = \"Mail\"\n    SEARCH = \"Search\"\n    ZCQL = \"ZCQL\"\n    ZIA = \"Zia\"\n    CRON = \"Cron\"\n    DATA_STORE = \"DataStore\"\n    FUNCTION = \"Function\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialType",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialType:\n    token = 'token'\n    ticket = 'ticket'\nclass ProjectHeader:\n    project_id = 'X-ZC-ProjectId'\n    domain = 'X-ZC-Project-Domain'\n    key = 'X-ZC-Project-Key'\n    environment = 'X-ZC-Environment'\n    project_secret_key = 'X-ZC-PROJECT-SECRET-KEY'\nclass CredentialHeader:",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ProjectHeader",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class ProjectHeader:\n    project_id = 'X-ZC-ProjectId'\n    domain = 'X-ZC-Project-Domain'\n    key = 'X-ZC-Project-Key'\n    environment = 'X-ZC-Environment'\n    project_secret_key = 'X-ZC-PROJECT-SECRET-KEY'\nclass CredentialHeader:\n    admin_cred_type = 'X-ZC-Admin-Cred-Type'\n    user_cred_type = 'X-ZC-User-Cred-Type'\n    admin_token = 'X-ZC-Admin-Cred-Token'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialHeader",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialHeader:\n    admin_cred_type = 'X-ZC-Admin-Cred-Type'\n    user_cred_type = 'X-ZC-User-Cred-Type'\n    admin_token = 'X-ZC-Admin-Cred-Token'\n    user_token = 'X-ZC-User-Cred-Token'\n    cookie = 'x-zc-cookie'\n    zcsrf = 'X-ZCSRF-TOKEN'\n    user = 'X-ZC-User-Type'\n    signature = \"X-ZC-Stratus-Signature\"\nclass CatalystService:",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CatalystService",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "class CatalystService:\n    SERVERLESS = 'baas'\n    BROWSER360 = 'browser360'\n    QUICK_ML = 'quickml'\n    STRATUS = 'stratus'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "env_override",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "def env_override(env_name: str, default_value: str):\n    env_value = os.getenv(env_name)\n    if not env_value:\n        return default_value\n    return env_value\nmeta_file = path.join(path.dirname(path.abspath(__file__)), '__version__.py')\nmeta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "meta_file",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "meta_file = path.join(path.dirname(path.abspath(__file__)), '__version__.py')\nmeta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version\nSDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "meta",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "meta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version\nSDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "SDK_VERSION",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "SDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_KEY",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_STATUS",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_MESSAGE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_CODE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "SUCCESS_STATUS",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "SUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "FAILURE_STATUS",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "FAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_KEY",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_ID",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_DOMAIN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_SECRET_KEY",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_CRED",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_CRED",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE_CRED",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_ACCESS_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_COOKIE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_ID",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "EXPIRES_IN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "EXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_IN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_SECRET",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "AUTH_URL",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "AUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_URL",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REDIRECT_URL",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "REDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "GRANT_TYPE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "GRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CODE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "TICKET",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "TICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_CRED_TYPE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_CRED_TYPE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JWT_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "JWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_TYPE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "USER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CONNECTOR_NAME",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "USER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "X_CATALYST_ORG_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "X_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_URL",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "URL_SEPARATOR",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "URL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "IS_LOCAL",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "IS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_TOKEN_COOKIE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "APP_DOMAIN",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "APP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "APP_VERSION_V1",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "APP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ACCOUNTS_URL",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "STRATUS_SUFFIX",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "STRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_HEADER",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE_HEADER",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_HEADER",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_AGENT",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "USER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "AUTHORIZATION",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "AUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_SCOPE_HEADER",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "USER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_SCOPE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_SCOPE",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "USER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "OAUTH_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "OAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "TICKET_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "TICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_PARAM_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ZAID",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._constants",
        "description": ".build.functions.school.zcatalyst_sdk._constants",
        "peekOfCode": "ZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"",
        "detail": ".build.functions.school.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "DefaultHttpResponse",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._http_client",
        "description": ".build.functions.school.zcatalyst_sdk._http_client",
        "peekOfCode": "class DefaultHttpResponse:\n    def __init__(self, resp: requests.Response):\n        self._response = resp\n        self._status_code = resp.status_code\n        self._headers = resp.headers\n        self.check_status()\n    @property\n    def response(self):\n        return self._response\n    @property",
        "detail": ".build.functions.school.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "HttpClient",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._http_client",
        "description": ".build.functions.school.zcatalyst_sdk._http_client",
        "peekOfCode": "class HttpClient:\n    def __init__(\n        self,\n        app=None,\n        base_url=None,\n        retries=DEFAULT_RETRY_CONFIG,\n        timeout=DEFAULT_TIMEOUT\n    ):\n        self._session = requests.session()\n        self._timeout = timeout",
        "detail": ".build.functions.school.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "AuthorizedHttpClient",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._http_client",
        "description": ".build.functions.school.zcatalyst_sdk._http_client",
        "peekOfCode": "class AuthorizedHttpClient(HttpClient):\n    temp_credential: JwtTokenCredential = None\n    def __init__(\n        self,\n        app\n    ):\n        super().__init__(app)\n    def request(\n        self,\n        method: str,",
        "detail": ".build.functions.school.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "USERAGENT_HEADER",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._http_client",
        "description": ".build.functions.school.zcatalyst_sdk._http_client",
        "peekOfCode": "USERAGENT_HEADER = {USER_AGENT: \"zc-python-sdk/\" + SDK_VERSION}\n# Default timeout for connect and read operation in seconds\nDEFAULT_TIMEOUT = (60, 30)\nDEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5",
        "detail": ".build.functions.school.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._http_client",
        "description": ".build.functions.school.zcatalyst_sdk._http_client",
        "peekOfCode": "DEFAULT_TIMEOUT = (60, 30)\nDEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5\n)\nclass DefaultHttpResponse:",
        "detail": ".build.functions.school.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RETRY_CONFIG",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk._http_client",
        "description": ".build.functions.school.zcatalyst_sdk._http_client",
        "peekOfCode": "DEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5\n)\nclass DefaultHttpResponse:\n    def __init__(self, resp: requests.Response):",
        "detail": ".build.functions.school.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "ZCThreadUtil",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk._thread_util",
        "description": ".build.functions.school.zcatalyst_sdk._thread_util",
        "peekOfCode": "class ZCThreadUtil:\n    def __init__(self) -> None:\n        try:\n            self.__zclocal = getattr(threading.current_thread(), '__zc_local')\n        except AttributeError:\n            setattr(threading.current_thread(), '__zc_local', {})\n            self.__zclocal = getattr(threading.current_thread(), '__zc_local')\n    def get_value(self, key: str):\n        return self.__zclocal.get(key)\n    def put_value(self, key: str, val: Any):",
        "detail": ".build.functions.school.zcatalyst_sdk._thread_util",
        "documentation": {}
    },
    {
        "label": "get_attr",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk._thread_util",
        "description": ".build.functions.school.zcatalyst_sdk._thread_util",
        "peekOfCode": "def get_attr(obj: dict, key: str):\n    if obj.get(key):\n        return obj.get(key)\n    fallback_obj = dict((k.lower(), v) for k, v in obj.items())\n    return fallback_obj.get(key.lower())",
        "detail": ".build.functions.school.zcatalyst_sdk._thread_util",
        "documentation": {}
    },
    {
        "label": "parse_headers_from_request",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk._util",
        "description": ".build.functions.school.zcatalyst_sdk._util",
        "peekOfCode": "def parse_headers_from_request(request):\n    try:\n        if hasattr(request, 'headers'):\n            thread_obj = ZCThreadUtil()\n            thread_obj.put_value(\"catalyst_headers\", dict(request.headers))\n    except Exception as err:\n        raise CatalystAppError(\n            \"Invalid req_obj\",\n            \"Kindly ensure whether the request object is valid\"\n        ) from err",
        "detail": ".build.functions.school.zcatalyst_sdk._util",
        "documentation": {}
    },
    {
        "label": "ICatalystNewUser",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.authentication",
        "description": ".build.functions.school.zcatalyst_sdk.authentication",
        "peekOfCode": "class ICatalystNewUser(ICatalystSignupConfig):\n    user_details: ICatalystUser\nclass Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:\n        resp = self._requester.request(",
        "detail": ".build.functions.school.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "Authentication",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.authentication",
        "description": ".build.functions.school.zcatalyst_sdk.authentication",
        "peekOfCode": "class Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:\n        resp = self._requester.request(\n            method=RequestMethod.GET,\n            path='/project-user/current',",
        "detail": ".build.functions.school.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "UserStatus",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.authentication",
        "description": ".build.functions.school.zcatalyst_sdk.authentication",
        "peekOfCode": "UserStatus = Literal['enable', 'disable']\nclass ICatalystNewUser(ICatalystSignupConfig):\n    user_details: ICatalystUser\nclass Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:",
        "detail": ".build.functions.school.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "CatalystAppOptions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "class CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()\n        if not isinstance(options, dict):\n            raise CatalystAppError(\n                'INVALID_APP_OPTIONS',\n                f'Illegal app option type - {type(options)}. App options must be a instance of dict'\n            )\n        config = CatalystAppOptions.validate_options(options)",
        "detail": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CatalystApp",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "class CatalystApp:\n    def __init__(\n        self,\n        credential: Credential,\n        options: Dict,\n        name: str\n    ):\n        if not name or not isinstance(name, str):\n            raise CatalystAppError(\n                'INVALID_APP_NAME',",
        "detail": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CATALYST_OPTIONS_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "CATALYST_OPTIONS_ENV_KEY = 'CATALYST_OPTIONS'\nCONFIG_MANDATORIES = {\n    APIConstants.PROJECT_ID: (int, str),\n    APIConstants.PROJECT_KEY: (int, str),\n    APIConstants.PROJECT_DOMAIN: (str,)\n}\nDEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:",
        "detail": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CONFIG_MANDATORIES",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "CONFIG_MANDATORIES = {\n    APIConstants.PROJECT_ID: (int, str),\n    APIConstants.PROJECT_KEY: (int, str),\n    APIConstants.PROJECT_DOMAIN: (str,)\n}\nDEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()",
        "detail": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENVIRONMENT",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "DEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()\n        if not isinstance(options, dict):\n            raise CatalystAppError(\n                'INVALID_APP_OPTIONS',\n                f'Illegal app option type - {type(options)}. App options must be a instance of dict'\n            )",
        "detail": ".build.functions.school.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "Circuit",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.circuit",
        "description": ".build.functions.school.zcatalyst_sdk.circuit",
        "peekOfCode": "class Circuit(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CIRCUIT\n    def execute(\n        self,\n        circuit_id: Union[int, str],\n        name: str,",
        "detail": ".build.functions.school.zcatalyst_sdk.circuit",
        "documentation": {}
    },
    {
        "label": "Credential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class Credential(ABC):\n    @abstractmethod\n    def token(self):\n        pass\n    def _switch_user(self, user=None):  # pylint: disable=unused-argument\n        return None\n    def current_user(self):\n        return CredentialUser.ADMIN\n    def current_user_type(self):\n        return CredentialUser.ADMIN",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "RefreshTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class RefreshTokenCredential(Credential):\n    def __init__(self, refresh_obj: ICatalystRefreshObj):\n        super().__init__()\n        RefreshTokenCredential._validate_refresh_obj(refresh_obj)\n        self._client_id = refresh_obj.get(APIConstants.CLIENT_ID)\n        self._client_secret = refresh_obj.get(APIConstants.CLIENT_SECRET)\n        self._refresh_token = refresh_obj.get(APIConstants.REFRESH_TOKEN)\n        self._cached_token: Dict[str, Union[str, int]] = None\n    def token(self) -> str:\n        if not self._cached_token or self._cached_token.get('expires_in') <= int(round(time())):",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "JwtTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class JwtTokenCredential:\n    def __init__(self, _app):\n        self.project_key = _app.config.get(PROJECT_KEY)\n        self.project_id = _app.config.get(PROJECT_ID)\n        self.project_domain = _app.config.get(PROJECT_DOMAIN)\n        self._cached_token = None\n    def generate_jwt_token(self, cookie: str, requester) -> ICatalystJwtObj:\n        resp = requester.request(\n                method=RequestMethod.GET,\n                url='https://' + self.project_domain +",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "AccessTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class AccessTokenCredential(Credential):\n    def __init__(self, token_obj: ICatalystTokenObj):\n        super().__init__()\n        self._token: str = _get_attr(token_obj, 'access_token')\n    def token(self):\n        return self._token\nclass TicketCredential(Credential):\n    def __init__(self, ticket_obj: ICatalystTicketObj):\n        super().__init__()\n        self._token: str = _get_attr(ticket_obj, 'ticket')",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "TicketCredential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class TicketCredential(Credential):\n    def __init__(self, ticket_obj: ICatalystTicketObj):\n        super().__init__()\n        self._token: str = _get_attr(ticket_obj, 'ticket')\n    def token(self):\n        return self._token\nclass CookieCredential(Credential):\n    def __init__(self, cookie_obj):\n        super().__init__()\n        cookie_str = _get_attr(cookie_obj, 'cookie')",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "CookieCredential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class CookieCredential(Credential):\n    def __init__(self, cookie_obj):\n        super().__init__()\n        cookie_str = _get_attr(cookie_obj, 'cookie')\n        csrf_token: str = ZCThreadUtil().get_value(APIConstants.CSRF_TOKEN_COOKIE)\n        if not csrf_token:\n            cookies_list: List = cookie_str.split(\"; \")\n            for cookie in cookies_list:\n                splitted_cookie: List = cookie.split(\"=\")\n                if splitted_cookie[0] == APIConstants.CSRF_TOKEN_COOKIE:",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "CatalystCredential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class CatalystCredential(Credential):\n    def __init__(self, user: str = None):\n        super().__init__()\n        thread_obj = ZCThreadUtil()\n        self._admin_cred: Union[AccessTokenCredential, TicketCredential] = None\n        self._user_cred: Union[AccessTokenCredential, TicketCredential, CookieCredential] = None\n        self._admin_token: str = thread_obj.get_value(APIConstants.ADMIN_CRED)\n        self._user_token: str = thread_obj.get_value(APIConstants.CLIENT_CRED)\n        self._cookie: str = thread_obj.get_value(APIConstants.COOKIE_CRED)\n        self._admin_cred_type = thread_obj.get_value(APIConstants.ADMIN_CRED_TYPE)",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ApplicationDefaultCredential",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "class ApplicationDefaultCredential(Credential):\n    def __init__(self):\n        super().__init__()\n        self._credential_obj = None\n        self._credential: Union[\n            AccessTokenCredential,\n            TicketCredential,\n            RefreshTokenCredential\n        ] = None\n        # load credentials from environment",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_CATALYST_AUTH_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "_CATALYST_AUTH_ENV_KEY = 'CATALYST_AUTH'\n_JWT_TOKEN_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.JWT_TOKEN,\n    APIConstants.SCOPES\n]\n_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_JWT_TOKEN_KEYS",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "_JWT_TOKEN_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.JWT_TOKEN,\n    APIConstants.SCOPES\n]\n_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN\n]",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_REFRESH_OBJ_KEYS",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN\n]\n_CATALYST_SCOPES = ['admin', 'user']\n_PORTAL_ID=os.getenv('CATALYST_PORTAL_DOMAIN')\nICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_CATALYST_SCOPES",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "_CATALYST_SCOPES = ['admin', 'user']\n_PORTAL_ID=os.getenv('CATALYST_PORTAL_DOMAIN')\nICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],\n    'jwt_token': str\n})\nICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystJwtObj",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],\n    'jwt_token': str\n})\nICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,\n    'refresh_token': str\n})",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystRefreshObj",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,\n    'refresh_token': str\n})\nICatalystTokenObj = TypedDict('ICatalystTokenObj', {\n    'access_token': str\n})\nICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystTokenObj",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystTokenObj = TypedDict('ICatalystTokenObj', {\n    'access_token': str\n})\nICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str\n})\n# Credential class for all credentials\nclass Credential(ABC):\n    @abstractmethod\n    def token(self):",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystTicketObj",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.credentials",
        "description": ".build.functions.school.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str\n})\n# Credential class for all credentials\nclass Credential(ABC):\n    @abstractmethod\n    def token(self):\n        pass\n    def _switch_user(self, user=None):  # pylint: disable=unused-argument\n        return None",
        "detail": ".build.functions.school.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystCronReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.cron",
        "description": ".build.functions.school.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronReq(ICatalystCron):\n    pass\nclass ICatalystCronUpdateReq(ICatalystCron):\n    id: str  # pylint: disable=invalid-name\nclass ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:",
        "detail": ".build.functions.school.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystCronUpdateReq",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.cron",
        "description": ".build.functions.school.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronUpdateReq(ICatalystCron):\n    id: str  # pylint: disable=invalid-name\nclass ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)",
        "detail": ".build.functions.school.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystCronRes",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.cron",
        "description": ".build.functions.school.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CRON",
        "detail": ".build.functions.school.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "Cron",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.cron",
        "description": ".build.functions.school.zcatalyst_sdk.cron",
        "peekOfCode": "class Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CRON\n    def get_all_cron(self) -> List[ICatalystCronRes]:\n        resp = self._requester.request(\n            method=RequestMethod.GET,\n            path='/cron',",
        "detail": ".build.functions.school.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystMailResp",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.email",
        "description": ".build.functions.school.zcatalyst_sdk.email",
        "peekOfCode": "class ICatalystMailResp(ICatalystMail):\n    project_details: Optional[ICatalystProject]\nclass Email(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.MAIL\n    def send_mail(self, mail_obj: ICatalystMail) -> ICatalystMailResp:\n        validator.is_non_empty_dict(mail_obj, 'mail_obj', CatalystMailError)",
        "detail": ".build.functions.school.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "Email",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.email",
        "description": ".build.functions.school.zcatalyst_sdk.email",
        "peekOfCode": "class Email(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.MAIL\n    def send_mail(self, mail_obj: ICatalystMail) -> ICatalystMailResp:\n        validator.is_non_empty_dict(mail_obj, 'mail_obj', CatalystMailError)\n        mail_data = self._generate_data(mail_obj)\n        resp = self._requester.request(",
        "detail": ".build.functions.school.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "_MAIL_OBJ_DICT",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.email",
        "description": ".build.functions.school.zcatalyst_sdk.email",
        "peekOfCode": "_MAIL_OBJ_DICT = {\n    'from_email': str,\n    'to_email': list,\n    'subject': str,\n    'content': str,\n    'cc': list,\n    'bcc': list,\n    'reply_to': list,\n    'html_mode': bool,\n    'display_name': str,",
        "detail": ".build.functions.school.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "CatalystError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystError(Exception):\n    def __init__(self, code, message, value=None, status_code = None):\n        self._code = code\n        self._message = message\n        self._http_status_code = status_code\n        self._value = value\n        Exception.__init__(self, self.to_string())\n    @property\n    def code(self):\n        return self._code",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCredentialError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCredentialError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAppError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAppError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAppError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)\n    @property\n    def status_code(self):\n        return self.http_status_code",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAPIError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)\n    @property\n    def status_code(self):\n        return self.http_status_code\nclass CatalystCacheError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCacheError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCacheError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDatastoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystDatastoreError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystDatastoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystFunctionError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystMailError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystFilestoreError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAuthenticationError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystZCQLError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCronError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCircuitError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystConnectorError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystPushNotificationError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystSearchError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystZiaError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "BrowserLogicError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "QuickMLError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystStratusError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystPipelineError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystNoSqlError",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystDeprecationWarning",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.exceptions",
        "description": ".build.functions.school.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.school.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "Functions",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.functions",
        "description": ".build.functions.school.zcatalyst_sdk.functions",
        "peekOfCode": "class Functions(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.FUNCTION\n    def execute(self, func_id: Union[str, int], args: Dict = None):\n        validator.is_non_empty_string_or_number(func_id, 'func_id', CatalystFunctionError)\n        if args is not None and not isinstance(args, dict):\n            raise CatalystFunctionError(",
        "detail": ".build.functions.school.zcatalyst_sdk.functions",
        "documentation": {}
    },
    {
        "label": "LogLevel",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.logger",
        "description": ".build.functions.school.zcatalyst_sdk.logger",
        "peekOfCode": "class LogLevel:\n    DEBUG = 10\n    INFO = 20\n    WARNING = 30\n    ERROR = 40\n    CRITICAL = 50\n    LEVELS = {\n        DEBUG: 'DEBUG',\n        INFO: 'INFO',\n        WARNING: 'WARNING',",
        "detail": ".build.functions.school.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.logger",
        "description": ".build.functions.school.zcatalyst_sdk.logger",
        "peekOfCode": "class Logger:\n    def __init__(self,\n        name: str = None,\n        log_level=LogLevel.WARNING,\n        log_format='{timestamp} [{level}] {message}'\n    ):\n        self.name = name\n        self.log_level = log_level\n        self.log_format = log_format\n    def set_level(self, level: int):",
        "detail": ".build.functions.school.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.logger",
        "description": ".build.functions.school.zcatalyst_sdk.logger",
        "peekOfCode": "def get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.school.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "_global_logger",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.logger",
        "description": ".build.functions.school.zcatalyst_sdk.logger",
        "peekOfCode": "_global_logger = Logger()\n_logger_registry = {}\ndef get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.school.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "_logger_registry",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.logger",
        "description": ".build.functions.school.zcatalyst_sdk.logger",
        "peekOfCode": "_logger_registry = {}\ndef get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.school.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.pipeline",
        "description": ".build.functions.school.zcatalyst_sdk.pipeline",
        "peekOfCode": "class Pipeline(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.PIPELINE\n    def get_pipeline_details(self, pipeline_id: str) -> PipelineDetails:\n        \"\"\"Get the details of the pipelines.\n        Args:\n            pipeline_id (str): Id to get the details of the pipeline.",
        "detail": ".build.functions.school.zcatalyst_sdk.pipeline",
        "documentation": {}
    },
    {
        "label": "QuickML",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.quick_ml",
        "description": ".build.functions.school.zcatalyst_sdk.quick_ml",
        "peekOfCode": "class QuickML(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.QUICK_ML\n    def predict(\n        self,\n        end_point_key: str,\n        input_data: Dict[str,Union[str, int]]",
        "detail": ".build.functions.school.zcatalyst_sdk.quick_ml",
        "documentation": {}
    },
    {
        "label": "Search",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.search",
        "description": ".build.functions.school.zcatalyst_sdk.search",
        "peekOfCode": "class Search(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.SEARCH\n    def execute_search_query(\n        self,\n        query: ICatalystSearchQuery\n    ) -> Dict[str, List[Dict[str, Any]]]:",
        "detail": ".build.functions.school.zcatalyst_sdk.search",
        "documentation": {}
    },
    {
        "label": "SmartBrowz",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.smart_browz",
        "description": ".build.functions.school.zcatalyst_sdk.smart_browz",
        "peekOfCode": "class SmartBrowz(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.SMART_BROWZ\n    def convert_to_pdf(\n        self,\n        source: str,\n        pdf_options: PdfOptions  = None,",
        "detail": ".build.functions.school.zcatalyst_sdk.smart_browz",
        "documentation": {}
    },
    {
        "label": "is_valid_email",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_valid_email(email):\n    \"\"\"\n    validates the given value is a email\n    Args:\n        email: The value to validate.\n    Returns:\n        bool: Whether the value is a valid email or not.\n    \"\"\"\n    regex = r'^[^@]+@[^@]+$'\n    if re.fullmatch(regex, email):",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_bool",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_bool(value):\n    \"\"\"\n    validates the given value is a boolean\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a boolean or not.\n    \"\"\"\n    return isinstance(value, bool)\ndef _is_number(value):",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_string",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_string(value):\n    \"\"\"\n    validates the given value is a string\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a string or not.\n    \"\"\"\n    return isinstance(value, str)\ndef is_list(value):",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_list",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_list(value):\n    \"\"\"\n    validates the given value is a list\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a list or not.\n    \"\"\"\n    return isinstance(value, list)\ndef is_dict(value):",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_dict",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_dict(value):\n    \"\"\"\n    validates the given value is a dict\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a dict or not.\n    \"\"\"\n    return isinstance(value, dict)\ndef is_set(value):",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_set",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_set(value):\n    \"\"\"\n    validates the given value is a set\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a set or not.\n    \"\"\"\n    return isinstance(value, set)\ndef is_tuple(value):",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_tuple",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_tuple(value):\n    \"\"\"\n    validates the given value is a tuple\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a tuple or not.\n    \"\"\"\n    return isinstance(value, tuple)\ndef is_buffered_reader(value):",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_buffered_reader",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_buffered_reader(value):\n    \"\"\"\n    validates the given value is a buffered reader or not\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a buffered reader or not.\n    \"\"\"\n    return isinstance(value, BufferedReader)\ndef is_non_empty_string(",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_string",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_string(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty string\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_string_or_number",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_string_or_number(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty string or number\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_parsable_number",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_parsable_number(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a parsable number\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_parsable_integer",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_parsable_integer(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a parsable integer\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_list",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_list(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty list\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_tuple",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_tuple(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty tuple\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_dict",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_dict(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty dict\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_keys_present",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_keys_present(\n    obj: dict,\n    keys: List[str],\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates a dict has given keys. Note: single level\n    Args:\n        obj: The obj to validate.",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_deprecated_key_present",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_deprecated_key_present(\n    obj: dict,\n    depkey: str,\n    actkey: Optional[str] = None,\n    delet : bool = False,\n    warn: bool = False\n):\n    \"\"\"\n    validates a dict has deprecated key. Note: single level\n    Args:",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_valid_url",
        "kind": 2,
        "importPath": ".build.functions.school.zcatalyst_sdk.validator",
        "description": ".build.functions.school.zcatalyst_sdk.validator",
        "peekOfCode": "def is_valid_url(url):\n    \"\"\"\n    validates the given value is a valid url\n    Args:\n        email: The value to validate.\n    Returns:\n        bool: Whether the value is a valid url or not.\n    \"\"\"\n    regex = \"\"\"^https?:\\\\/\\\\/(?:www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\n            \\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)$\"\"\"",
        "detail": ".build.functions.school.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "Zcql",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.zcql",
        "description": ".build.functions.school.zcatalyst_sdk.zcql",
        "peekOfCode": "class Zcql(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.ZCQL\n    def execute_query(self, query: str) -> List[ZcqlQueryOutput]:\n        if not query or not isinstance(query, str):\n            raise CatalystZCQLError(\n                'INVALID_QUERY',",
        "detail": ".build.functions.school.zcatalyst_sdk.zcql",
        "documentation": {}
    },
    {
        "label": "ZcqlQueryOutput",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.zcql",
        "description": ".build.functions.school.zcatalyst_sdk.zcql",
        "peekOfCode": "ZcqlQueryOutput = TypedDict('ZcqlQueryOutput', {'table_name': Dict})\nclass Zcql(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.ZCQL\n    def execute_query(self, query: str) -> List[ZcqlQueryOutput]:\n        if not query or not isinstance(query, str):\n            raise CatalystZCQLError(",
        "detail": ".build.functions.school.zcatalyst_sdk.zcql",
        "documentation": {}
    },
    {
        "label": "Zia",
        "kind": 6,
        "importPath": ".build.functions.school.zcatalyst_sdk.zia",
        "description": ".build.functions.school.zcatalyst_sdk.zia",
        "peekOfCode": "class Zia(Component):\n    def __init__(self, app):\n        self._app = app\n        self._requester = AuthorizedHttpClient(app)\n    def get_component_name(self):\n        return Components.ZIA\n    def detect_object(self, file: BufferedReader) -> ICatalystZiaObject:\n        self._is_valid_file_type(file)\n        resp = self._requester.request(\n            method=RequestMethod.POST,",
        "detail": ".build.functions.school.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystOCROptions",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.zia",
        "description": ".build.functions.school.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystOCROptions = TypedDict(\n    \"ICatalystOCROptions\",\n    {\"language\": Optional[str], \"model_type\": Optional[str]},\n    total=False,\n)\nICatalystBarCodeOptions = TypedDict(\n    \"ICatalystBarCodeOptions\", {\"format\": Optional[str]}\n)\nICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}",
        "detail": ".build.functions.school.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystBarCodeOptions",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.zia",
        "description": ".build.functions.school.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystBarCodeOptions = TypedDict(\n    \"ICatalystBarCodeOptions\", {\"format\": Optional[str]}\n)\nICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}\n)\nICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],",
        "detail": ".build.functions.school.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystImageModerationOpts",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.zia",
        "description": ".build.functions.school.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}\n)\nICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],\n        \"emotion\": Optional[bool],\n        \"age\": Optional[bool],\n        \"gender\": Optional[bool],",
        "detail": ".build.functions.school.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystFaceAnalysisOptions",
        "kind": 5,
        "importPath": ".build.functions.school.zcatalyst_sdk.zia",
        "description": ".build.functions.school.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],\n        \"emotion\": Optional[bool],\n        \"age\": Optional[bool],\n        \"gender\": Optional[bool],\n    },\n    total=False,\n)",
        "detail": ".build.functions.school.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "getSchoolForLogin",
        "kind": 2,
        "importPath": ".build.functions.school.main",
        "description": ".build.functions.school.main",
        "peekOfCode": "def getSchoolForLogin(id, password, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_id = '{id}' AND school_password = '{password}'\"\n    output = zcql_service.execute_query(query)\n    return output\ndef getSchoolForSignUp(name, address, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_name = '{name}' AND school_address = '{address}'\"\n    output = zcql_service.execute_query(query)\n    return output",
        "detail": ".build.functions.school.main",
        "documentation": {}
    },
    {
        "label": "getSchoolForSignUp",
        "kind": 2,
        "importPath": ".build.functions.school.main",
        "description": ".build.functions.school.main",
        "peekOfCode": "def getSchoolForSignUp(name, address, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_name = '{name}' AND school_address = '{address}'\"\n    output = zcql_service.execute_query(query)\n    return output\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        body = request.get_json()\n        school = body.get('school')",
        "detail": ".build.functions.school.main",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": ".build.functions.school.main",
        "description": ".build.functions.school.main",
        "peekOfCode": "def handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        body = request.get_json()\n        school = body.get('school')\n        print(school)\n        if not school:\n            return make_response(jsonify({\n                \"error\": \"school object is missing\"\n            }), 400)",
        "detail": ".build.functions.school.main",
        "documentation": {}
    },
    {
        "label": "tableName",
        "kind": 5,
        "importPath": ".build.functions.school.main",
        "description": ".build.functions.school.main",
        "peekOfCode": "tableName = \"schools\"\ndef getSchoolForLogin(id, password, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_id = '{id}' AND school_password = '{password}'\"\n    output = zcql_service.execute_query(query)\n    return output\ndef getSchoolForSignUp(name, address, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_name = '{name}' AND school_address = '{address}'\"\n    output = zcql_service.execute_query(query)",
        "detail": ".build.functions.school.main",
        "documentation": {}
    },
    {
        "label": "_Sentinel",
        "kind": 6,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "class _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(\n            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)\n        )\nelif sys.version_info >= (3, 9):",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_ExtensionsSpecialForm",
        "kind": 6,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):\n    def __repr__(self):\n        return 'typing_extensions.' + self._name\nFinal = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.\n    # See https://bugs.python.org/issue46342",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_DefaultMixin",
        "kind": 6,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "class _DefaultMixin:\n    \"\"\"Mixin for TypeVarLike defaults.\"\"\"\n    __slots__ = ()\n    __init__ = _set_default\n# Classes using this metaclass must provide a _backported_typevarlike ClassVar\nclass _TypeVarLikeMeta(type):\n    def __instancecheck__(cls, __instance: Any) -> bool:\n        return isinstance(__instance, cls._backported_typevarlike)\nif _PEP_696_IMPLEMENTED:\n    from typing import TypeVar",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_TypeVarLikeMeta",
        "kind": 6,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "class _TypeVarLikeMeta(type):\n    def __instancecheck__(cls, __instance: Any) -> bool:\n        return isinstance(__instance, cls._backported_typevarlike)\nif _PEP_696_IMPLEMENTED:\n    from typing import TypeVar\nelse:\n    # Add default and infer_variance parameters from PEP 696 and 695\n    class TypeVar(metaclass=_TypeVarLikeMeta):\n        \"\"\"Type variable.\"\"\"\n        _backported_typevarlike = typing.TypeVar",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_SpecialForm",
        "kind": 6,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "class _SpecialForm(typing._Final, _root=True):\n    __slots__ = ('_name', '__doc__', '_getitem')\n    def __init__(self, getitem):\n        self._getitem = getitem\n        self._name = getitem.__name__\n        self.__doc__ = getitem.__doc__\n    def __getattr__(self, item):\n        if item in {'__name__', '__qualname__'}:\n            return self._name\n        raise AttributeError(item)",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "IntVar",
        "kind": 2,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "def IntVar(name):\n    return typing.TypeVar(name)\n# A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8\nif sys.version_info >= (3, 10, 1):\n    Literal = typing.Literal\nelse:\n    def _flatten_literal_params(parameters):\n        \"\"\"An internal helper for Literal creation: flatten Literals among parameters\"\"\"\n        params = []\n        for p in parameters:",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "__all__ = [\n    # Super-special typing primitives.\n    'Any',\n    'ClassVar',\n    'Concatenate',\n    'Final',\n    'LiteralString',\n    'ParamSpec',\n    'ParamSpecArgs',\n    'ParamSpecKwargs',",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "PEP_560",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "PEP_560 = True\nGenericMeta = type\n_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "GenericMeta",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "GenericMeta = type\n_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PEP_696_IMPLEMENTED",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_marker",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(\n            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)\n        )\nelif sys.version_info >= (3, 9):\n    def _should_collect_from_parameters(t):\n        return isinstance(t, (typing._GenericAlias, _types.GenericAlias))\nelse:",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "NoReturn = typing.NoReturn\n# Some unconstrained type variables.  These are used by the container types.\n# (These are not for export.)\nT = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "T = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "KT",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "KT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "VT",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "VT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_co",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "T_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_contra",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "T_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)\n        def __repr__(self):",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "ClassVar = typing.ClassVar\nclass _ExtensionsSpecialForm(typing._SpecialForm, _root=True):\n    def __repr__(self):\n        return 'typing_extensions.' + self._name\nFinal = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Final",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Final = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.\n    # See https://bugs.python.org/issue46342\n    def final(f):\n        \"\"\"This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_overload_dummy",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_overload_dummy = typing._overload_dummy\nif hasattr(typing, \"get_overloads\"):  # 3.11+\n    overload = typing.overload\n    get_overloads = typing.get_overloads\n    clear_overloads = typing.clear_overloads\nelse:\n    # {module: {qualname: {firstlineno: func}}}\n    _overload_registry = collections.defaultdict(\n        functools.partial(collections.defaultdict, dict)\n    )",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Type",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Type = typing.Type\n# Various ABCs mimicking those in collections.abc.\n# A few are simply re-exported for completeness.\nAwaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Awaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Coroutine",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Coroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterable",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "AsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "AsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Deque",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Deque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "DefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "OrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Counter",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Counter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "ChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Text",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Text = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(\n        typing, \"_SpecialGenericAlias\", typing._GenericAlias",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "TYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(\n        typing, \"_SpecialGenericAlias\", typing._GenericAlias\n    )",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PROTO_ALLOWLIST",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_PROTO_ALLOWLIST = {\n    'collections.abc': [\n        'Callable', 'Awaitable', 'Iterable', 'Iterator', 'AsyncIterable',\n        'Hashable', 'Sized', 'Container', 'Collection', 'Reversible', 'Buffer',\n    ],\n    'contextlib': ['AbstractContextManager', 'AbstractAsyncContextManager'],\n    'typing_extensions': ['Buffer'],\n}\n_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {\n    \"__match_args__\", \"__protocol_attrs__\", \"__non_callable_proto_members__\",",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_EXCLUDED_ATTRS",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {\n    \"__match_args__\", \"__protocol_attrs__\", \"__non_callable_proto_members__\",\n    \"__final__\",\n}\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object\n        if base.__name__ in {'Protocol', 'Generic'}:\n            continue\n        annotations = getattr(base, '__annotations__', {})",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "runtime",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "runtime = runtime_checkable\n# Our version of runtime-checkable protocols is faster on Python 3.8-3.11\nif sys.version_info >= (3, 12):\n    SupportsInt = typing.SupportsInt\n    SupportsFloat = typing.SupportsFloat\n    SupportsComplex = typing.SupportsComplex\n    SupportsBytes = typing.SupportsBytes\n    SupportsIndex = typing.SupportsIndex\n    SupportsAbs = typing.SupportsAbs\n    SupportsRound = typing.SupportsRound",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PEP_728_IMPLEMENTED",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_PEP_728_IMPLEMENTED = False\nif _PEP_728_IMPLEMENTED:\n    # The standard library TypedDict in Python 3.8 does not store runtime information\n    # about which (if any) keys are optional.  See https://bugs.python.org/issue38834\n    # The standard library TypedDict in Python 3.9.0/1 does not honour the \"total\"\n    # keyword with old-style TypedDict().  See https://bugs.python.org/issue42059\n    # The standard library TypedDict below Python 3.11 does not store runtime\n    # information about optional and required keys when using Required or NotRequired.\n    # Generic TypedDicts are also impossible using typing.TypedDict on Python <3.11.\n    # Aaaand on 3.12 we add __orig_bases__ to TypedDict",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_UNPACK_DOC",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_UNPACK_DOC = \"\"\"\\\nType unpack operator.\nThe type unpack operator takes the child types from some container type,\nsuch as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For\nexample:\n  # For some generic class `Foo`:\n  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]\n  Ts = TypeVarTuple('Ts')\n  # Specifies that `Bar` is generic in an arbitrary number of types.\n  # (Think of `Ts` as a tuple of an arbitrary number of individual",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_TYPEVARTUPLE_TYPES",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_TYPEVARTUPLE_TYPES = {TypeVarTuple, getattr(typing, \"TypeVarTuple\", None)}\ndef _is_unpacked_typevartuple(x) -> bool:\n    if get_origin(x) is not Unpack:\n        return False\n    args = get_args(x)\n    return (\n        bool(args)\n        and len(args) == 1\n        and type(args[0]) in _TYPEVARTUPLE_TYPES\n    )",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_CapsuleType",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "_CapsuleType = getattr(_types, \"CapsuleType\", None)\nif _CapsuleType is None:\n    try:\n        import _socket\n    except ImportError:\n        pass\n    else:\n        _CAPI = getattr(_socket, \"CAPI\", None)\n        if _CAPI is not None:\n            _CapsuleType = type(_CAPI)",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "AbstractSet = typing.AbstractSet\nAnyStr = typing.AnyStr\nBinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "AnyStr = typing.AnyStr\nBinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "BinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Callable",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Callable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Collection",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Collection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Container = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Dict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ForwardRef",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "ForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "FrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Generic",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Generic = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Hashable",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Hashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "IO",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "IO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ItemsView",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "ItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Iterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Iterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "KeysView",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "KeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "List = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Mapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MappingView",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "MappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Match = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "MutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "MutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "MutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Optional",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Optional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Pattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Reversible",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Reversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Sequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Set = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Sized",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Sized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "TextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Tuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Union",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "Union = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "ValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "cast",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "cast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "no_type_check",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "no_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "no_type_check_decorator",
        "kind": 5,
        "importPath": ".build.functions.school.typing_extensions",
        "description": ".build.functions.school.typing_extensions",
        "peekOfCode": "no_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.school.typing_extensions",
        "documentation": {}
    },
    {
        "label": "exit_cacert_ctx",
        "kind": 2,
        "importPath": ".build.functions.students.certifi.core",
        "description": ".build.functions.students.certifi.core",
        "peekOfCode": "def exit_cacert_ctx() -> None:\n    _CACERT_CTX.__exit__(None, None, None)  # type: ignore[union-attr]\nif sys.version_info >= (3, 11):\n    from importlib.resources import as_file, files\n    _CACERT_CTX = None\n    _CACERT_PATH = None\n    def where() -> str:\n        # This is slightly terrible, but we want to delay extracting the file\n        # in cases where we're inside of a zipimport situation until someone\n        # actually calls where(), but we don't want to re-extract the file",
        "detail": ".build.functions.students.certifi.core",
        "documentation": {}
    },
    {
        "label": "from_bytes",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.api",
        "description": ".build.functions.students.charset_normalizer.api",
        "peekOfCode": "def from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.students.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "from_fp",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.api",
        "description": ".build.functions.students.charset_normalizer.api",
        "peekOfCode": "def from_fp(\n    fp: BinaryIO,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.students.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "from_path",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.api",
        "description": ".build.functions.students.charset_normalizer.api",
        "peekOfCode": "def from_path(\n    path: str | bytes | PathLike,  # type: ignore[type-arg]\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.students.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "is_binary",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.api",
        "description": ".build.functions.students.charset_normalizer.api",
        "peekOfCode": "def is_binary(\n    fp_or_path_or_payload: PathLike | str | BinaryIO | bytes,  # type: ignore[type-arg]\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.20,\n    cp_isolation: list[str] | None = None,\n    cp_exclusion: list[str] | None = None,\n    preemptive_behaviour: bool = True,\n    explain: bool = False,\n    language_threshold: float = 0.1,",
        "detail": ".build.functions.students.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.api",
        "description": ".build.functions.students.charset_normalizer.api",
        "peekOfCode": "logger = logging.getLogger(\"charset_normalizer\")\nexplain_handler = logging.StreamHandler()\nexplain_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s | %(levelname)s | %(message)s\")\n)\ndef from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,",
        "detail": ".build.functions.students.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "explain_handler",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.api",
        "description": ".build.functions.students.charset_normalizer.api",
        "peekOfCode": "explain_handler = logging.StreamHandler()\nexplain_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s | %(levelname)s | %(message)s\")\n)\ndef from_bytes(\n    sequences: bytes | bytearray,\n    steps: int = 5,\n    chunk_size: int = 512,\n    threshold: float = 0.2,\n    cp_isolation: list[str] | None = None,",
        "detail": ".build.functions.students.charset_normalizer.api",
        "documentation": {}
    },
    {
        "label": "encoding_unicode_range",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def encoding_unicode_range(iana_name: str) -> list[str]:\n    \"\"\"\n    Return associated unicode ranges in a single byte code page.\n    \"\"\"\n    if is_multi_byte_encoding(iana_name):\n        raise OSError(\"Function not supported on multi-byte code page\")\n    decoder = importlib.import_module(f\"encodings.{iana_name}\").IncrementalDecoder\n    p: IncrementalDecoder = decoder(errors=\"ignore\")\n    seen_ranges: dict[str, int] = {}\n    character_count: int = 0",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "unicode_range_languages",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def unicode_range_languages(primary_range: str) -> list[str]:\n    \"\"\"\n    Return inferred languages used with a unicode range.\n    \"\"\"\n    languages: list[str] = []\n    for language, characters in FREQUENCIES.items():\n        for character in characters:\n            if unicode_range(character) == primary_range:\n                languages.append(language)\n                break",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "encoding_languages",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def encoding_languages(iana_name: str) -> list[str]:\n    \"\"\"\n    Single-byte encoding language association. Some code page are heavily linked to particular language(s).\n    This function does the correspondence.\n    \"\"\"\n    unicode_ranges: list[str] = encoding_unicode_range(iana_name)\n    primary_range: str | None = None\n    for specified_range in unicode_ranges:\n        if \"Latin\" not in specified_range:\n            primary_range = specified_range",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "mb_encoding_languages",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def mb_encoding_languages(iana_name: str) -> list[str]:\n    \"\"\"\n    Multi-byte encoding language association. Some code page are heavily linked to particular language(s).\n    This function does the correspondence.\n    \"\"\"\n    if (\n        iana_name.startswith(\"shift_\")\n        or iana_name.startswith(\"iso2022_jp\")\n        or iana_name.startswith(\"euc_j\")\n        or iana_name == \"cp932\"",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "get_target_features",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def get_target_features(language: str) -> tuple[bool, bool]:\n    \"\"\"\n    Determine main aspects from a supported language if it contains accents and if is pure Latin.\n    \"\"\"\n    target_have_accents: bool = False\n    target_pure_latin: bool = True\n    for character in FREQUENCIES[language]:\n        if not target_have_accents and is_accentuated(character):\n            target_have_accents = True\n        if target_pure_latin and is_latin(character) is False:",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "alphabet_languages",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def alphabet_languages(\n    characters: list[str], ignore_non_latin: bool = False\n) -> list[str]:\n    \"\"\"\n    Return associated languages associated to given characters.\n    \"\"\"\n    languages: list[tuple[str, float]] = []\n    source_have_accents = any(is_accentuated(character) for character in characters)\n    for language, language_characters in FREQUENCIES.items():\n        target_have_accents, target_pure_latin = get_target_features(language)",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "characters_popularity_compare",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def characters_popularity_compare(\n    language: str, ordered_characters: list[str]\n) -> float:\n    \"\"\"\n    Determine if a ordered characters list (by occurrence from most appearance to rarest) match a particular language.\n    The result is a ratio between 0. (absolutely no correspondence) and 1. (near perfect fit).\n    Beware that is function is not strict on the match in order to ease the detection. (Meaning close match is 1.)\n    \"\"\"\n    if language not in FREQUENCIES:\n        raise ValueError(f\"{language} not available\")",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "alpha_unicode_split",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def alpha_unicode_split(decoded_sequence: str) -> list[str]:\n    \"\"\"\n    Given a decoded text sequence, return a list of str. Unicode range / alphabet separation.\n    Ex. a text containing English/Latin with a bit a Hebrew will return two items in the resulting list;\n    One containing the latin letters and the other hebrew.\n    \"\"\"\n    layers: dict[str, str] = {}\n    for character in decoded_sequence:\n        if character.isalpha() is False:\n            continue",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "merge_coherence_ratios",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def merge_coherence_ratios(results: list[CoherenceMatches]) -> CoherenceMatches:\n    \"\"\"\n    This function merge results previously given by the function coherence_ratio.\n    The return type is the same as coherence_ratio.\n    \"\"\"\n    per_language_ratios: dict[str, list[float]] = {}\n    for result in results:\n        for sub_result in result:\n            language, ratio = sub_result\n            if language not in per_language_ratios:",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "filter_alt_coherence_matches",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def filter_alt_coherence_matches(results: CoherenceMatches) -> CoherenceMatches:\n    \"\"\"\n    We shall NOT return \"English\" in CoherenceMatches because it is an alternative\n    of \"English\". This function only keeps the best match and remove the em-dash in it.\n    \"\"\"\n    index_results: dict[str, list[float]] = dict()\n    for result in results:\n        language, ratio = result\n        no_em_name: str = language.replace(\"\", \"\")\n        if no_em_name not in index_results:",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "coherence_ratio",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.cd",
        "description": ".build.functions.students.charset_normalizer.cd",
        "peekOfCode": "def coherence_ratio(\n    decoded_sequence: str, threshold: float = 0.1, lg_inclusion: str | None = None\n) -> CoherenceMatches:\n    \"\"\"\n    Detect ANY language that can be identified in given sequence. The sequence will be analysed by layers.\n    A layer = Character extraction by alphabets/ranges.\n    \"\"\"\n    results: list[tuple[str, float]] = []\n    ignore_non_latin: bool = False\n    sufficient_match_count: int = 0",
        "detail": ".build.functions.students.charset_normalizer.cd",
        "documentation": {}
    },
    {
        "label": "RE_POSSIBLE_ENCODING_INDICATION",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.constant",
        "description": ".build.functions.students.charset_normalizer.constant",
        "peekOfCode": "RE_POSSIBLE_ENCODING_INDICATION = re_compile(\n    r\"(?:(?:encoding)|(?:charset)|(?:coding))(?:[\\:= ]{1,10})(?:[\\\"\\']?)([a-zA-Z0-9\\-_]+)(?:[\\\"\\']?)\",\n    IGNORECASE,\n)\nIANA_NO_ALIASES = [\n    \"cp720\",\n    \"cp737\",\n    \"cp856\",\n    \"cp874\",\n    \"cp875\",",
        "detail": ".build.functions.students.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "IANA_NO_ALIASES",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.constant",
        "description": ".build.functions.students.charset_normalizer.constant",
        "peekOfCode": "IANA_NO_ALIASES = [\n    \"cp720\",\n    \"cp737\",\n    \"cp856\",\n    \"cp874\",\n    \"cp875\",\n    \"cp1006\",\n    \"koi8_r\",\n    \"koi8_t\",\n    \"koi8_u\",",
        "detail": ".build.functions.students.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_CHINESE_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.constant",
        "description": ".build.functions.students.charset_normalizer.constant",
        "peekOfCode": "COMMON_CHINESE_CHARACTERS = \"\"\nCOMMON_JAPANESE_CHARACTERS = \"\"\nCOMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,",
        "detail": ".build.functions.students.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_JAPANESE_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.constant",
        "description": ".build.functions.students.charset_normalizer.constant",
        "peekOfCode": "COMMON_JAPANESE_CHARACTERS = \"\"\nCOMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]",
        "detail": ".build.functions.students.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_KOREAN_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.constant",
        "description": ".build.functions.students.charset_normalizer.constant",
        "peekOfCode": "COMMON_KOREAN_CHARACTERS = \"\"\n# Combine all into a set\nCOMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]\n    )",
        "detail": ".build.functions.students.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "COMMON_CJK_CHARACTERS",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.constant",
        "description": ".build.functions.students.charset_normalizer.constant",
        "peekOfCode": "COMMON_CJK_CHARACTERS = set(\n    \"\".join(\n        [\n            COMMON_CHINESE_CHARACTERS,\n            COMMON_JAPANESE_CHARACTERS,\n            COMMON_KOREAN_CHARACTERS,\n        ]\n    )\n)\nKO_NAMES: set[str] = {\"johab\", \"cp949\", \"euc_kr\"}",
        "detail": ".build.functions.students.charset_normalizer.constant",
        "documentation": {}
    },
    {
        "label": "detect",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.legacy",
        "description": ".build.functions.students.charset_normalizer.legacy",
        "peekOfCode": "def detect(\n    byte_str: bytes, should_rename_legacy: bool = False, **kwargs: Any\n) -> ResultDict:\n    \"\"\"\n    chardet legacy method\n    Detect the encoding of the given byte string. It should be mostly backward-compatible.\n    Encoding name will match Chardet own writing whenever possible. (Not on encoding name unsupported by it)\n    This function is deprecated and should be used to migrate your project easily, consult the documentation for\n    further information. Not planned for removal.\n    :param byte_str:     The byte sequence to examine.",
        "detail": ".build.functions.students.charset_normalizer.legacy",
        "documentation": {}
    },
    {
        "label": "MessDetectorPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class MessDetectorPlugin:\n    \"\"\"\n    Base abstract class used for mess detection plugins.\n    All detectors MUST extend and implement given methods.\n    \"\"\"\n    def eligible(self, character: str) -> bool:\n        \"\"\"\n        Determine if given character should be fed in.\n        \"\"\"\n        raise NotImplementedError  # pragma: nocover",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "TooManySymbolOrPunctuationPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class TooManySymbolOrPunctuationPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._punctuation_count: int = 0\n        self._symbol_count: int = 0\n        self._character_count: int = 0\n        self._last_printable_char: str | None = None\n        self._frenzy_symbol_in_word: bool = False\n    def eligible(self, character: str) -> bool:\n        return character.isprintable()\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "TooManyAccentuatedPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class TooManyAccentuatedPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._accentuated_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return character.isalpha()\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if is_accentuated(character):\n            self._accentuated_count += 1",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "UnprintablePlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class UnprintablePlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._unprintable_count: int = 0\n        self._character_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return True\n    def feed(self, character: str) -> None:\n        if is_unprintable(character):\n            self._unprintable_count += 1\n        self._character_count += 1",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuspiciousDuplicateAccentPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class SuspiciousDuplicateAccentPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._successive_count: int = 0\n        self._character_count: int = 0\n        self._last_latin_character: str | None = None\n    def eligible(self, character: str) -> bool:\n        return character.isalpha() and is_latin(character)\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if (",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuspiciousRange",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class SuspiciousRange(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._suspicious_successive_range_count: int = 0\n        self._character_count: int = 0\n        self._last_printable_seen: str | None = None\n    def eligible(self, character: str) -> bool:\n        return character.isprintable()\n    def feed(self, character: str) -> None:\n        self._character_count += 1\n        if (",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "SuperWeirdWordPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class SuperWeirdWordPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._word_count: int = 0\n        self._bad_word_count: int = 0\n        self._foreign_long_count: int = 0\n        self._is_current_word_bad: bool = False\n        self._foreign_long_watch: bool = False\n        self._character_count: int = 0\n        self._bad_character_count: int = 0\n        self._buffer: str = \"\"",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "CjkUncommonPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class CjkUncommonPlugin(MessDetectorPlugin):\n    \"\"\"\n    Detect messy CJK text that probably means nothing.\n    \"\"\"\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._uncommon_count: int = 0\n    def eligible(self, character: str) -> bool:\n        return is_cjk(character)\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "ArchaicUpperLowerPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class ArchaicUpperLowerPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._buf: bool = False\n        self._character_count_since_last_sep: int = 0\n        self._successive_upper_lower_count: int = 0\n        self._successive_upper_lower_count_final: int = 0\n        self._character_count: int = 0\n        self._last_alpha_seen: str | None = None\n        self._current_ascii_only: bool = True\n    def eligible(self, character: str) -> bool:",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "ArabicIsolatedFormPlugin",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "class ArabicIsolatedFormPlugin(MessDetectorPlugin):\n    def __init__(self) -> None:\n        self._character_count: int = 0\n        self._isolated_form_count: int = 0\n    def reset(self) -> None:  # Abstract\n        self._character_count = 0\n        self._isolated_form_count = 0\n    def eligible(self, character: str) -> bool:\n        return is_arabic(character)\n    def feed(self, character: str) -> None:",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "is_suspiciously_successive_range",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "def is_suspiciously_successive_range(\n    unicode_range_a: str | None, unicode_range_b: str | None\n) -> bool:\n    \"\"\"\n    Determine if two Unicode range seen next to each other can be considered as suspicious.\n    \"\"\"\n    if unicode_range_a is None or unicode_range_b is None:\n        return True\n    if unicode_range_a == unicode_range_b:\n        return False",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "mess_ratio",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.md",
        "description": ".build.functions.students.charset_normalizer.md",
        "peekOfCode": "def mess_ratio(\n    decoded_sequence: str, maximum_threshold: float = 0.2, debug: bool = False\n) -> float:\n    \"\"\"\n    Compute a mess ratio given a decoded bytes sequence. The maximum threshold does stop the computation earlier.\n    \"\"\"\n    detectors: list[MessDetectorPlugin] = [\n        md_class() for md_class in MessDetectorPlugin.__subclasses__()\n    ]\n    length: int = len(decoded_sequence) + 1",
        "detail": ".build.functions.students.charset_normalizer.md",
        "documentation": {}
    },
    {
        "label": "CharsetMatch",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.models",
        "description": ".build.functions.students.charset_normalizer.models",
        "peekOfCode": "class CharsetMatch:\n    def __init__(\n        self,\n        payload: bytes,\n        guessed_encoding: str,\n        mean_mess_ratio: float,\n        has_sig_or_bom: bool,\n        languages: CoherenceMatches,\n        decoded_payload: str | None = None,\n        preemptive_declaration: str | None = None,",
        "detail": ".build.functions.students.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CharsetMatches",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.models",
        "description": ".build.functions.students.charset_normalizer.models",
        "peekOfCode": "class CharsetMatches:\n    \"\"\"\n    Container with every CharsetMatch items ordered by default from most probable to the less one.\n    Act like a list(iterable) but does not implements all related methods.\n    \"\"\"\n    def __init__(self, results: list[CharsetMatch] | None = None):\n        self._results: list[CharsetMatch] = sorted(results) if results else []\n    def __iter__(self) -> Iterator[CharsetMatch]:\n        yield from self._results\n    def __getitem__(self, item: int | str) -> CharsetMatch:",
        "detail": ".build.functions.students.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CliDetectionResult",
        "kind": 6,
        "importPath": ".build.functions.students.charset_normalizer.models",
        "description": ".build.functions.students.charset_normalizer.models",
        "peekOfCode": "class CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,\n        alphabets: list[str],\n        has_sig_or_bom: bool,",
        "detail": ".build.functions.students.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CoherenceMatch",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.models",
        "description": ".build.functions.students.charset_normalizer.models",
        "peekOfCode": "CoherenceMatch = Tuple[str, float]\nCoherenceMatches = List[CoherenceMatch]\nclass CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,",
        "detail": ".build.functions.students.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "CoherenceMatches",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.models",
        "description": ".build.functions.students.charset_normalizer.models",
        "peekOfCode": "CoherenceMatches = List[CoherenceMatch]\nclass CliDetectionResult:\n    def __init__(\n        self,\n        path: str,\n        encoding: str | None,\n        encoding_aliases: list[str],\n        alternative_encodings: list[str],\n        language: str,\n        alphabets: list[str],",
        "detail": ".build.functions.students.charset_normalizer.models",
        "documentation": {}
    },
    {
        "label": "is_accentuated",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_accentuated(character: str) -> bool:\n    try:\n        description: str = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return (\n        \"WITH GRAVE\" in description\n        or \"WITH ACUTE\" in description\n        or \"WITH CEDILLA\" in description\n        or \"WITH DIAERESIS\" in description",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "remove_accent",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def remove_accent(character: str) -> str:\n    decomposed: str = unicodedata.decomposition(character)\n    if not decomposed:\n        return character\n    codes: list[str] = decomposed.split(\" \")\n    return chr(int(codes[0], 16))\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef unicode_range(character: str) -> str | None:\n    \"\"\"\n    Retrieve the Unicode range official name from a single character.",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "unicode_range",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def unicode_range(character: str) -> str | None:\n    \"\"\"\n    Retrieve the Unicode range official name from a single character.\n    \"\"\"\n    character_ord: int = ord(character)\n    for range_name, ord_range in UNICODE_RANGES_COMBINED.items():\n        if character_ord in ord_range:\n            return range_name\n    return None\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_latin",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_latin(character: str) -> bool:\n    try:\n        description: str = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"LATIN\" in description\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_punctuation(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"P\" in character_category:",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_punctuation",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_punctuation(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"P\" in character_category:\n        return True\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Punctuation\" in character_range\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_symbol(character: str) -> bool:",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_symbol",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_symbol(character: str) -> bool:\n    character_category: str = unicodedata.category(character)\n    if \"S\" in character_category or \"N\" in character_category:\n        return True\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Forms\" in character_range and character_category != \"Lo\"\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_emoticon(character: str) -> bool:",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_emoticon",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_emoticon(character: str) -> bool:\n    character_range: str | None = unicode_range(character)\n    if character_range is None:\n        return False\n    return \"Emoticons\" in character_range or \"Pictographs\" in character_range\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_separator(character: str) -> bool:\n    if character.isspace() or character in {\"\", \"+\", \"<\", \">\"}:\n        return True\n    character_category: str = unicodedata.category(character)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_separator",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_separator(character: str) -> bool:\n    if character.isspace() or character in {\"\", \"+\", \"<\", \">\"}:\n        return True\n    character_category: str = unicodedata.category(character)\n    return \"Z\" in character_category or character_category in {\"Po\", \"Pd\", \"Pc\"}\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_case_variable(character: str) -> bool:\n    return character.islower() != character.isupper()\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk(character: str) -> bool:",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_case_variable",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_case_variable(character: str) -> bool:\n    return character.islower() != character.isupper()\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"CJK\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cjk",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_cjk(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"CJK\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_hiragana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_hiragana",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_hiragana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"HIRAGANA\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_katakana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_katakana",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_katakana(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"KATAKANA\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_hangul(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_hangul",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_hangul(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"HANGUL\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_thai(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_thai",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_thai(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"THAI\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_arabic(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_arabic",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_arabic(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"ARABIC\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_arabic_isolated_form(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_arabic_isolated_form",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_arabic_isolated_form(character: str) -> bool:\n    try:\n        character_name = unicodedata.name(character)\n    except ValueError:  # Defensive: unicode database outdated?\n        return False\n    return \"ARABIC\" in character_name and \"ISOLATED FORM\" in character_name\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_cjk_uncommon(character: str) -> bool:\n    return character not in COMMON_CJK_CHARACTERS\n@lru_cache(maxsize=len(UNICODE_RANGES_COMBINED))",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cjk_uncommon",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_cjk_uncommon(character: str) -> bool:\n    return character not in COMMON_CJK_CHARACTERS\n@lru_cache(maxsize=len(UNICODE_RANGES_COMBINED))\ndef is_unicode_range_secondary(range_name: str) -> bool:\n    return any(keyword in range_name for keyword in UNICODE_SECONDARY_RANGE_KEYWORD)\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_unicode_range_secondary",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_unicode_range_secondary(range_name: str) -> bool:\n    return any(keyword in range_name for keyword in UNICODE_SECONDARY_RANGE_KEYWORD)\n@lru_cache(maxsize=UTF8_MAXIMAL_ALLOCATION)\ndef is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False\n        and character != \"\\x1a\"  # Why? Its the ASCII substitute character.\n        and character != \"\\ufeff\"  # bug discovered in Python,\n        # Zero Width No-Break Space located in \tArabic Presentation Forms-B, Unicode 1.1 not acknowledged as space.",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_unprintable",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_unprintable(character: str) -> bool:\n    return (\n        character.isspace() is False  # includes \\n \\t \\r \\v\n        and character.isprintable() is False\n        and character != \"\\x1a\"  # Why? Its the ASCII substitute character.\n        and character != \"\\ufeff\"  # bug discovered in Python,\n        # Zero Width No-Break Space located in \tArabic Presentation Forms-B, Unicode 1.1 not acknowledged as space.\n    )\ndef any_specified_encoding(sequence: bytes, search_zone: int = 8192) -> str | None:\n    \"\"\"",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "any_specified_encoding",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def any_specified_encoding(sequence: bytes, search_zone: int = 8192) -> str | None:\n    \"\"\"\n    Extract using ASCII-only decoder any specified encoding in the first n-bytes.\n    \"\"\"\n    if not isinstance(sequence, bytes):\n        raise TypeError\n    seq_len: int = len(sequence)\n    results: list[str] = findall(\n        RE_POSSIBLE_ENCODING_INDICATION,\n        sequence[: min(seq_len, search_zone)].decode(\"ascii\", errors=\"ignore\"),",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_multi_byte_encoding",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_multi_byte_encoding(name: str) -> bool:\n    \"\"\"\n    Verify is a specific encoding is a multi byte one based on it IANA name\n    \"\"\"\n    return name in {\n        \"utf_8\",\n        \"utf_8_sig\",\n        \"utf_16\",\n        \"utf_16_be\",\n        \"utf_16_le\",",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "identify_sig_or_bom",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def identify_sig_or_bom(sequence: bytes) -> tuple[str | None, bytes]:\n    \"\"\"\n    Identify and extract SIG/BOM in given sequence.\n    \"\"\"\n    for iana_encoding in ENCODING_MARKS:\n        marks: bytes | list[bytes] = ENCODING_MARKS[iana_encoding]\n        if isinstance(marks, bytes):\n            marks = [marks]\n        for mark in marks:\n            if sequence.startswith(mark):",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "should_strip_sig_or_bom",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def should_strip_sig_or_bom(iana_encoding: str) -> bool:\n    return iana_encoding not in {\"utf_16\", \"utf_32\"}\ndef iana_name(cp_name: str, strict: bool = True) -> str:\n    \"\"\"Returns the Python normalized encoding name (Not the IANA official name).\"\"\"\n    cp_name = cp_name.lower().replace(\"-\", \"_\")\n    encoding_alias: str\n    encoding_iana: str\n    for encoding_alias, encoding_iana in aliases.items():\n        if cp_name in [encoding_alias, encoding_iana]:\n            return encoding_iana",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "iana_name",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def iana_name(cp_name: str, strict: bool = True) -> str:\n    \"\"\"Returns the Python normalized encoding name (Not the IANA official name).\"\"\"\n    cp_name = cp_name.lower().replace(\"-\", \"_\")\n    encoding_alias: str\n    encoding_iana: str\n    for encoding_alias, encoding_iana in aliases.items():\n        if cp_name in [encoding_alias, encoding_iana]:\n            return encoding_iana\n    if strict:\n        raise ValueError(f\"Unable to retrieve IANA for '{cp_name}'\")",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "cp_similarity",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def cp_similarity(iana_name_a: str, iana_name_b: str) -> float:\n    if is_multi_byte_encoding(iana_name_a) or is_multi_byte_encoding(iana_name_b):\n        return 0.0\n    decoder_a = importlib.import_module(f\"encodings.{iana_name_a}\").IncrementalDecoder\n    decoder_b = importlib.import_module(f\"encodings.{iana_name_b}\").IncrementalDecoder\n    id_a: IncrementalDecoder = decoder_a(errors=\"ignore\")\n    id_b: IncrementalDecoder = decoder_b(errors=\"ignore\")\n    character_match_count: int = 0\n    for i in range(255):\n        to_be_decoded: bytes = bytes([i])",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "is_cp_similar",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def is_cp_similar(iana_name_a: str, iana_name_b: str) -> bool:\n    \"\"\"\n    Determine if two code page are at least 80% similar. IANA_SUPPORTED_SIMILAR dict was generated using\n    the function cp_similarity.\n    \"\"\"\n    return (\n        iana_name_a in IANA_SUPPORTED_SIMILAR\n        and iana_name_b in IANA_SUPPORTED_SIMILAR[iana_name_a]\n    )\ndef set_logging_handler(",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "set_logging_handler",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def set_logging_handler(\n    name: str = \"charset_normalizer\",\n    level: int = logging.INFO,\n    format_string: str = \"%(asctime)s | %(levelname)s | %(message)s\",\n) -> None:\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(format_string))\n    logger.addHandler(handler)",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "cut_sequence_chunks",
        "kind": 2,
        "importPath": ".build.functions.students.charset_normalizer.utils",
        "description": ".build.functions.students.charset_normalizer.utils",
        "peekOfCode": "def cut_sequence_chunks(\n    sequences: bytes,\n    encoding_iana: str,\n    offsets: range,\n    chunk_size: int,\n    bom_or_sig_available: bool,\n    strip_sig_or_bom: bool,\n    sig_payload: bytes,\n    is_multi_byte_decoder: bool,\n    decoded_payload: str | None = None,",
        "detail": ".build.functions.students.charset_normalizer.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.version",
        "description": ".build.functions.students.charset_normalizer.version",
        "peekOfCode": "__version__ = \"3.4.4\"\nVERSION = __version__.split(\".\")",
        "detail": ".build.functions.students.charset_normalizer.version",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": ".build.functions.students.charset_normalizer.version",
        "description": ".build.functions.students.charset_normalizer.version",
        "peekOfCode": "VERSION = __version__.split(\".\")",
        "detail": ".build.functions.students.charset_normalizer.version",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": ".build.functions.students.idna.codec",
        "description": ".build.functions.students.idna.codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        return encode(data), len(data)\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))",
        "detail": ".build.functions.students.idna.codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": ".build.functions.students.idna.codec",
        "description": ".build.functions.students.idna.codec",
        "peekOfCode": "class IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = b\"\"\n        if labels:\n            if not labels[-1]:",
        "detail": ".build.functions.students.idna.codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": ".build.functions.students.idna.codec",
        "description": ".build.functions.students.idna.codec",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return (\"\", 0)\n        if not isinstance(data, str):\n            data = str(data, \"ascii\")\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = \"\"",
        "detail": ".build.functions.students.idna.codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": ".build.functions.students.idna.codec",
        "description": ".build.functions.students.idna.codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    pass\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,",
        "detail": ".build.functions.students.idna.codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": ".build.functions.students.idna.codec",
        "description": ".build.functions.students.idna.codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    pass\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,  # type: ignore\n        incrementalencoder=IncrementalEncoder,",
        "detail": ".build.functions.students.idna.codec",
        "documentation": {}
    },
    {
        "label": "search_function",
        "kind": 2,
        "importPath": ".build.functions.students.idna.codec",
        "description": ".build.functions.students.idna.codec",
        "peekOfCode": "def search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,  # type: ignore\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,",
        "detail": ".build.functions.students.idna.codec",
        "documentation": {}
    },
    {
        "label": "_unicode_dots_re",
        "kind": 5,
        "importPath": ".build.functions.students.idna.codec",
        "description": ".build.functions.students.idna.codec",
        "peekOfCode": "_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return b\"\", 0\n        return encode(data), len(data)\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":",
        "detail": ".build.functions.students.idna.codec",
        "documentation": {}
    },
    {
        "label": "ToASCII",
        "kind": 2,
        "importPath": ".build.functions.students.idna.compat",
        "description": ".build.functions.students.idna.compat",
        "peekOfCode": "def ToASCII(label: str) -> bytes:\n    return encode(label)\ndef ToUnicode(label: Union[bytes, bytearray]) -> str:\n    return decode(label)\ndef nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.students.idna.compat",
        "documentation": {}
    },
    {
        "label": "ToUnicode",
        "kind": 2,
        "importPath": ".build.functions.students.idna.compat",
        "description": ".build.functions.students.idna.compat",
        "peekOfCode": "def ToUnicode(label: Union[bytes, bytearray]) -> str:\n    return decode(label)\ndef nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.students.idna.compat",
        "documentation": {}
    },
    {
        "label": "nameprep",
        "kind": 2,
        "importPath": ".build.functions.students.idna.compat",
        "description": ".build.functions.students.idna.compat",
        "peekOfCode": "def nameprep(s: Any) -> None:\n    raise NotImplementedError(\"IDNA 2008 does not utilise nameprep protocol\")",
        "detail": ".build.functions.students.idna.compat",
        "documentation": {}
    },
    {
        "label": "IDNAError",
        "kind": 6,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "class IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "IDNABidiError",
        "kind": 6,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "class IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "InvalidCodepoint",
        "kind": 6,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "class InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "InvalidCodepointContext",
        "kind": 6,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "class InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):\n            raise ValueError(\"Unknown character in unicodedata\")\n    return v\ndef _is_script(cp: str, script: str) -> bool:",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_label_length",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def valid_label_length(label: Union[bytes, str]) -> bool:\n    if len(label) > 63:\n        return False\n    return True\ndef valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_string_length",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == \"\":",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "check_bidi",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == \"\":\n            # String likely comes from a newer version of Unicode\n            raise IDNABidiError(\"Unknown directionality in label {} at position {}\".format(repr(label), idx))\n        if direction in [\"R\", \"AL\", \"AN\"]:\n            bidi_label = True",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "check_initial_combiner",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def check_initial_combiner(label: str) -> bool:\n    if unicodedata.category(label[0])[0] == \"M\":\n        raise IDNAError(\"Label begins with an illegal combining character\")\n    return True\ndef check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == \"--\":\n        raise IDNAError(\"Label has disallowed hyphens in 3rd and 4th position\")\n    if label[0] == \"-\" or label[-1] == \"-\":\n        raise IDNAError(\"Label must not start or end with a hyphen\")\n    return True",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "check_hyphen_ok",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == \"--\":\n        raise IDNAError(\"Label has disallowed hyphens in 3rd and 4th position\")\n    if label[0] == \"-\" or label[-1] == \"-\":\n        raise IDNAError(\"Label must not start or end with a hyphen\")\n    return True\ndef check_nfc(label: str) -> None:\n    if unicodedata.normalize(\"NFC\", label) != label:\n        raise IDNAError(\"Label must be in Normalization Form C\")\ndef valid_contextj(label: str, pos: int) -> bool:",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "check_nfc",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def check_nfc(label: str) -> None:\n    if unicodedata.normalize(\"NFC\", label) != label:\n        raise IDNAError(\"Label must be in Normalization Form C\")\ndef valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x200C:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        ok = False",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_contextj",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x200C:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        ok = False\n        for i in range(pos - 1, -1, -1):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord(\"T\"):",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "valid_contexto",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def valid_contexto(label: str, pos: int, exception: bool = False) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 0x00B7:\n        if 0 < pos < len(label) - 1:\n            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:\n                return True\n        return False\n    elif cp_value == 0x0375:\n        if pos < len(label) - 1 and len(label) > 1:\n            return _is_script(label[pos + 1], \"Greek\")",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "check_label",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def check_label(label: Union[str, bytes, bytearray]) -> None:\n    if isinstance(label, (bytes, bytearray)):\n        label = label.decode(\"utf-8\")\n    if len(label) == 0:\n        raise IDNAError(\"Empty Label\")\n    check_nfc(label)\n    check_hyphen_ok(label)\n    check_initial_combiner(label)\n    for pos, cp in enumerate(label):\n        cp_value = ord(cp)",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "alabel",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def alabel(label: str) -> bytes:\n    try:\n        label_bytes = label.encode(\"ascii\")\n        ulabel(label_bytes)\n        if not valid_label_length(label_bytes):\n            raise IDNAError(\"Label too long\")\n        return label_bytes\n    except UnicodeEncodeError:\n        pass\n    check_label(label)",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "ulabel",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def ulabel(label: Union[str, bytes, bytearray]) -> str:\n    if not isinstance(label, (bytes, bytearray)):\n        try:\n            label_bytes = label.encode(\"ascii\")\n        except UnicodeEncodeError:\n            check_label(label)\n            return label\n    else:\n        label_bytes = bytes(label)\n    label_bytes = label_bytes.lower()",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "uts46_remap",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:\n    \"\"\"Re-map the characters in the string according to UTS46 processing.\"\"\"\n    from .uts46data import uts46data\n    output = \"\"\n    for pos, char in enumerate(domain):\n        code_point = ord(char)\n        try:\n            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, \"Z\")) - 1]\n            status = uts46row[1]\n            replacement: Optional[str] = None",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def encode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n    transitional: bool = False,\n) -> bytes:\n    if not isinstance(s, str):\n        try:\n            s = str(s, \"ascii\")",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "def decode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n) -> str:\n    try:\n        if not isinstance(s, str):\n            s = str(s, \"ascii\")\n    except UnicodeDecodeError:",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "_virama_combining_class",
        "kind": 5,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "_virama_combining_class = 9\n_alabel_prefix = b\"xn--\"\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "_alabel_prefix",
        "kind": 5,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "_alabel_prefix = b\"xn--\"\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "_unicode_dots_re",
        "kind": 5,
        "importPath": ".build.functions.students.idna.core",
        "description": ".build.functions.students.idna.core",
        "peekOfCode": "_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass",
        "detail": ".build.functions.students.idna.core",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.students.idna.idnadata",
        "description": ".build.functions.students.idna.idnadata",
        "peekOfCode": "__version__ = \"16.0.0\"\nscripts = {\n    \"Greek\": (\n        0x37000000374,\n        0x37500000378,\n        0x37A0000037E,\n        0x37F00000380,\n        0x38400000385,\n        0x38600000387,\n        0x3880000038B,",
        "detail": ".build.functions.students.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "scripts",
        "kind": 5,
        "importPath": ".build.functions.students.idna.idnadata",
        "description": ".build.functions.students.idna.idnadata",
        "peekOfCode": "scripts = {\n    \"Greek\": (\n        0x37000000374,\n        0x37500000378,\n        0x37A0000037E,\n        0x37F00000380,\n        0x38400000385,\n        0x38600000387,\n        0x3880000038B,\n        0x38C0000038D,",
        "detail": ".build.functions.students.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "joining_types",
        "kind": 5,
        "importPath": ".build.functions.students.idna.idnadata",
        "description": ".build.functions.students.idna.idnadata",
        "peekOfCode": "joining_types = {\n    0xAD: 84,\n    0x300: 84,\n    0x301: 84,\n    0x302: 84,\n    0x303: 84,\n    0x304: 84,\n    0x305: 84,\n    0x306: 84,\n    0x307: 84,",
        "detail": ".build.functions.students.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "codepoint_classes",
        "kind": 5,
        "importPath": ".build.functions.students.idna.idnadata",
        "description": ".build.functions.students.idna.idnadata",
        "peekOfCode": "codepoint_classes = {\n    \"PVALID\": (\n        0x2D0000002E,\n        0x300000003A,\n        0x610000007B,\n        0xDF000000F7,\n        0xF800000100,\n        0x10100000102,\n        0x10300000104,\n        0x10500000106,",
        "detail": ".build.functions.students.idna.idnadata",
        "documentation": {}
    },
    {
        "label": "intranges_from_list",
        "kind": 2,
        "importPath": ".build.functions.students.idna.intranges",
        "description": ".build.functions.students.idna.intranges",
        "peekOfCode": "def intranges_from_list(list_: List[int]) -> Tuple[int, ...]:\n    \"\"\"Represent a list of integers as a sequence of ranges:\n    ((start_0, end_0), (start_1, end_1), ...), such that the original\n    integers are exactly those x such that start_i <= x < end_i for some i.\n    Ranges are encoded as single integers (start << 32 | end), not as tuples.\n    \"\"\"\n    sorted_list = sorted(list_)\n    ranges = []\n    last_write = -1\n    for i in range(len(sorted_list)):",
        "detail": ".build.functions.students.idna.intranges",
        "documentation": {}
    },
    {
        "label": "intranges_contain",
        "kind": 2,
        "importPath": ".build.functions.students.idna.intranges",
        "description": ".build.functions.students.idna.intranges",
        "peekOfCode": "def intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:\n    \"\"\"Determine if `int_` falls into one of the ranges in `ranges`.\"\"\"\n    tuple_ = _encode_range(int_, 0)\n    pos = bisect.bisect_left(ranges, tuple_)\n    # we could be immediately ahead of a tuple (start, end)\n    # with start < int_ <= end\n    if pos > 0:\n        left, right = _decode_range(ranges[pos - 1])\n        if left <= int_ < right:\n            return True",
        "detail": ".build.functions.students.idna.intranges",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.students.idna.package_data",
        "description": ".build.functions.students.idna.package_data",
        "peekOfCode": "__version__ = \"3.11\"",
        "detail": ".build.functions.students.idna.package_data",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.students.idna.uts46data",
        "description": ".build.functions.students.idna.uts46data",
        "peekOfCode": "__version__ = \"16.0.0\"\ndef _seg_0() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x0, \"V\"),\n        (0x1, \"V\"),\n        (0x2, \"V\"),\n        (0x3, \"V\"),\n        (0x4, \"V\"),\n        (0x5, \"V\"),\n        (0x6, \"V\"),",
        "detail": ".build.functions.students.idna.uts46data",
        "documentation": {}
    },
    {
        "label": "uts46data",
        "kind": 5,
        "importPath": ".build.functions.students.idna.uts46data",
        "description": ".build.functions.students.idna.uts46data",
        "peekOfCode": "uts46data = tuple(\n    _seg_0()\n    + _seg_1()\n    + _seg_2()\n    + _seg_3()\n    + _seg_4()\n    + _seg_5()\n    + _seg_6()\n    + _seg_7()\n    + _seg_8()",
        "detail": ".build.functions.students.idna.uts46data",
        "documentation": {}
    },
    {
        "label": "to_native_string",
        "kind": 2,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "def to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        out = string.decode(encoding)\n    return out",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "unicode_is_ascii",
        "kind": 2,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode(\"ascii\")\n        return True",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_NAME_RE_BYTE",
        "kind": 5,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_NAME_RE_BYTE = re.compile(rb\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_NAME_RE_STR = re.compile(r\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_NAME_RE_STR",
        "kind": 5,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_NAME_RE_STR = re.compile(r\"^[^:\\s][^:\\r\\n]*$\")\n_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_VALUE_RE_BYTE",
        "kind": 5,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb\"^\\S[^\\r\\n]*$|^$\")\n_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_VALID_HEADER_VALUE_RE_STR",
        "kind": 5,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "_VALID_HEADER_VALUE_RE_STR = re.compile(r\"^\\S[^\\r\\n]*$|^$\")\n_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_HEADER_VALIDATORS_STR",
        "kind": 5,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)\n_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "_HEADER_VALIDATORS_BYTE",
        "kind": 5,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)\nHEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "HEADER_VALIDATORS",
        "kind": 5,
        "importPath": ".build.functions.students.requests._internal_utils",
        "description": ".build.functions.students.requests._internal_utils",
        "peekOfCode": "HEADER_VALIDATORS = {\n    bytes: _HEADER_VALIDATORS_BYTE,\n    str: _HEADER_VALIDATORS_STR,\n}\ndef to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):",
        "detail": ".build.functions.students.requests._internal_utils",
        "documentation": {}
    },
    {
        "label": "BaseAdapter",
        "kind": 6,
        "importPath": ".build.functions.students.requests.adapters",
        "description": ".build.functions.students.requests.adapters",
        "peekOfCode": "class BaseAdapter:\n    \"\"\"The Base Transport Adapter\"\"\"\n    def __init__(self):\n        super().__init__()\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.",
        "detail": ".build.functions.students.requests.adapters",
        "documentation": {}
    },
    {
        "label": "HTTPAdapter",
        "kind": 6,
        "importPath": ".build.functions.students.requests.adapters",
        "description": ".build.functions.students.requests.adapters",
        "peekOfCode": "class HTTPAdapter(BaseAdapter):\n    \"\"\"The built-in HTTP Adapter for urllib3.\n    Provides a general-case interface for Requests sessions to contact HTTP and\n    HTTPS urls by implementing the Transport Adapter interface. This class will\n    usually be created by the :class:`Session <Session>` class under the\n    covers.\n    :param pool_connections: The number of urllib3 connection pools to cache.\n    :param pool_maxsize: The maximum number of connections to save in the pool.\n    :param max_retries: The maximum number of retries each connection\n        should attempt. Note, this applies only to failed DNS lookups, socket",
        "detail": ".build.functions.students.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOLBLOCK",
        "kind": 5,
        "importPath": ".build.functions.students.requests.adapters",
        "description": ".build.functions.students.requests.adapters",
        "peekOfCode": "DEFAULT_POOLBLOCK = False\nDEFAULT_POOLSIZE = 10\nDEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":",
        "detail": ".build.functions.students.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOLSIZE",
        "kind": 5,
        "importPath": ".build.functions.students.requests.adapters",
        "description": ".build.functions.students.requests.adapters",
        "peekOfCode": "DEFAULT_POOLSIZE = 10\nDEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}",
        "detail": ".build.functions.students.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RETRIES",
        "kind": 5,
        "importPath": ".build.functions.students.requests.adapters",
        "description": ".build.functions.students.requests.adapters",
        "peekOfCode": "DEFAULT_RETRIES = 0\nDEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}\n    pool_kwargs = {}",
        "detail": ".build.functions.students.requests.adapters",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POOL_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.students.requests.adapters",
        "description": ".build.functions.students.requests.adapters",
        "peekOfCode": "DEFAULT_POOL_TIMEOUT = None\ndef _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}\n    pool_kwargs = {}\n    parsed_request_url = urlparse(request.url)",
        "detail": ".build.functions.students.requests.adapters",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def request(method, url, **kwargs):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n    :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "get",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def get(url, params=None, **kwargs):\n    r\"\"\"Sends a GET request.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"get\", url, params=params, **kwargs)",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def options(url, **kwargs):\n    r\"\"\"Sends an OPTIONS request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"options\", url, **kwargs)\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "head",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n        `allow_redirects` is not provided, it will be set to `False` (as\n        opposed to the default :meth:`request` behavior).\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    kwargs.setdefault(\"allow_redirects\", False)",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "post",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def post(url, data=None, json=None, **kwargs):\n    r\"\"\"Sends a POST request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "put",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def put(url, data=None, **kwargs):\n    r\"\"\"Sends a PUT request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "patch",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def patch(url, data=None, **kwargs):\n    r\"\"\"Sends a PATCH request.\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "delete",
        "kind": 2,
        "importPath": ".build.functions.students.requests.api",
        "description": ".build.functions.students.requests.api",
        "peekOfCode": "def delete(url, **kwargs):\n    r\"\"\"Sends a DELETE request.\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request(\"delete\", url, **kwargs)",
        "detail": ".build.functions.students.requests.api",
        "documentation": {}
    },
    {
        "label": "AuthBase",
        "kind": 6,
        "importPath": ".build.functions.students.requests.auth",
        "description": ".build.functions.students.requests.auth",
        "peekOfCode": "class AuthBase:\n    \"\"\"Base class that all auth implementations derive from\"\"\"\n    def __call__(self, r):\n        raise NotImplementedError(\"Auth hooks must be callable.\")\nclass HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    def __eq__(self, other):",
        "detail": ".build.functions.students.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPBasicAuth",
        "kind": 6,
        "importPath": ".build.functions.students.requests.auth",
        "description": ".build.functions.students.requests.auth",
        "peekOfCode": "class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),",
        "detail": ".build.functions.students.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPProxyAuth",
        "kind": 6,
        "importPath": ".build.functions.students.requests.auth",
        "description": ".build.functions.students.requests.auth",
        "peekOfCode": "class HTTPProxyAuth(HTTPBasicAuth):\n    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n    def __call__(self, r):\n        r.headers[\"Proxy-Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r\nclass HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password",
        "detail": ".build.functions.students.requests.auth",
        "documentation": {}
    },
    {
        "label": "HTTPDigestAuth",
        "kind": 6,
        "importPath": ".build.functions.students.requests.auth",
        "description": ".build.functions.students.requests.auth",
        "peekOfCode": "class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n    def init_per_thread_state(self):\n        # Ensure state is initialized just once per-thread\n        if not hasattr(self._thread_local, \"init\"):",
        "detail": ".build.functions.students.requests.auth",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE_FORM_URLENCODED",
        "kind": 5,
        "importPath": ".build.functions.students.requests.auth",
        "description": ".build.functions.students.requests.auth",
        "peekOfCode": "CONTENT_TYPE_FORM_URLENCODED = \"application/x-www-form-urlencoded\"\nCONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility",
        "detail": ".build.functions.students.requests.auth",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE_MULTI_PART",
        "kind": 5,
        "importPath": ".build.functions.students.requests.auth",
        "description": ".build.functions.students.requests.auth",
        "peekOfCode": "CONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility\n    # for things like ints. This will be removed in 3.0.0.",
        "detail": ".build.functions.students.requests.auth",
        "documentation": {}
    },
    {
        "label": "chardet",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "chardet = _resolve_char_detection()\n# -------\n# Pythons\n# -------\n# Syntax sugar.\n_ver = sys.version_info\n#: Python 2.x?\nis_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "_ver",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "_ver = sys.version_info\n#: Python 2.x?\nis_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "is_py2 = _ver[0] == 2\n#: Python 3.x?\nis_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "is_py3",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "is_py3 = _ver[0] == 3\n# json/simplejson module import resolution\nhas_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json\nif has_simplejson:\n    from simplejson import JSONDecodeError",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "has_simplejson",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "has_simplejson = False\ntry:\n    import simplejson as json\n    has_simplejson = True\nexcept ImportError:\n    import json\nif has_simplejson:\n    from simplejson import JSONDecodeError\nelse:\n    from json import JSONDecodeError",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "builtin_str",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "builtin_str = str\nstr = str\nbytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "str = str\nbytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "bytes",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "bytes = bytes\nbasestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "basestring",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "basestring = (str, bytes)\nnumeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "numeric_types",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "numeric_types = (int, float)\ninteger_types = (int,)",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "integer_types",
        "kind": 5,
        "importPath": ".build.functions.students.requests.compat",
        "description": ".build.functions.students.requests.compat",
        "peekOfCode": "integer_types = (int,)",
        "detail": ".build.functions.students.requests.compat",
        "documentation": {}
    },
    {
        "label": "MockRequest",
        "kind": 6,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "class MockRequest:\n    \"\"\"Wraps a `requests.Request` to mimic a `urllib2.Request`.\n    The code in `http.cookiejar.CookieJar` expects this interface in order to correctly\n    manage cookie policies, i.e., determine whether a cookie can be set, given the\n    domains of the request and the cookie.\n    The original request object is read-only. The client is responsible for collecting\n    the new headers via `get_new_headers()` and interpreting them appropriately. You\n    probably want `get_cookie_header`, defined below.\n    \"\"\"\n    def __init__(self, request):",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "MockResponse",
        "kind": 6,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "class MockResponse:\n    \"\"\"Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n    ...what? Basically, expose the parsed HTTP headers from the server response\n    the way `http.cookiejar` expects to see them.\n    \"\"\"\n    def __init__(self, headers):\n        \"\"\"Make a MockResponse for `cookiejar` to read.\n        :param headers: a httplib.HTTPMessage or analogous carrying the headers\n        \"\"\"\n        self._headers = headers",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "CookieConflictError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "class CookieConflictError(RuntimeError):\n    \"\"\"There are two cookies that meet the criteria specified in the cookie jar.\n    Use .get and .set and include domain and path args in order to be more specific.\n    \"\"\"\nclass RequestsCookieJar(cookielib.CookieJar, MutableMapping):\n    \"\"\"Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\n    interface.\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "RequestsCookieJar",
        "kind": 6,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "class RequestsCookieJar(cookielib.CookieJar, MutableMapping):\n    \"\"\"Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\n    interface.\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n    Requests does not use the dict interface internally; it's just for\n    compatibility with external client code. All requests code should work\n    out of the box with externally provided instances of ``CookieJar``, e.g.\n    ``LWPCookieJar`` and ``FileCookieJar``.",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "extract_cookies_to_jar",
        "kind": 2,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "def extract_cookies_to_jar(jar, request, response):\n    \"\"\"Extract the cookies from the response into a CookieJar.\n    :param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n    :param request: our own requests.Request object\n    :param response: urllib3.HTTPResponse object\n    \"\"\"\n    if not (hasattr(response, \"_original_response\") and response._original_response):\n        return\n    # the _original_response field is the wrapped httplib.HTTPResponse object,\n    req = MockRequest(request)",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "get_cookie_header",
        "kind": 2,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "def get_cookie_header(jar, request):\n    \"\"\"\n    Produce an appropriate Cookie header string to be sent with `request`, or None.\n    :rtype: str\n    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get(\"Cookie\")\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "remove_cookie_by_name",
        "kind": 2,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "def remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.\n    Wraps CookieJar.clear(), is O(n).\n    \"\"\"\n    clearables = []\n    for cookie in cookiejar:\n        if cookie.name != name:\n            continue\n        if domain is not None and domain != cookie.domain:\n            continue",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "create_cookie",
        "kind": 2,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "def create_cookie(name, value, **kwargs):\n    \"\"\"Make a cookie from underspecified parameters.\n    By default, the pair of `name` and `value` will be set for the domain ''\n    and sent on every request (this is sometimes called a \"supercookie\").\n    \"\"\"\n    result = {\n        \"version\": 0,\n        \"name\": name,\n        \"value\": value,\n        \"port\": None,",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "morsel_to_cookie",
        "kind": 2,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "def morsel_to_cookie(morsel):\n    \"\"\"Convert a Morsel object into a Cookie containing the one k/v pair.\"\"\"\n    expires = None\n    if morsel[\"max-age\"]:\n        try:\n            expires = int(time.time() + int(morsel[\"max-age\"]))\n        except ValueError:\n            raise TypeError(f\"max-age: {morsel['max-age']} must be integer\")\n    elif morsel[\"expires\"]:\n        time_template = \"%a, %d-%b-%Y %H:%M:%S GMT\"",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "cookiejar_from_dict",
        "kind": 2,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :param cookiejar: (optional) A cookiejar to add the cookies to.\n    :param overwrite: (optional) If False, will not replace cookies\n        already in the jar with new ones.\n    :rtype: CookieJar\n    \"\"\"\n    if cookiejar is None:\n        cookiejar = RequestsCookieJar()",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "merge_cookies",
        "kind": 2,
        "importPath": ".build.functions.students.requests.cookies",
        "description": ".build.functions.students.requests.cookies",
        "peekOfCode": "def merge_cookies(cookiejar, cookies):\n    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n    :param cookiejar: CookieJar object to add the cookies to.\n    :param cookies: Dictionary or CookieJar object to be added.\n    :rtype: CookieJar\n    \"\"\"\n    if not isinstance(cookiejar, cookielib.CookieJar):\n        raise ValueError(\"You can only merge into CookieJar\")\n    if isinstance(cookies, dict):\n        cookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)",
        "detail": ".build.functions.students.requests.cookies",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class RequestException(IOError):\n    \"\"\"There was an ambiguous exception that occurred while handling your\n    request.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize RequestException with `request` and `response` objects.\"\"\"\n        response = kwargs.pop(\"response\", None)\n        self.response = response\n        self.request = kwargs.pop(\"request\", None)\n        if response is not None and not self.request and hasattr(response, \"request\"):",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidJSONError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class InvalidJSONError(RequestException):\n    \"\"\"A JSON error occurred.\"\"\"\nclass JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n    \"\"\"Couldn't decode the text into json\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Construct the JSONDecodeError instance first with all\n        args. Then use it's args to construct the IOError so that\n        the json specific args aren't used as IOError specific args\n        and the error message from JSONDecodeError is preserved.",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n    \"\"\"Couldn't decode the text into json\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Construct the JSONDecodeError instance first with all\n        args. Then use it's args to construct the IOError so that\n        the json specific args aren't used as IOError specific args\n        and the error message from JSONDecodeError is preserved.\n        \"\"\"\n        CompatJSONDecodeError.__init__(self, *args)",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class HTTPError(RequestException):\n    \"\"\"An HTTP error occurred.\"\"\"\nclass ConnectionError(RequestException):\n    \"\"\"A Connection error occurred.\"\"\"\nclass ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class ConnectionError(RequestException):\n    \"\"\"A Connection error occurred.\"\"\"\nclass ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class ProxyError(ConnectionError):\n    \"\"\"A proxy error occurred.\"\"\"\nclass SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class SSLError(ConnectionError):\n    \"\"\"An SSL error occurred.\"\"\"\nclass Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"\nclass ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class Timeout(RequestException):\n    \"\"\"The request timed out.\n    Catching this error will catch both\n    :exc:`~requests.exceptions.ConnectTimeout` and\n    :exc:`~requests.exceptions.ReadTimeout` errors.\n    \"\"\"\nclass ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.\n    Requests that produced this error are safe to retry.\n    \"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeout",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class ConnectTimeout(ConnectionError, Timeout):\n    \"\"\"The request timed out while trying to connect to the remote server.\n    Requests that produced this error are safe to retry.\n    \"\"\"\nclass ReadTimeout(Timeout):\n    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"\nclass URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeout",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class ReadTimeout(Timeout):\n    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"\nclass URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "URLRequired",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class URLRequired(RequestException):\n    \"\"\"A valid URL is required to make a request.\"\"\"\nclass TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "TooManyRedirects",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class TooManyRedirects(RequestException):\n    \"\"\"Too many redirects.\"\"\"\nclass MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "MissingSchema",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class MissingSchema(RequestException, ValueError):\n    \"\"\"The URL scheme (e.g. http or https) is missing.\"\"\"\nclass InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidSchema",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class InvalidSchema(RequestException, ValueError):\n    \"\"\"The URL scheme provided is either invalid or unsupported.\"\"\"\nclass InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidURL",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class InvalidURL(RequestException, ValueError):\n    \"\"\"The URL provided was somehow invalid.\"\"\"\nclass InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class InvalidHeader(RequestException, ValueError):\n    \"\"\"The header value provided was somehow invalid.\"\"\"\nclass InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidProxyURL",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class InvalidProxyURL(InvalidURL):\n    \"\"\"The proxy URL provided is invalid.\"\"\"\nclass ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ChunkedEncodingError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class ChunkedEncodingError(RequestException):\n    \"\"\"The server declared chunked encoding but sent an invalid chunk.\"\"\"\nclass ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "ContentDecodingError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class ContentDecodingError(RequestException, BaseHTTPError):\n    \"\"\"Failed to decode response content.\"\"\"\nclass StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "StreamConsumedError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class StreamConsumedError(RequestException, TypeError):\n    \"\"\"The content for this response was already consumed.\"\"\"\nclass RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RetryError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class RetryError(RequestException):\n    \"\"\"Custom retries logic failed\"\"\"\nclass UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "UnrewindableBodyError",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class UnrewindableBodyError(RequestException):\n    \"\"\"Requests encountered an error when trying to rewind a body.\"\"\"\n# Warnings\nclass RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestsWarning",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class RequestsWarning(Warning):\n    \"\"\"Base warning for Requests.\"\"\"\nclass FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "FileModeWarning",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class FileModeWarning(RequestsWarning, DeprecationWarning):\n    \"\"\"A file was opened in text mode, but Requests determined its binary length.\"\"\"\nclass RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestsDependencyWarning",
        "kind": 6,
        "importPath": ".build.functions.students.requests.exceptions",
        "description": ".build.functions.students.requests.exceptions",
        "peekOfCode": "class RequestsDependencyWarning(RequestsWarning):\n    \"\"\"An imported dependency doesn't match the expected version range.\"\"\"",
        "detail": ".build.functions.students.requests.exceptions",
        "documentation": {}
    },
    {
        "label": "info",
        "kind": 2,
        "importPath": ".build.functions.students.requests.help",
        "description": ".build.functions.students.requests.help",
        "peekOfCode": "def info():\n    \"\"\"Generate information for a bug report.\"\"\"\n    try:\n        platform_info = {\n            \"system\": platform.system(),\n            \"release\": platform.release(),\n        }\n    except OSError:\n        platform_info = {\n            \"system\": \"Unknown\",",
        "detail": ".build.functions.students.requests.help",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".build.functions.students.requests.help",
        "description": ".build.functions.students.requests.help",
        "peekOfCode": "def main():\n    \"\"\"Pretty-print the bug information as JSON.\"\"\"\n    print(json.dumps(info(), sort_keys=True, indent=2))\nif __name__ == \"__main__\":\n    main()",
        "detail": ".build.functions.students.requests.help",
        "documentation": {}
    },
    {
        "label": "default_hooks",
        "kind": 2,
        "importPath": ".build.functions.students.requests.hooks",
        "description": ".build.functions.students.requests.hooks",
        "peekOfCode": "def default_hooks():\n    return {event: [] for event in HOOKS}\n# TODO: response is the only one\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]",
        "detail": ".build.functions.students.requests.hooks",
        "documentation": {}
    },
    {
        "label": "dispatch_hook",
        "kind": 2,
        "importPath": ".build.functions.students.requests.hooks",
        "description": ".build.functions.students.requests.hooks",
        "peekOfCode": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if _hook_data is not None:",
        "detail": ".build.functions.students.requests.hooks",
        "documentation": {}
    },
    {
        "label": "HOOKS",
        "kind": 5,
        "importPath": ".build.functions.students.requests.hooks",
        "description": ".build.functions.students.requests.hooks",
        "peekOfCode": "HOOKS = [\"response\"]\ndef default_hooks():\n    return {event: [] for event in HOOKS}\n# TODO: response is the only one\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):",
        "detail": ".build.functions.students.requests.hooks",
        "documentation": {}
    },
    {
        "label": "RequestEncodingMixin",
        "kind": 6,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "class RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:\n            path = \"/\"\n        url.append(path)",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "RequestHooksMixin",
        "kind": 6,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "class RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n    def deregister_hook(self, event, hook):",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "Request",
        "kind": 6,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "class Request(RequestHooksMixin):\n    \"\"\"A user-created :class:`Request <Request>` object.\n    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n    :param method: HTTP method to use.\n    :param url: URL to send.\n    :param headers: dictionary of headers to send.\n    :param files: dictionary of {filename: fileobject} files to multipart upload.\n    :param data: the body to attach to the request. If a dictionary or\n        list of tuples ``[(key, value)]`` is provided, form-encoding will\n        take place.",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "PreparedRequest",
        "kind": 6,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n    \"\"\"The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\n    containing the exact bytes that will be sent to the server.\n    Instances are generated from a :class:`Request <Request>` object, and\n    should not be instantiated manually; doing so may produce undesirable\n    effects.\n    Usage::\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "class Response:\n    \"\"\"The :class:`Response <Response>` object, which contains a\n    server's response to an HTTP request.\n    \"\"\"\n    __attrs__ = [\n        \"_content\",\n        \"status_code\",\n        \"headers\",\n        \"url\",\n        \"history\",",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "REDIRECT_STATI",
        "kind": 5,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "REDIRECT_STATI = (\n    codes.moved,  # 301\n    codes.found,  # 302\n    codes.other,  # 303\n    codes.temporary_redirect,  # 307\n    codes.permanent_redirect,  # 308\n)\nDEFAULT_REDIRECT_LIMIT = 30\nCONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "DEFAULT_REDIRECT_LIMIT",
        "kind": 5,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "DEFAULT_REDIRECT_LIMIT = 30\nCONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "CONTENT_CHUNK_SIZE",
        "kind": 5,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "CONTENT_CHUNK_SIZE = 10 * 1024\nITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "ITER_CHUNK_SIZE",
        "kind": 5,
        "importPath": ".build.functions.students.requests.models",
        "description": ".build.functions.students.requests.models",
        "peekOfCode": "ITER_CHUNK_SIZE = 512\nclass RequestEncodingMixin:\n    @property\n    def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n        url = []\n        p = urlsplit(self.url)\n        path = p.path\n        if not path:\n            path = \"/\"",
        "detail": ".build.functions.students.requests.models",
        "documentation": {}
    },
    {
        "label": "SessionRedirectMixin",
        "kind": 6,
        "importPath": ".build.functions.students.requests.sessions",
        "description": ".build.functions.students.requests.sessions",
        "peekOfCode": "class SessionRedirectMixin:\n    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:",
        "detail": ".build.functions.students.requests.sessions",
        "documentation": {}
    },
    {
        "label": "Session",
        "kind": 6,
        "importPath": ".build.functions.students.requests.sessions",
        "description": ".build.functions.students.requests.sessions",
        "peekOfCode": "class Session(SessionRedirectMixin):\n    \"\"\"A Requests session.\n    Provides cookie persistence, connection-pooling, and configuration.\n    Basic Usage::\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n    Or as a context manager::\n      >>> with requests.Session() as s:",
        "detail": ".build.functions.students.requests.sessions",
        "documentation": {}
    },
    {
        "label": "merge_setting",
        "kind": 2,
        "importPath": ".build.functions.students.requests.sessions",
        "description": ".build.functions.students.requests.sessions",
        "peekOfCode": "def merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"Determines appropriate setting for a given request, taking into account\n    the explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n    if session_setting is None:\n        return request_setting\n    if request_setting is None:\n        return session_setting\n    # Bypass if not a dictionary (e.g. verify)",
        "detail": ".build.functions.students.requests.sessions",
        "documentation": {}
    },
    {
        "label": "merge_hooks",
        "kind": 2,
        "importPath": ".build.functions.students.requests.sessions",
        "description": ".build.functions.students.requests.sessions",
        "peekOfCode": "def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n    \"\"\"Properly merges both requests and session hooks.\n    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get(\"response\") == []:\n        return request_hooks\n    if request_hooks is None or request_hooks.get(\"response\") == []:\n        return session_hooks\n    return merge_setting(request_hooks, session_hooks, dict_class)",
        "detail": ".build.functions.students.requests.sessions",
        "documentation": {}
    },
    {
        "label": "session",
        "kind": 2,
        "importPath": ".build.functions.students.requests.sessions",
        "description": ".build.functions.students.requests.sessions",
        "peekOfCode": "def session():\n    \"\"\"\n    Returns a :class:`Session` for context-management.\n    .. deprecated:: 1.0.0\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n    :rtype: Session\n    \"\"\"\n    return Session()",
        "detail": ".build.functions.students.requests.sessions",
        "documentation": {}
    },
    {
        "label": "_codes",
        "kind": 5,
        "importPath": ".build.functions.students.requests.status_codes",
        "description": ".build.functions.students.requests.status_codes",
        "peekOfCode": "_codes = {\n    # Informational.\n    100: (\"continue\",),\n    101: (\"switching_protocols\",),\n    102: (\"processing\", \"early-hints\"),\n    103: (\"checkpoint\",),\n    122: (\"uri_too_long\", \"request_uri_too_long\"),\n    200: (\"ok\", \"okay\", \"all_ok\", \"all_okay\", \"all_good\", \"\\\\o/\", \"\"),\n    201: (\"created\",),\n    202: (\"accepted\",),",
        "detail": ".build.functions.students.requests.status_codes",
        "documentation": {}
    },
    {
        "label": "codes",
        "kind": 5,
        "importPath": ".build.functions.students.requests.status_codes",
        "description": ".build.functions.students.requests.status_codes",
        "peekOfCode": "codes = LookupDict(name=\"status_codes\")\ndef _init():\n    for code, titles in _codes.items():\n        for title in titles:\n            setattr(codes, title, code)\n            if not title.startswith((\"\\\\\", \"/\")):\n                setattr(codes, title.upper(), code)\n    def doc(code):\n        names = \", \".join(f\"``{n}``\" for n in _codes[code])\n        return \"* %d: %s\" % (code, names)",
        "detail": ".build.functions.students.requests.status_codes",
        "documentation": {}
    },
    {
        "label": "CaseInsensitiveDict",
        "kind": 6,
        "importPath": ".build.functions.students.requests.structures",
        "description": ".build.functions.students.requests.structures",
        "peekOfCode": "class CaseInsensitiveDict(MutableMapping):\n    \"\"\"A case-insensitive ``dict``-like object.\n    Implements all methods and operations of\n    ``MutableMapping`` as well as dict's ``copy``. Also\n    provides ``lower_items``.\n    All keys are expected to be strings. The structure remembers the\n    case of the last key to be set, and ``iter(instance)``,\n    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``\n    will contain case-sensitive keys. However, querying and contains\n    testing is case insensitive::",
        "detail": ".build.functions.students.requests.structures",
        "documentation": {}
    },
    {
        "label": "LookupDict",
        "kind": 6,
        "importPath": ".build.functions.students.requests.structures",
        "description": ".build.functions.students.requests.structures",
        "peekOfCode": "class LookupDict(dict):\n    \"\"\"Dictionary lookup object.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        super().__init__()\n    def __repr__(self):\n        return f\"<lookup '{self.name}'>\"\n    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n        return self.__dict__.get(key, None)",
        "detail": ".build.functions.students.requests.structures",
        "documentation": {}
    },
    {
        "label": "dict_to_sequence",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def dict_to_sequence(d):\n    \"\"\"Returns an internal sequence dictionary update.\"\"\"\n    if hasattr(d, \"items\"):\n        d = d.items()\n    return d\ndef super_len(o):\n    total_length = None\n    current_position = 0\n    if not is_urllib3_1 and isinstance(o, str):\n        # urllib3 2.x+ treats all strings as utf-8 instead",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "super_len",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def super_len(o):\n    total_length = None\n    current_position = 0\n    if not is_urllib3_1 and isinstance(o, str):\n        # urllib3 2.x+ treats all strings as utf-8 instead\n        # of latin-1 (iso-8859-1) like http.client.\n        o = o.encode(\"utf-8\")\n    if hasattr(o, \"__len__\"):\n        total_length = len(o)\n    elif hasattr(o, \"len\"):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_netrc_auth",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n    netrc_file = os.environ.get(\"NETRC\")\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n        netrc_locations = (f\"~/{f}\" for f in NETRC_FILES)\n    try:\n        from netrc import NetrcParseError, netrc\n        netrc_path = None",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "guess_filename",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def guess_filename(obj):\n    \"\"\"Tries to guess the filename of the given object.\"\"\"\n    name = getattr(obj, \"name\", None)\n    if name and isinstance(name, basestring) and name[0] != \"<\" and name[-1] != \">\":\n        return os.path.basename(name)\ndef extract_zipped_paths(path):\n    \"\"\"Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    \"\"\"",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "extract_zipped_paths",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def extract_zipped_paths(path):\n    \"\"\"Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    \"\"\"\n    if os.path.exists(path):\n        # this is already a valid path, no need to do anything further\n        return path\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "atomic_open",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def atomic_open(filename):\n    \"\"\"Write a file to the disk in an atomic fashion\"\"\"\n    tmp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))\n    try:\n        with os.fdopen(tmp_descriptor, \"wb\") as tmp_handler:\n            yield tmp_handler\n        os.replace(tmp_name, filename)\n    except BaseException:\n        os.remove(tmp_name)\n        raise",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "from_key_val_list",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def from_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. Unless it can not be represented as such, return an\n    OrderedDict, e.g.,\n    ::\n        >>> from_key_val_list([('key', 'val')])\n        OrderedDict([('key', 'val')])\n        >>> from_key_val_list('string')\n        Traceback (most recent call last):\n        ...",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "to_key_val_list",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def to_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. If it can be, return a list of tuples, e.g.,\n    ::\n        >>> to_key_val_list([('key', 'val')])\n        [('key', 'val')]\n        >>> to_key_val_list({'key': 'val'})\n        [('key', 'val')]\n        >>> to_key_val_list('string')\n        Traceback (most recent call last):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_list_header",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def parse_list_header(value):\n    \"\"\"Parse lists as described by RFC 2068 Section 2.\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Quotes are removed automatically after parsing.\n    It basically works like :func:`parse_set_header` just that items\n    may appear multiple times and case sensitivity is preserved.\n    The return value is a standard :class:`list`:\n    >>> parse_list_header('token, \"quoted value\"')",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_dict_header",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def parse_dict_header(value):\n    \"\"\"Parse lists of key, value pairs as described by RFC 2068 Section 2 and\n    convert them into a python dict:\n    >>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n    >>> type(d) is dict\n    True\n    >>> sorted(d.items())\n    [('bar', 'as well'), ('foo', 'is a fish')]\n    If there is no value for a key it will be `None`:\n    >>> parse_dict_header('key_without_value')",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "unquote_header_value",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def unquote_header_value(value, is_filename=False):\n    r\"\"\"Unquotes a header value.  (Reversal of :func:`quote_header_value`).\n    This does not use the real unquoting but what browsers are actually\n    using for quoting.\n    :param value: the header value to unquote.\n    :rtype: str\n    \"\"\"\n    if value and value[0] == value[-1] == '\"':\n        # this is not the real unquoting, but fixing this so that the\n        # RFC is met will result in bugs with internet explorer and",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "dict_from_cookiejar",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def dict_from_cookiejar(cj):\n    \"\"\"Returns a key/value dictionary from a CookieJar.\n    :param cj: CookieJar object to extract cookies from.\n    :rtype: dict\n    \"\"\"\n    cookie_dict = {cookie.name: cookie.value for cookie in cj}\n    return cookie_dict\ndef add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cj: CookieJar to insert cookies into.",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "add_dict_to_cookiejar",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n    :param cj: CookieJar to insert cookies into.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :rtype: CookieJar\n    \"\"\"\n    return cookiejar_from_dict(cookie_dict, cj)\ndef get_encodings_from_content(content):\n    \"\"\"Returns encodings from given content string.\n    :param content: bytestring to extract encodings from.",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_encodings_from_content",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def get_encodings_from_content(content):\n    \"\"\"Returns encodings from given content string.\n    :param content: bytestring to extract encodings from.\n    \"\"\"\n    warnings.warn(\n        (\n            \"In requests 3.0, get_encodings_from_content will be removed. For \"\n            \"more information, please see the discussion on issue #2266. (This\"\n            \" warning should only appear once.)\"\n        ),",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_encoding_from_headers",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def get_encoding_from_headers(headers):\n    \"\"\"Returns encodings from given HTTP Header Dict.\n    :param headers: dictionary to extract encoding from.\n    :rtype: str\n    \"\"\"\n    content_type = headers.get(\"content-type\")\n    if not content_type:\n        return None\n    content_type, params = _parse_content_type_header(content_type)\n    if \"charset\" in params:",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "stream_decode_response_unicode",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes an iterator.\"\"\"\n    if r.encoding is None:\n        yield from iterator\n        return\n    decoder = codecs.getincrementaldecoder(r.encoding)(errors=\"replace\")\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "iter_slices",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def iter_slices(string, slice_length):\n    \"\"\"Iterate over slices of a string.\"\"\"\n    pos = 0\n    if slice_length is None or slice_length <= 0:\n        slice_length = len(string)\n    while pos < len(string):\n        yield string[pos : pos + slice_length]\n        pos += slice_length\ndef get_unicode_from_response(r):\n    \"\"\"Returns the requested content back in unicode.",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_unicode_from_response",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def get_unicode_from_response(r):\n    \"\"\"Returns the requested content back in unicode.\n    :param r: Response object to get unicode content from.\n    Tried:\n    1. charset from content-type\n    2. fall back and replace all unicode characters\n    :rtype: str\n    \"\"\"\n    warnings.warn(\n        (",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "unquote_unreserved",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def unquote_unreserved(uri):\n    \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n    :rtype: str\n    \"\"\"\n    parts = uri.split(\"%\")\n    for i in range(1, len(parts)):\n        h = parts[i][0:2]\n        if len(h) == 2 and h.isalnum():\n            try:",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "requote_uri",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def requote_uri(uri):\n    \"\"\"Re-quote the given URI.\n    This function passes the given URI through an unquote/quote cycle to\n    ensure that it is fully and consistently quoted.\n    :rtype: str\n    \"\"\"\n    safe_with_percent = \"!#$%&'()*+,/:;=?@[]~\"\n    safe_without_percent = \"!#$&'()*+,/:;=?@[]~\"\n    try:\n        # Unquote only the unreserved characters",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "address_in_network",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n    :rtype: bool\n    \"\"\"\n    ipaddr = struct.unpack(\"=L\", socket.inet_aton(ip))[0]\n    netaddr, bits = net.split(\"/\")\n    netmask = struct.unpack(\"=L\", socket.inet_aton(dotted_netmask(int(bits))))[0]\n    network = struct.unpack(\"=L\", socket.inet_aton(netaddr))[0] & netmask",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "dotted_netmask",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def dotted_netmask(mask):\n    \"\"\"Converts mask from /xx format to xxx.xxx.xxx.xxx\n    Example: if mask is 24 function returns 255.255.255.0\n    :rtype: str\n    \"\"\"\n    bits = 0xFFFFFFFF ^ (1 << 32 - mask) - 1\n    return socket.inet_ntoa(struct.pack(\">I\", bits))\ndef is_ipv4_address(string_ip):\n    \"\"\"\n    :rtype: bool",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "is_ipv4_address",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def is_ipv4_address(string_ip):\n    \"\"\"\n    :rtype: bool\n    \"\"\"\n    try:\n        socket.inet_aton(string_ip)\n    except OSError:\n        return False\n    return True\ndef is_valid_cidr(string_network):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_cidr",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def is_valid_cidr(string_network):\n    \"\"\"\n    Very simple check of the cidr format in no_proxy variable.\n    :rtype: bool\n    \"\"\"\n    if string_network.count(\"/\") == 1:\n        try:\n            mask = int(string_network.split(\"/\")[1])\n        except ValueError:\n            return False",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "set_environ",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def set_environ(env_name, value):\n    \"\"\"Set the environment variable 'env_name' to 'value'\n    Save previous value, yield, and then restore the previous value stored in\n    the environment variable 'env_name'.\n    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "should_bypass_proxies",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def should_bypass_proxies(url, no_proxy):\n    \"\"\"\n    Returns whether we should bypass proxies or not.\n    :rtype: bool\n    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    def get_proxy(key):\n        return os.environ.get(key) or os.environ.get(key.upper())\n    # First check whether no_proxy is defined. If it is, check that the URL",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_environ_proxies",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def get_environ_proxies(url, no_proxy=None):\n    \"\"\"\n    Return a dict of environment proxies.\n    :rtype: dict\n    \"\"\"\n    if should_bypass_proxies(url, no_proxy=no_proxy):\n        return {}\n    else:\n        return getproxies()\ndef select_proxy(url, proxies):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "select_proxy",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def select_proxy(url, proxies):\n    \"\"\"Select a proxy for the url, if applicable.\n    :param url: The url being for the request\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get(\"all\"))\n    proxy_keys = [",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "resolve_proxies",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def resolve_proxies(request, proxies, trust_env=True):\n    \"\"\"This method takes proxy information from a request and configuration\n    input to resolve a mapping of target proxies. This will consider settings\n    such as NO_PROXY to strip proxy configurations.\n    :param request: Request or PreparedRequest\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    :param trust_env: Boolean declaring whether to trust environment configs\n    :rtype: dict\n    \"\"\"\n    proxies = proxies if proxies is not None else {}",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "default_user_agent",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def default_user_agent(name=\"python-requests\"):\n    \"\"\"\n    Return a string representing the default user agent.\n    :rtype: str\n    \"\"\"\n    return f\"{name}/{__version__}\"\ndef default_headers():\n    \"\"\"\n    :rtype: requests.structures.CaseInsensitiveDict\n    \"\"\"",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "default_headers",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def default_headers():\n    \"\"\"\n    :rtype: requests.structures.CaseInsensitiveDict\n    \"\"\"\n    return CaseInsensitiveDict(\n        {\n            \"User-Agent\": default_user_agent(),\n            \"Accept-Encoding\": DEFAULT_ACCEPT_ENCODING,\n            \"Accept\": \"*/*\",\n            \"Connection\": \"keep-alive\",",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "parse_header_links",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def parse_header_links(value):\n    \"\"\"Return a list of parsed link headers proxies.\n    i.e. Link: <http:/.../front.jpeg>; rel=front; type=\"image/jpeg\",<http://.../back.jpeg>; rel=back;type=\"image/jpeg\"\n    :rtype: list\n    \"\"\"\n    links = []\n    replace_chars = \" '\\\"\"\n    value = value.strip(replace_chars)\n    if not value:\n        return links",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "guess_json_utf",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]\n    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):\n        return \"utf-32\"  # BOM included",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "prepend_scheme_if_needed",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def prepend_scheme_if_needed(url, new_scheme):\n    \"\"\"Given a URL that may or may not have a scheme, prepend the given scheme.\n    Does not replace a present scheme with the one provided as an argument.\n    :rtype: str\n    \"\"\"\n    parsed = parse_url(url)\n    scheme, auth, host, port, path, query, fragment = parsed\n    # A defect in urlparse determines that there isn't a netloc present in some\n    # urls. We previously assumed parsing was overly cautious, and swapped the\n    # netloc and path. Due to a lack of tests on the original defect, this is",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "get_auth_from_url",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n    :rtype: (str,str)\n    \"\"\"\n    parsed = urlparse(url)\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = (\"\", \"\")",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "check_header_validity",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def check_header_validity(header):\n    \"\"\"Verifies that header parts don't contain leading whitespace\n    reserved characters, or return characters.\n    :param header: tuple, in the format (name, value).\n    \"\"\"\n    name, value = header\n    _validate_header_part(header, name, 0)\n    _validate_header_part(header, value, 1)\ndef _validate_header_part(header, header_part, header_validator_index):\n    if isinstance(header_part, str):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "urldefragauth",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def urldefragauth(url):\n    \"\"\"\n    Given a url remove the fragment and the authentication part.\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, params, query, fragment = urlparse(url)\n    # see func:`prepend_scheme_if_needed`\n    if not netloc:\n        netloc, path = path, netloc\n    netloc = netloc.rsplit(\"@\", 1)[-1]",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "rewind_body",
        "kind": 2,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "def rewind_body(prepared_request):\n    \"\"\"Move file pointer back to its recorded starting position\n    so it can be read again on redirect.\n    \"\"\"\n    body_seek = getattr(prepared_request.body, \"seek\", None)\n    if body_seek is not None and isinstance(\n        prepared_request._body_position, integer_types\n    ):\n        try:\n            body_seek(prepared_request._body_position)",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "NETRC_FILES",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "NETRC_FILES = (\".netrc\", \"_netrc\")\nDEFAULT_CA_BUNDLE_PATH = certs.where()\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CA_BUNDLE_PATH",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "DEFAULT_CA_BUNDLE_PATH = certs.where()\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PORTS",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "DEFAULT_PORTS = {\"http\": 80, \"https\": 443}\n# Ensure that ', ' is used to preserve previous delimiter behavior.\nDEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:\n            import winreg",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ACCEPT_ENCODING",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "DEFAULT_ACCEPT_ENCODING = \", \".join(\n    re.split(r\",\\s*\", make_headers(accept_encoding=True)[\"accept-encoding\"])\n)\nif sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n    def proxy_bypass_registry(host):\n        try:\n            import winreg\n        except ImportError:\n            return False",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "UNRESERVED_SET",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "UNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\"\n)\ndef unquote_unreserved(uri):\n    \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n    :rtype: str\n    \"\"\"\n    parts = uri.split(\"%\")\n    for i in range(1, len(parts)):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "_null = \"\\x00\".encode(\"ascii\")  # encoding to ASCII for Python 3\n_null2 = _null * 2\n_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null2",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "_null2 = _null * 2\n_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "_null3",
        "kind": 5,
        "importPath": ".build.functions.students.requests.utils",
        "description": ".build.functions.students.requests.utils",
        "peekOfCode": "_null3 = _null * 3\ndef guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]\n    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):",
        "detail": ".build.functions.students.requests.utils",
        "documentation": {}
    },
    {
        "label": "EmscriptenHTTPConnection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.connection",
        "description": ".build.functions.students.urllib3.contrib.emscripten.connection",
        "peekOfCode": "class EmscriptenHTTPConnection:\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]\n    default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n    timeout: None | (float)\n    host: str\n    port: int\n    blocksize: int\n    source_address: tuple[str, int] | None\n    socket_options: _TYPE_SOCKET_OPTIONS | None\n    proxy: Url | None",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.connection",
        "documentation": {}
    },
    {
        "label": "EmscriptenHTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.connection",
        "description": ".build.functions.students.urllib3.contrib.emscripten.connection",
        "peekOfCode": "class EmscriptenHTTPSConnection(EmscriptenHTTPConnection):\n    default_port = port_by_scheme[\"https\"]\n    # all this is basically ignored, as browser handles https\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None\n    cert_file: str | None\n    key_file: str | None\n    key_password: str | None",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.connection",
        "documentation": {}
    },
    {
        "label": "_RequestError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request\n        self.response = response",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_StreamingError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _StreamingError(_RequestError):\n    pass\nclass _TimeoutError(_RequestError):\n    pass\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_TimeoutError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _TimeoutError(_RequestError):\n    pass\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_ReadStream",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,\n        worker: JsProxy,\n        connection_id: int,\n        request: EmscriptenRequest,\n    ):",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_StreamingFetcher",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _StreamingFetcher:\n    def __init__(self) -> None:\n        # make web-worker and data buffer on startup\n        self.streaming_ready = False\n        streaming_worker_code = (\n            files(__package__)\n            .joinpath(\"emscripten_fetch_worker.js\")\n            .read_text(encoding=\"utf-8\")\n        )\n        js_data_blob = js.Blob.new(",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_JSPIReadStream",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "class _JSPIReadStream(io.RawIOBase):\n    \"\"\"\n    A read stream that uses pyodide.ffi.run_sync to read from a JavaScript fetch\n    response. This requires support for WebAssembly JavaScript Promise Integration\n    in the containing browser, and for pyodide to be launched via runPythonAsync.\n    :param js_read_stream:\n        The JavaScript stream reader\n    :param timeout:\n        Timeout in seconds\n    :param request:",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_in_browser_main_thread",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_in_browser_main_thread() -> bool:\n    return hasattr(js, \"window\") and hasattr(js, \"self\") and js.self == js.window\ndef is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_cross_origin_isolated",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\ndef is_worker_available() -> bool:",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_in_node",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\ndef is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n_fetcher: _StreamingFetcher | None = None",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "is_worker_available",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n_fetcher: _StreamingFetcher | None = None\nif is_worker_available() and (\n    (is_cross_origin_isolated() and not is_in_browser_main_thread())\n    and (not is_in_node())\n):\n    _fetcher = _StreamingFetcher()\nelse:\n    _fetcher = None",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_streaming_request",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if has_jspi():\n        return send_jspi_request(request, True)\n    elif is_in_node():\n        raise _RequestError(\n            message=NODE_JSPI_ERROR,\n            request=request,\n            response=None,\n        )\n    if _fetcher and streaming_ready():",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_request",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_request(request: EmscriptenRequest) -> EmscriptenResponse:\n    if has_jspi():\n        return send_jspi_request(request, False)\n    elif is_in_node():\n        raise _RequestError(\n            message=NODE_JSPI_ERROR,\n            request=request,\n            response=None,\n        )\n    try:",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "send_jspi_request",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def send_jspi_request(\n    request: EmscriptenRequest, streaming: bool\n) -> EmscriptenResponse:\n    \"\"\"\n    Send a request using WebAssembly JavaScript Promise Integration\n    to wrap the asynchronous JavaScript fetch api (experimental).\n    :param request:\n        Request to send\n    :param streaming:\n        Whether to stream the response",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "has_jspi",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def has_jspi() -> bool:\n    \"\"\"\n    Return true if jspi can be used.\n    This requires both browser support and also WebAssembly\n    to be in the correct state - i.e. that the javascript\n    call into python was async not sync.\n    :return: True if jspi can be used.\n    :rtype: bool\n    \"\"\"\n    try:",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "streaming_ready",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "def streaming_ready() -> bool | None:\n    if _fetcher:\n        return _fetcher.streaming_ready\n    else:\n        return None  # no fetcher, return None to signify that\nasync def wait_for_streaming_ready() -> bool:\n    if _fetcher:\n        await _fetcher.js_worker_ready_promise\n        return True\n    else:",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "HEADERS_TO_IGNORE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "HEADERS_TO_IGNORE = (\"user-agent\",)\nSUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "SUCCESS_HEADER",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "SUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "SUCCESS_EOF",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "SUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "ERROR_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "ERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "ERROR_EXCEPTION",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "ERROR_EXCEPTION = -4\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "NODE_JSPI_ERROR",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "NODE_JSPI_ERROR = (\n    \"urllib3 only works in Node.js with pyodide.runPythonAsync\"\n    \" and requires the flag --experimental-wasm-stack-switching in \"\n    \" versions of node <24.\"\n)\ndef send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if has_jspi():\n        return send_jspi_request(request, True)\n    elif is_in_node():\n        raise _RequestError(",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_SHOWN_TIMEOUT_WARNING",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "_SHOWN_TIMEOUT_WARNING = False\ndef _show_timeout_warning() -> None:\n    global _SHOWN_TIMEOUT_WARNING\n    if not _SHOWN_TIMEOUT_WARNING:\n        _SHOWN_TIMEOUT_WARNING = True\n        message = \"Warning: Timeout is not available on main browser thread\"\n        js.console.warn(message)\n_SHOWN_STREAMING_WARNING = False\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "_SHOWN_STREAMING_WARNING",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "description": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "peekOfCode": "_SHOWN_STREAMING_WARNING = False\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING\n    if not _SHOWN_STREAMING_WARNING:\n        _SHOWN_STREAMING_WARNING = True\n        message = \"Can't stream HTTP requests because: \\n\"\n        if not is_cross_origin_isolated():\n            message += \"  Page is not cross-origin isolated\\n\"\n        if is_in_browser_main_thread():\n            message += \"  Python is running in main browser thread\\n\"",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.fetch",
        "documentation": {}
    },
    {
        "label": "EmscriptenRequest",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.request",
        "description": ".build.functions.students.urllib3.contrib.emscripten.request",
        "peekOfCode": "class EmscriptenRequest:\n    method: str\n    url: str\n    params: dict[str, str] | None = None\n    body: _TYPE_BODY | None = None\n    headers: dict[str, str] = field(default_factory=dict)\n    timeout: float = 0\n    decode_content: bool = True\n    def set_header(self, name: str, value: str) -> None:\n        self.headers[name.capitalize()] = value",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.request",
        "documentation": {}
    },
    {
        "label": "EmscriptenResponse",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.response",
        "description": ".build.functions.students.urllib3.contrib.emscripten.response",
        "peekOfCode": "class EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "EmscriptenHttpResponseWrapper",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.response",
        "description": ".build.functions.students.urllib3.contrib.emscripten.response",
        "peekOfCode": "class EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,\n        connection: BaseHTTPConnection | BaseHTTPSConnection | None = None,\n    ):\n        self._pool = None  # set by pool class\n        self._body = None\n        self._response = internal_response",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.emscripten.response",
        "description": ".build.functions.students.urllib3.contrib.emscripten.response",
        "peekOfCode": "log = logging.getLogger(__name__)\n@dataclass\nclass EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,",
        "detail": ".build.functions.students.urllib3.contrib.emscripten.response",
        "documentation": {}
    },
    {
        "label": "WrappedSocket",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "class WrappedSocket:\n    \"\"\"API-compatibility wrapper for Python OpenSSL's Connection-class.\"\"\"\n    def __init__(\n        self,\n        connection: OpenSSL.SSL.Connection,\n        socket: socket_cls,\n        suppress_ragged_eofs: bool = True,\n    ) -> None:\n        self.connection = connection\n        self.socket = socket",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "PyOpenSSLContext",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "class PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)\n        self._options = 0",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "inject_into_urllib3",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "def inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n    util.SSLContext = orig_util_SSLContext",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "extract_from_urllib3",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "def extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n    util.SSLContext = orig_util_SSLContext\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.IS_PYOPENSSL = False\n    util.ssl_.IS_PYOPENSSL = False\ndef _validate_dependencies_met() -> None:\n    \"\"\"\n    Verifies that PyOpenSSL's package-level dependencies have been met.\n    Throws `ImportError` if they are not met.",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "get_subj_alt_name",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "def get_subj_alt_name(peer_cert: X509) -> list[tuple[str, str]]:\n    \"\"\"\n    Given an PyOpenSSL certificate, provides all the subject alternative names.\n    \"\"\"\n    cert = peer_cert.to_cryptography()\n    # We want to find the SAN extension. Ask Cryptography to locate it (it's\n    # faster than looping in Python)\n    try:\n        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value\n    except x509.ExtensionNotFound:",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "__all__ = [\"inject_into_urllib3\", \"extract_from_urllib3\"]\n# Map from urllib3 to PyOpenSSL compatible parameter-values.\n_openssl_versions: dict[int, int] = {\n    util.ssl_.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    util.ssl_.PROTOCOL_TLS_CLIENT: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,\n}\nif hasattr(ssl, \"PROTOCOL_TLSv1_1\") and hasattr(OpenSSL.SSL, \"TLSv1_1_METHOD\"):\n    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD\nif hasattr(ssl, \"PROTOCOL_TLSv1_2\") and hasattr(OpenSSL.SSL, \"TLSv1_2_METHOD\"):",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_stdlib_to_openssl_verify",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "_stdlib_to_openssl_verify = {\n    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,\n    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,\n    ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER\n    + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,\n}\n_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_openssl_to_stdlib_verify",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(\n    OpenSSL.SSL, \"OP_NO_SSLv3\", 0\n)\n_OP_NO_TLSv1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1\", 0)\n_OP_NO_TLSv1_1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_1\", 0)\n_OP_NO_TLSv1_2: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_2\", 0)\n_OP_NO_TLSv1_3: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_3\", 0)",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "SSL_WRITE_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "SSL_WRITE_BLOCKSIZE = 16384\norig_util_SSLContext = util.ssl_.SSLContext\nlog = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "orig_util_SSLContext",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "orig_util_SSLContext = util.ssl_.SSLContext\nlog = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n    _validate_dependencies_met()\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "WrappedSocket.makefile",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.contrib.pyopenssl",
        "description": ".build.functions.students.urllib3.contrib.pyopenssl",
        "peekOfCode": "WrappedSocket.makefile = socket_cls.makefile  # type: ignore[attr-defined]\nclass PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)",
        "detail": ".build.functions.students.urllib3.contrib.pyopenssl",
        "documentation": {}
    },
    {
        "label": "_TYPE_SOCKS_OPTIONS",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.socks",
        "description": ".build.functions.students.urllib3.contrib.socks",
        "peekOfCode": "class _TYPE_SOCKS_OPTIONS(typing.TypedDict):\n    socks_version: int\n    proxy_host: str | None\n    proxy_port: str | None\n    username: str | None\n    password: str | None\n    rdns: bool\nclass SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.",
        "detail": ".build.functions.students.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSConnection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.socks",
        "description": ".build.functions.students.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.\n    \"\"\"\n    def __init__(\n        self,\n        _socks_options: _TYPE_SOCKS_OPTIONS,\n        *args: typing.Any,\n        **kwargs: typing.Any,\n    ) -> None:",
        "detail": ".build.functions.students.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.socks",
        "description": ".build.functions.students.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection):\n    pass\nclass SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.",
        "detail": ".build.functions.students.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.socks",
        "description": ".build.functions.students.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {",
        "detail": ".build.functions.students.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSHTTPSConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.socks",
        "description": ".build.functions.students.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,",
        "detail": ".build.functions.students.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "SOCKSProxyManager",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.contrib.socks",
        "description": ".build.functions.students.urllib3.contrib.socks",
        "peekOfCode": "class SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,\n    }\n    def __init__(",
        "detail": ".build.functions.students.urllib3.contrib.socks",
        "documentation": {}
    },
    {
        "label": "_LockedObject",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "class _LockedObject(typing.Generic[T]):\n    \"\"\"\n    A wrapper class that hides a specific object behind a lock.\n    The goal here is to provide a simple way to protect access to an object\n    that cannot safely be simultaneously accessed from multiple threads. The\n    intended use of this class is simple: take hold of it with a context\n    manager, which returns the protected object.\n    \"\"\"\n    __slots__ = (\n        \"lock\",",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "HTTP2Connection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "class HTTP2Connection(HTTPSConnection):\n    def __init__(\n        self, host: str, port: int | None = None, **kwargs: typing.Any\n    ) -> None:\n        self._h2_conn = self._new_h2_conn()\n        self._h2_stream: int | None = None\n        self._headers: list[tuple[bytes, bytes]] = []\n        if \"proxy\" in kwargs or \"proxy_config\" in kwargs:  # Defensive:\n            raise NotImplementedError(\"Proxies aren't supported with HTTP/2\")\n        super().__init__(host, port, **kwargs)",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "HTTP2Response",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "class HTTP2Response(BaseHTTPResponse):\n    # TODO: This is a woefully incomplete response object, but works for non-streaming.\n    def __init__(\n        self,\n        status: int,\n        headers: HTTPHeaderDict,\n        request_url: str,\n        data: bytes,\n        decode_content: bool = False,  # TODO: support decoding\n    ) -> None:",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "orig_HTTPSConnection",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "orig_HTTPSConnection = HTTPSConnection\nT = typing.TypeVar(\"T\")\nlog = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "T = typing.TypeVar(\"T\")\nlog = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "log = logging.getLogger(__name__)\nRE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "RE_IS_LEGAL_HEADER_NAME",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "RE_IS_LEGAL_HEADER_NAME = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-z]+$\")\nRE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.\n    This does not allow for the `:` character in the header name, so should not",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "RE_IS_ILLEGAL_HEADER_VALUE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.connection",
        "description": ".build.functions.students.urllib3.http2.connection",
        "peekOfCode": "RE_IS_ILLEGAL_HEADER_VALUE = re.compile(rb\"[\\0\\x00\\x0a\\x0d\\r\\n]|^[ \\r\\n\\t]|[ \\r\\n\\t]$\")\ndef _is_legal_header_name(name: bytes) -> bool:\n    \"\"\"\n    \"An implementation that validates fields according to the definitions in Sections\n    5.1 and 5.5 of [HTTP] only needs an additional check that field names do not\n    include uppercase characters.\" (https://httpwg.org/specs/rfc9113.html#n-field-validity)\n    `http.client._is_legal_header_name` does not validate the field name according to the\n    HTTP 1.1 spec, so we do that here, in addition to checking for uppercase characters.\n    This does not allow for the `:` character in the header name, so should not\n    be used to validate pseudo-headers.",
        "detail": ".build.functions.students.urllib3.http2.connection",
        "documentation": {}
    },
    {
        "label": "_HTTP2ProbeCache",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.http2.probe",
        "description": ".build.functions.students.urllib3.http2.probe",
        "peekOfCode": "class _HTTP2ProbeCache:\n    __slots__ = (\n        \"_lock\",\n        \"_cache_locks\",\n        \"_cache_values\",\n    )\n    def __init__(self) -> None:\n        self._lock = threading.Lock()\n        self._cache_locks: dict[tuple[str, int], threading.RLock] = {}\n        self._cache_values: dict[tuple[str, int], bool | None] = {}",
        "detail": ".build.functions.students.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_HTTP2_PROBE_CACHE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.probe",
        "description": ".build.functions.students.urllib3.http2.probe",
        "peekOfCode": "_HTTP2_PROBE_CACHE = _HTTP2ProbeCache()\nset_and_release = _HTTP2_PROBE_CACHE.set_and_release\nacquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.students.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "set_and_release",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.probe",
        "description": ".build.functions.students.urllib3.http2.probe",
        "peekOfCode": "set_and_release = _HTTP2_PROBE_CACHE.set_and_release\nacquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.students.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "acquire_and_get",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.probe",
        "description": ".build.functions.students.urllib3.http2.probe",
        "peekOfCode": "acquire_and_get = _HTTP2_PROBE_CACHE.acquire_and_get\n_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.students.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_values",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.probe",
        "description": ".build.functions.students.urllib3.http2.probe",
        "peekOfCode": "_values = _HTTP2_PROBE_CACHE._values\n_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.students.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "_reset",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.probe",
        "description": ".build.functions.students.urllib3.http2.probe",
        "peekOfCode": "_reset = _HTTP2_PROBE_CACHE._reset\n__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.students.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.http2.probe",
        "description": ".build.functions.students.urllib3.http2.probe",
        "peekOfCode": "__all__ = [\n    \"set_and_release\",\n    \"acquire_and_get\",\n]",
        "detail": ".build.functions.students.urllib3.http2.probe",
        "documentation": {}
    },
    {
        "label": "is_connection_dropped",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.connection",
        "description": ".build.functions.students.urllib3.util.connection",
        "peekOfCode": "def is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n# This function is copied from socket.py in the Python 2.7 standard\n# library test suite. Added to its signature is only `socket_options`.\n# One additional modification is that we avoid binding to IPv6 servers\n# discovered in DNS if the system doesn't have IPv6 functionality.",
        "detail": ".build.functions.students.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "create_connection",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.connection",
        "description": ".build.functions.students.urllib3.util.connection",
        "peekOfCode": "def create_connection(\n    address: tuple[str, int],\n    timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n    source_address: tuple[str, int] | None = None,\n    socket_options: _TYPE_SOCKET_OPTIONS | None = None,\n) -> socket.socket:\n    \"\"\"Connect to *address* and return the socket object.\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance",
        "detail": ".build.functions.students.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "allowed_gai_family",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.connection",
        "description": ".build.functions.students.urllib3.util.connection",
        "peekOfCode": "def allowed_gai_family() -> socket.AddressFamily:\n    \"\"\"This function is designed to work in the context of\n    getaddrinfo, where family=socket.AF_UNSPEC is the default and\n    will perform a DNS search for both IPv6 and IPv4 records.\"\"\"\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family\ndef _has_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"",
        "detail": ".build.functions.students.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "_TYPE_SOCKET_OPTIONS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.connection",
        "description": ".build.functions.students.urllib3.util.connection",
        "peekOfCode": "_TYPE_SOCKET_OPTIONS = list[tuple[int, int, typing.Union[int, bytes]]]\nif typing.TYPE_CHECKING:\n    from .._base_connection import BaseHTTPConnection\ndef is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n# This function is copied from socket.py in the Python 2.7 standard",
        "detail": ".build.functions.students.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "HAS_IPV6",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.connection",
        "description": ".build.functions.students.urllib3.util.connection",
        "peekOfCode": "HAS_IPV6 = _has_ipv6(\"::1\")",
        "detail": ".build.functions.students.urllib3.util.connection",
        "documentation": {}
    },
    {
        "label": "connection_requires_http_tunnel",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.proxy",
        "description": ".build.functions.students.urllib3.util.proxy",
        "peekOfCode": "def connection_requires_http_tunnel(\n    proxy_url: Url | None = None,\n    proxy_config: ProxyConfig | None = None,\n    destination_scheme: str | None = None,\n) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:",
        "detail": ".build.functions.students.urllib3.util.proxy",
        "documentation": {}
    },
    {
        "label": "_TYPE_FAILEDTELL",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "class _TYPE_FAILEDTELL(Enum):\n    token = 0\n_FAILEDTELL: Final[_TYPE_FAILEDTELL] = _TYPE_FAILEDTELL.token\n_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "ChunksAndContentLength",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "class ChunksAndContentLength(typing.NamedTuple):\n    chunks: typing.Iterable[bytes] | None\n    content_length: int | None\ndef body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n    A 'Content-Length' of 'None' indicates the length of the body",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "make_headers",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "def make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"\n    Shortcuts for generating request headers.",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "set_file_position",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "def set_file_position(\n    body: typing.Any, pos: _TYPE_BODY_POSITION | None\n) -> _TYPE_BODY_POSITION | None:\n    \"\"\"\n    If a position is provided, move file to that point.\n    Otherwise, we'll attempt to record a position for future use.\n    \"\"\"\n    if pos is not None:\n        rewind_body(body, pos)\n    elif getattr(body, \"tell\", None) is not None:",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "rewind_body",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "def rewind_body(body: typing.IO[typing.AnyStr], body_pos: _TYPE_BODY_POSITION) -> None:\n    \"\"\"\n    Attempt to rewind body to a certain position.\n    Primarily used for request redirects and retries.\n    :param body:\n        File-like object that supports seek.\n    :param int pos:\n        Position to seek to in file.\n    \"\"\"\n    body_seek = getattr(body, \"seek\", None)",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "body_to_chunks",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "def body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n    A 'Content-Length' of 'None' indicates the length of the body\n    can't be determined so should use 'Transfer-Encoding: chunked'\n    for framing instead.\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "SKIP_HEADER",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "SKIP_HEADER = \"@@@SKIP_HEADER@@@\"\nSKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "SKIPPABLE_HEADERS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "SKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "ACCEPT_ENCODING",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "ACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:\n    ACCEPT_ENCODING += \",br\"",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "_TYPE_BODY_POSITION",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "_METHODS_NOT_EXPECTING_BODY",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.request",
        "description": ".build.functions.students.urllib3.util.request",
        "peekOfCode": "_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.util.request",
        "documentation": {}
    },
    {
        "label": "is_fp_closed",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.response",
        "description": ".build.functions.students.urllib3.util.response",
        "peekOfCode": "def is_fp_closed(obj: object) -> bool:\n    \"\"\"\n    Checks whether a given file-like object is closed.\n    :param obj:\n        The file-like object to check.\n    \"\"\"\n    try:\n        # Check `isclosed()` first, in case Python3 doesn't set `closed`.\n        # GH Issue #928\n        return obj.isclosed()  # type: ignore[no-any-return, attr-defined]",
        "detail": ".build.functions.students.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "assert_header_parsing",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.response",
        "description": ".build.functions.students.urllib3.util.response",
        "peekOfCode": "def assert_header_parsing(headers: httplib.HTTPMessage) -> None:\n    \"\"\"\n    Asserts whether all headers have been successfully parsed.\n    Extracts encountered errors from the result of parsing headers.\n    Only works on Python 3.\n    :param http.client.HTTPMessage headers: Headers to verify.\n    :raises urllib3.exceptions.HeaderParsingError:\n        If parsing errors are found.\n    \"\"\"\n    # This will fail silently if we pass in the wrong kind of parameter.",
        "detail": ".build.functions.students.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "is_response_to_head",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.response",
        "description": ".build.functions.students.urllib3.util.response",
        "peekOfCode": "def is_response_to_head(response: httplib.HTTPResponse) -> bool:\n    \"\"\"\n    Checks whether the request of a response has been a HEAD-request.\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    \"\"\"\n    # FIXME: Can we do this somehow without accessing private httplib _method?\n    method_str = response._method  # type: str  # type: ignore[attr-defined]\n    return method_str.upper() == \"HEAD\"",
        "detail": ".build.functions.students.urllib3.util.response",
        "documentation": {}
    },
    {
        "label": "RequestHistory",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.retry",
        "description": ".build.functions.students.urllib3.util.retry",
        "peekOfCode": "class RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\nclass Retry:\n    \"\"\"Retry configuration.\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.",
        "detail": ".build.functions.students.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.retry",
        "description": ".build.functions.students.urllib3.util.retry",
        "peekOfCode": "class Retry:\n    \"\"\"Retry configuration.\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n    Retries can be defined as a default for a pool:\n    .. code-block:: python\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request(\"GET\", \"https://example.com/\")\n    Or per-request (which overrides the default for the pool):",
        "detail": ".build.functions.students.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.retry",
        "description": ".build.functions.students.urllib3.util.retry",
        "peekOfCode": "log = logging.getLogger(__name__)\n# Data structure for representing the metadata of requests that result in a retry.\nclass RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\nclass Retry:\n    \"\"\"Retry configuration.",
        "detail": ".build.functions.students.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "Retry.DEFAULT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.retry",
        "description": ".build.functions.students.urllib3.util.retry",
        "peekOfCode": "Retry.DEFAULT = Retry(3)",
        "detail": ".build.functions.students.urllib3.util.retry",
        "documentation": {}
    },
    {
        "label": "assert_fingerprint",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n    if cert is None:\n        raise SSLError(\"No certificate for the peer.\")",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "resolve_cert_reqs",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def resolve_cert_reqs(candidate: None | int | str) -> VerifyMode:\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "resolve_ssl_version",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def resolve_ssl_version(candidate: None | int | str) -> int:\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "create_urllib3_context",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def create_urllib3_context(\n    ssl_version: int | None = None,\n    cert_reqs: int | None = None,\n    options: int | None = None,\n    ciphers: str | None = None,\n    ssl_minimum_version: int | None = None,\n    ssl_maximum_version: int | None = None,\n    verify_flags: int | None = None,\n) -> ssl.SSLContext:\n    \"\"\"Creates and configures an :class:`ssl.SSLContext` instance for use with urllib3.",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ssl_wrap_socket",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = None,\n    certfile: str | None = None,\n    cert_reqs: int | None = None,\n    ca_certs: str | None = None,\n    server_hostname: str | None = None,\n    ssl_version: int | None = None,\n    ciphers: str | None = None,\n    ssl_context: ssl.SSLContext | None = None,",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "is_ipaddress",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "def is_ipaddress(hostname: str | bytes) -> bool:\n    \"\"\"Detects whether the hostname given is an IPv4 or IPv6 address.\n    Also detects IPv6 addresses with Zone IDs.\n    :param str hostname: Hostname to examine.\n    :return: True if the hostname is an IP address, False otherwise.\n    \"\"\"\n    if isinstance(hostname, bytes):\n        # IDN A-label bytes are ASCII compatible.\n        hostname = hostname.decode(\"ascii\")\n    return bool(_IPV4_RE.match(hostname) or _BRACELESS_IPV6_ADDRZ_RE.match(hostname))",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "SSLContext",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "SSLContext = None\nSSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "SSLTransport",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "SSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "HAS_NEVER_CHECK_COMMON_NAME",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "HAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "IS_PYOPENSSL",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "IS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "ALPN_PROTOCOLS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "ALPN_PROTOCOLS = [\"http/1.1\"]\n_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "_TYPE_VERSION_INFO",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "_TYPE_VERSION_INFO = tuple[int, int, int, str, int]\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "HASHFUNC_MAP",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "HASHFUNC_MAP = {\n    length: getattr(hashlib, algorithm, None)\n    for length, algorithm in ((32, \"md5\"), (40, \"sha1\"), (64, \"sha256\"))\n}\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,\n) -> bool:\n    \"\"\"Return True for CPython 3.9.3+ or 3.10+ and PyPy 7.3.8+ where",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "_TYPE_PEER_CERT_RET",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_",
        "description": ".build.functions.students.urllib3.util.ssl_",
        "peekOfCode": "_TYPE_PEER_CERT_RET = typing.Union[\"_TYPE_PEER_CERT_RET_DICT\", bytes, None]\ndef assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n    if cert is None:",
        "detail": ".build.functions.students.urllib3.util.ssl_",
        "documentation": {}
    },
    {
        "label": "CertificateError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "peekOfCode": "class CertificateError(ValueError):\n    pass\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:",
        "detail": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "match_hostname",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "peekOfCode": "def match_hostname(\n    cert: _TYPE_PEER_CERT_RET_DICT | None,\n    hostname: str,\n    hostname_checks_common_name: bool = False,\n) -> None:\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n    CertificateError is raised on failure. On success, the function\n    returns nothing.",
        "detail": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "description": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "peekOfCode": "__version__ = \"3.5.0.1\"\nclass CertificateError(ValueError):\n    pass\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []",
        "detail": ".build.functions.students.urllib3.util.ssl_match_hostname",
        "documentation": {}
    },
    {
        "label": "SSLTransport",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.ssltransport",
        "description": ".build.functions.students.urllib3.util.ssltransport",
        "peekOfCode": "class SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"\n    @staticmethod\n    def _validate_ssl_context_for_tls_in_tls(ssl_context: ssl.SSLContext) -> None:",
        "detail": ".build.functions.students.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_WriteBuffer",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssltransport",
        "description": ".build.functions.students.urllib3.util.ssltransport",
        "peekOfCode": "_WriteBuffer = typing.Union[bytearray, memoryview]\n_ReturnValue = typing.TypeVar(\"_ReturnValue\")\nSSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.",
        "detail": ".build.functions.students.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_ReturnValue",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssltransport",
        "description": ".build.functions.students.urllib3.util.ssltransport",
        "peekOfCode": "_ReturnValue = typing.TypeVar(\"_ReturnValue\")\nSSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "SSL_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.ssltransport",
        "description": ".build.functions.students.urllib3.util.ssltransport",
        "peekOfCode": "SSL_BLOCKSIZE = 16384\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n    The class supports most of the socket API operations.\n    \"\"\"\n    @staticmethod",
        "detail": ".build.functions.students.urllib3.util.ssltransport",
        "documentation": {}
    },
    {
        "label": "_TYPE_DEFAULT",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.timeout",
        "description": ".build.functions.students.urllib3.util.timeout",
        "peekOfCode": "class _TYPE_DEFAULT(Enum):\n    # This value should never be passed to socket.settimeout() so for safety we use a -1.\n    # socket.settimout() raises a ValueError for negative values.\n    token = -1\n_DEFAULT_TIMEOUT: Final[_TYPE_DEFAULT] = _TYPE_DEFAULT.token\n_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\nclass Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python",
        "detail": ".build.functions.students.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.timeout",
        "description": ".build.functions.students.urllib3.util.timeout",
        "peekOfCode": "class Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python\n        import urllib3\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n        http = urllib3.PoolManager(timeout=timeout)\n        resp = http.request(\"GET\", \"https://example.com/\")\n        print(resp.status)\n    Or per-request (which overrides the default for the pool):",
        "detail": ".build.functions.students.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "_TYPE_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.timeout",
        "description": ".build.functions.students.urllib3.util.timeout",
        "peekOfCode": "_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\nclass Timeout:\n    \"\"\"Timeout configuration.\n    Timeouts can be defined as a default for a pool:\n    .. code-block:: python\n        import urllib3\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n        http = urllib3.PoolManager(timeout=timeout)\n        resp = http.request(\"GET\", \"https://example.com/\")\n        print(resp.status)",
        "detail": ".build.functions.students.urllib3.util.timeout",
        "documentation": {}
    },
    {
        "label": "Url",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "class Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),\n            (\"query\", typing.Optional[str]),",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "def parse_url(url: str) -> Url:\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 and RFC 6874 compliant.\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n    Partly backwards-compatible with :mod:`urllib.parse`.\n    Example:",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_NORMALIZABLE_SCHEMES",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_NORMALIZABLE_SCHEMES = (\"http\", \"https\", None)\n# Almost all of these patterns were derived from the\n# 'rfc3986' module: https://github.com/python-hyper/rfc3986\n_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_PERCENT_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_SCHEME_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_URI_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV4_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HEX_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_LS32_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_subs",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_variations",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",\n    # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_UNRESERVED_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\\-~\"\n_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_ZONE_ID_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_ADDRZ_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_REG_NAME_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_TARGET_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV4_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_IPV6_ADDRZ_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_BRACELESS_IPV6_ADDRZ_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_ZONE_ID_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HOST_PORT_PAT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_HOST_PORT_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_UNRESERVED_CHARS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_SUB_DELIM_CHARS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_USERINFO_CHARS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_PATH_CHARS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "_QUERY_CHARS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.url",
        "description": ".build.functions.students.urllib3.util.url",
        "peekOfCode": "_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),",
        "detail": ".build.functions.students.urllib3.util.url",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.util",
        "description": ".build.functions.students.urllib3.util.util",
        "peekOfCode": "def to_bytes(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> bytes:\n    if isinstance(x, bytes):\n        return x\n    elif not isinstance(x, str):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.encode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.encode()",
        "detail": ".build.functions.students.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "to_str",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.util",
        "description": ".build.functions.students.urllib3.util.util",
        "peekOfCode": "def to_str(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> str:\n    if isinstance(x, str):\n        return x\n    elif not isinstance(x, bytes):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.decode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.decode()",
        "detail": ".build.functions.students.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "reraise",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.util",
        "description": ".build.functions.students.urllib3.util.util",
        "peekOfCode": "def reraise(\n    tp: type[BaseException] | None,\n    value: BaseException,\n    tb: TracebackType | None = None,\n) -> typing.NoReturn:\n    try:\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:",
        "detail": ".build.functions.students.urllib3.util.util",
        "documentation": {}
    },
    {
        "label": "select_wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.wait",
        "description": ".build.functions.students.urllib3.util.wait",
        "peekOfCode": "def select_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    rcheck = []\n    wcheck = []",
        "detail": ".build.functions.students.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "poll_wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.wait",
        "description": ".build.functions.students.urllib3.util.wait",
        "peekOfCode": "def poll_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    mask = 0\n    if read:",
        "detail": ".build.functions.students.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_socket",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.wait",
        "description": ".build.functions.students.urllib3.util.wait",
        "peekOfCode": "def wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    # We delay choosing which implementation to use until the first time we're\n    # called. We could do it at import time, but then we might make the wrong\n    # decision if someone goes wild with monkeypatching select.poll after\n    # we're imported.",
        "detail": ".build.functions.students.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_read",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.wait",
        "description": ".build.functions.students.urllib3.util.wait",
        "peekOfCode": "def wait_for_read(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for reading to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, read=True, timeout=timeout)\ndef wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)",
        "detail": ".build.functions.students.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "wait_for_write",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.util.wait",
        "description": ".build.functions.students.urllib3.util.wait",
        "peekOfCode": "def wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)",
        "detail": ".build.functions.students.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.util.wait",
        "description": ".build.functions.students.urllib3.util.wait",
        "peekOfCode": "__all__ = [\"wait_for_read\", \"wait_for_write\"]\n# How should we wait on sockets?\n#\n# There are two types of APIs you can use for waiting on sockets: the fancy\n# modern stateful APIs like epoll/kqueue, and the older stateless APIs like\n# select/poll. The stateful APIs are more efficient when you have a lots of\n# sockets to keep track of, because you can set them up once and then use them\n# lots of times. But we only ever want to wait on a single socket at a time\n# and don't want to keep track of state, so the stateless APIs are actually\n# more efficient. So we want to use select() or poll().",
        "detail": ".build.functions.students.urllib3.util.wait",
        "documentation": {}
    },
    {
        "label": "ProxyConfig",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3._base_connection",
        "description": ".build.functions.students.urllib3._base_connection",
        "peekOfCode": "class ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str",
        "detail": ".build.functions.students.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_ResponseOptions",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3._base_connection",
        "description": ".build.functions.students.urllib3._base_connection",
        "peekOfCode": "class _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str\n    preload_content: bool\n    decode_content: bool\n    enforce_content_length: bool\nif typing.TYPE_CHECKING:\n    import ssl",
        "detail": ".build.functions.students.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_TYPE_BODY",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._base_connection",
        "description": ".build.functions.students.urllib3._base_connection",
        "peekOfCode": "_TYPE_BODY = typing.Union[bytes, typing.IO[typing.Any], typing.Iterable[bytes], str]\nclass ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str",
        "detail": ".build.functions.students.urllib3._base_connection",
        "documentation": {}
    },
    {
        "label": "_Sentinel",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "class _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "RecentlyUsedContainer",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "class RecentlyUsedContainer(typing.Generic[_KT, _VT], typing.MutableMapping[_KT, _VT]):\n    \"\"\"\n    Provides a thread-safe dict-like container which maintains up to\n    ``maxsize`` keys while throwing away the least-recently-used keys beyond\n    ``maxsize``.\n    :param maxsize:\n        Maximum number of recent elements to retain.\n    :param dispose_func:\n        Every time an item is evicted from the container,\n        ``dispose_func(value)`` is called.  Callback which will get called",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "HTTPHeaderDictItemView",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "class HTTPHeaderDictItemView(set[tuple[str, str]]):\n    \"\"\"\n    HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of\n    address.\n    If we directly try to get an item with a particular name, we will get a string\n    back that is the concatenated version of all the values:\n    >>> d['X-Header-Name']\n    'Value1, Value2, Value3'\n    However, if we iterate over an HTTPHeaderDict's items, we will optionally combine\n    these values based on whether combine=True was called when building up the dictionary",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "HTTPHeaderDict",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "class HTTPHeaderDict(typing.MutableMapping[str, str]):\n    \"\"\"\n    :param headers:\n        An iterable of field-value pairs. Must not contain multiple field names\n        when compared case-insensitively.\n    :param kwargs:\n        Additional field-value pairs to pass in to ``dict.update``.\n    A ``dict`` like container for storing HTTP Headers.\n    Field names are stored and compared case-insensitively in compliance with\n    RFC 7230. Iteration provides the first case-sensitive key seen for each",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "ensure_can_construct_http_header_dict",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "def ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.\n        return typing.cast(typing.Mapping[str, str], potential)\n    elif isinstance(potential, typing.Iterable):",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "__all__ = [\"RecentlyUsedContainer\", \"HTTPHeaderDict\"]\n# Key type\n_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_KT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_VT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "_DT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "_DT = typing.TypeVar(\"_DT\")\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "ValidHTTPHeaderSource",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._collections",
        "description": ".build.functions.students.urllib3._collections",
        "peekOfCode": "ValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\nclass _Sentinel(Enum):\n    not_passed = auto()\ndef ensure_can_construct_http_header_dict(\n    potential: object,",
        "detail": ".build.functions.students.urllib3._collections",
        "documentation": {}
    },
    {
        "label": "RequestMethods",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3._request_methods",
        "description": ".build.functions.students.urllib3._request_methods",
        "peekOfCode": "class RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n    Provides behavior for making common types of HTTP request methods and\n    decides which type of request field encoding to use.\n    Specifically,\n    :meth:`.request_encode_url` is for sending requests whose fields are\n    encoded in the URL (such as GET, HEAD, DELETE).",
        "detail": ".build.functions.students.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._request_methods",
        "description": ".build.functions.students.urllib3._request_methods",
        "peekOfCode": "__all__ = [\"RequestMethods\"]\n_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.",
        "detail": ".build.functions.students.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "_TYPE_ENCODE_URL_FIELDS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._request_methods",
        "description": ".build.functions.students.urllib3._request_methods",
        "peekOfCode": "_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n    Provides behavior for making common types of HTTP request methods and",
        "detail": ".build.functions.students.urllib3._request_methods",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._version",
        "description": ".build.functions.students.urllib3._version",
        "peekOfCode": "__all__ = [\n    \"__version__\",\n    \"__version_tuple__\",\n    \"version\",\n    \"version_tuple\",\n    \"__commit_id__\",\n    \"commit_id\",\n]\nTYPE_CHECKING = False\nif TYPE_CHECKING:",
        "detail": ".build.functions.students.urllib3._version",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._version",
        "description": ".build.functions.students.urllib3._version",
        "peekOfCode": "TYPE_CHECKING = False\nif TYPE_CHECKING:\n    from typing import Tuple\n    from typing import Union\n    VERSION_TUPLE = Tuple[Union[int, str], ...]\n    COMMIT_ID = Union[str, None]\nelse:\n    VERSION_TUPLE = object\n    COMMIT_ID = object\nversion: str",
        "detail": ".build.functions.students.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._version",
        "description": ".build.functions.students.urllib3._version",
        "peekOfCode": "__version__ = version = '2.6.3'\n__version_tuple__ = version_tuple = (2, 6, 3)\n__commit_id__ = commit_id = None",
        "detail": ".build.functions.students.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._version",
        "description": ".build.functions.students.urllib3._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (2, 6, 3)\n__commit_id__ = commit_id = None",
        "detail": ".build.functions.students.urllib3._version",
        "documentation": {}
    },
    {
        "label": "__commit_id__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3._version",
        "description": ".build.functions.students.urllib3._version",
        "peekOfCode": "__commit_id__ = commit_id = None",
        "detail": ".build.functions.students.urllib3._version",
        "documentation": {}
    },
    {
        "label": "HTTPConnection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "class HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling\n      Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "HTTPSConnection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "class HTTPSConnection(HTTPConnection):\n    \"\"\"\n    Many of the parameters to this constructor are passed to the underlying SSL\n    socket by means of :py:func:`urllib3.util.ssl_wrap_socket`.\n    \"\"\"\n    default_port = port_by_scheme[\"https\"]  # type: ignore[misc]\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "_WrappedAndVerifiedSocket",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "class _WrappedAndVerifiedSocket(typing.NamedTuple):\n    \"\"\"\n    Wrapped socket and whether the connection is\n    verified after the TLS handshake\n    \"\"\"\n    socket: ssl.SSLSocket | SSLTransport\n    is_verified: bool\ndef _ssl_wrap_socket_and_match_hostname(\n    sock: socket.socket,\n    *,",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "DummyConnection",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "class DummyConnection:\n    \"\"\"Used to detect a failed ConnectionCls import.\"\"\"\nif not ssl:\n    HTTPSConnection = DummyConnection  # type: ignore[misc, assignment] # noqa: F811\nVerifiedHTTPSConnection = HTTPSConnection\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "ConnectionError = ConnectionError\nBrokenPipeError = BrokenPipeError\nlog = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "BrokenPipeError",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "BrokenPipeError = BrokenPipeError\nlog = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "log = logging.getLogger(__name__)\nport_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "port_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "port_by_scheme = {\"http\": 80, \"https\": 443}\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "RECENT_DATE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "RECENT_DATE = datetime.date(2025, 1, 1)\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "_CONTAINS_CONTROL_CHAR_RE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "VerifiedHTTPSConnection",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connection",
        "description": ".build.functions.students.urllib3.connection",
        "peekOfCode": "VerifiedHTTPSConnection = HTTPSConnection\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"\n    return Url(scheme=scheme, host=conn.host, port=conn.port, path=path).url",
        "detail": ".build.functions.students.urllib3.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.connectionpool",
        "description": ".build.functions.students.urllib3.connectionpool",
        "peekOfCode": "class ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.\n    \"\"\"\n    scheme: str | None = None",
        "detail": ".build.functions.students.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.connectionpool",
        "description": ".build.functions.students.urllib3.connectionpool",
        "peekOfCode": "class HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n    :param timeout:",
        "detail": ".build.functions.students.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPSConnectionPool",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.connectionpool",
        "description": ".build.functions.students.urllib3.connectionpool",
        "peekOfCode": "class HTTPSConnectionPool(HTTPConnectionPool):\n    \"\"\"\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.",
        "detail": ".build.functions.students.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "connection_from_url",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.connectionpool",
        "description": ".build.functions.students.urllib3.connectionpool",
        "peekOfCode": "def connection_from_url(url: str, **kw: typing.Any) -> HTTPConnectionPool:\n    \"\"\"\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n    :param \\\\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like",
        "detail": ".build.functions.students.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connectionpool",
        "description": ".build.functions.students.urllib3.connectionpool",
        "peekOfCode": "log = logging.getLogger(__name__)\n_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded",
        "detail": ".build.functions.students.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "_TYPE_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connectionpool",
        "description": ".build.functions.students.urllib3.connectionpool",
        "peekOfCode": "_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.",
        "detail": ".build.functions.students.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "_blocking_errnos",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.connectionpool",
        "description": ".build.functions.students.urllib3.connectionpool",
        "peekOfCode": "_blocking_errnos = {errno.EAGAIN, errno.EWOULDBLOCK}\nclass HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.",
        "detail": ".build.functions.students.urllib3.connectionpool",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class HTTPError(Exception):\n    \"\"\"Base exception used by this module.\"\"\"\nclass HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HTTPWarning",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "PoolError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)\nclass RequestError(PoolError):",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class RequestError(PoolError):\n    \"\"\"Base exception for PoolErrors that have associated URLs.\"\"\"\n    def __init__(self, pool: ConnectionPool, url: str | None, message: str) -> None:\n        self.url = url\n        super().__init__(pool, message)\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self.url, self._message)\nclass SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SSLError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"\nclass ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n    # The original error is also available as __cause__.\n    original_error: Exception\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\nclass DecodeError(HTTPError):",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxyError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n    # The original error is also available as __cause__.\n    original_error: Exception\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\nclass DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\nclass ProtocolError(HTTPError):",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DecodeError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\nclass ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "MaxRetryError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n    \"\"\"\n    def __init__(\n        self, pool: ConnectionPool, url: str | None, reason: Exception | None = None",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HostChangedError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class HostChangedError(RequestError):\n    \"\"\"Raised when an existing pool gets a request for a foreign host.\"\"\"\n    def __init__(\n        self, pool: ConnectionPool, url: str, retries: Retry | int = 3\n    ) -> None:\n        message = f\"Tried to open a foreign host with url: {url}\"\n        super().__init__(pool, url, message)\n        self.retries = retries\nclass TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutStateError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"\nclass TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ReadTimeoutError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectTimeoutError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        self._message = message\n        super().__init__(f\"{conn}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NewConnectionError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        self._message = message\n        super().__init__(f\"{conn}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)\n    @property",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NameResolutionError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class NameResolutionError(NewConnectionError):\n    \"\"\"Raised when host name resolution fails.\"\"\"\n    def __init__(self, host: str, conn: HTTPConnection, reason: socket.gaierror):\n        message = f\"Failed to resolve '{host}' ({reason})\"\n        self._host = host\n        self._reason = reason\n        super().__init__(conn, message)\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (self._host, None, self._reason)",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyPoolError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class EmptyPoolError(PoolError):\n    \"\"\"Raised when a pool runs out of connections and no more are allowed.\"\"\"\nclass FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "FullPoolError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ClosedPoolError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationValueError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n        self.location = location\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "URLSchemeUnknown",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"\n        super().__init__(message)\n        self.scheme = scheme\nclass ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"\nclass SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SecurityWarning",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InsecureRequestWarning",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "NotOpenSSLWarning",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "SystemTimeWarning",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InsecurePlatformWarning",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "DependencyWarning",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ResponseNotChunked",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "BodyNotHttplibCompatible",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "IncompleteRead",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.\n    \"\"\"\n    partial: int  # type: ignore[assignment]\n    expected: int\n    def __init__(self, partial: int, expected: int) -> None:\n        self.partial = partial",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidChunkLength",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class InvalidChunkLength(HTTPError, httplib_IncompleteRead):\n    \"\"\"Invalid chunk length in a chunked response.\"\"\"\n    def __init__(self, response: HTTPResponse, length: bytes) -> None:\n        self.partial: int = response.tell()  # type: ignore[assignment]\n        self.expected: int | None = response.length_remaining\n        self.response = response\n        self.length = length\n    def __repr__(self) -> str:\n        return \"InvalidChunkLength(got length %r, %i bytes read)\" % (\n            self.length,",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidHeader",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class InvalidHeader(HTTPError):\n    \"\"\"The header provided was somehow invalid.\"\"\"\nclass ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxySchemeUnknown",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None\n        if scheme is None:\n            message = \"Proxy URL had no scheme, should start with http:// or https://\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ProxySchemeUnsupported",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class ProxySchemeUnsupported(ValueError):\n    \"\"\"Fetching HTTPS resources through HTTPS proxies is unsupported\"\"\"\nclass HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\nclass UnrewindableBodyError(HTTPError):",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "HeaderParsingError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\nclass UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "UnrewindableBodyError",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "class UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "_TYPE_REDUCE_RESULT",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "_TYPE_REDUCE_RESULT = tuple[typing.Callable[..., object], tuple[object, ...]]\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        self._message = message\n        super().__init__(f\"{pool}: {message}\")\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self._message)",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "ConnectionError",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.exceptions",
        "description": ".build.functions.students.urllib3.exceptions",
        "peekOfCode": "ConnectionError = ProtocolError\n# Leaf Exceptions\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "RequestField",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "class RequestField:\n    \"\"\"\n    A data container for request body parameters.\n    :param name:\n        The name of this request field. Must be unicode.\n    :param data:\n        The data/value body.\n    :param filename:\n        An optional filename of the request field. Must be unicode.\n    :param headers:",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "guess_content_type",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "def guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.\n    :param filename:\n        The filename to guess the \"Content-Type\" of using :mod:`mimetypes`.\n    :param default:\n        If no \"Content-Type\" can be guessed, default to `default`.\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param_rfc2231",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "def format_header_param_rfc2231(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Helper function to format and quote a single header parameter using the\n    strategy defined in RFC 2231.\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows\n    `RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_multipart_header_param",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "def format_multipart_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Format and quote a single multipart header parameter.\n    This follows the `WHATWG HTML Standard`_ as of 2021/06/10, matching\n    the behavior of current browser and curl versions. Values are\n    assumed to be UTF-8. The ``\\\\n``, ``\\\\r``, and ``\"`` characters are\n    percent encoded.\n    .. _WHATWG HTML Standard:\n        https://html.spec.whatwg.org/multipage/\n        form-control-infrastructure.html#multipart-form-data",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param_html5",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "def format_header_param_html5(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n    warnings.warn(\n        \"'format_header_param_html5' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "format_header_param",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "def format_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n    warnings.warn(\n        \"'format_header_param' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELD_VALUE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "_TYPE_FIELD_VALUE = typing.Union[str, bytes]\n_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    tuple[str, _TYPE_FIELD_VALUE],\n    tuple[str, _TYPE_FIELD_VALUE, str],\n]\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELD_VALUE_TUPLE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.fields",
        "description": ".build.functions.students.urllib3.fields",
        "peekOfCode": "_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    tuple[str, _TYPE_FIELD_VALUE],\n    tuple[str, _TYPE_FIELD_VALUE, str],\n]\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.",
        "detail": ".build.functions.students.urllib3.fields",
        "documentation": {}
    },
    {
        "label": "choose_boundary",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.filepost",
        "description": ".build.functions.students.urllib3.filepost",
        "peekOfCode": "def choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.",
        "detail": ".build.functions.students.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "iter_field_objects",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.filepost",
        "description": ".build.functions.students.urllib3.filepost",
        "peekOfCode": "def iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.\n    \"\"\"\n    iterable: typing.Iterable[RequestField | tuple[str, _TYPE_FIELD_VALUE_TUPLE]]\n    if isinstance(fields, typing.Mapping):\n        iterable = fields.items()\n    else:",
        "detail": ".build.functions.students.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "encode_multipart_formdata",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.filepost",
        "description": ".build.functions.students.urllib3.filepost",
        "peekOfCode": "def encode_multipart_formdata(\n    fields: _TYPE_FIELDS, boundary: str | None = None\n) -> tuple[bytes, str]:\n    \"\"\"\n    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n    :param fields:\n        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n        Values are processed by :func:`urllib3.fields.RequestField.from_tuples`.\n    :param boundary:\n        If not specified, then a random boundary will be generated using",
        "detail": ".build.functions.students.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "writer",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.filepost",
        "description": ".build.functions.students.urllib3.filepost",
        "peekOfCode": "writer = codecs.lookup(\"utf-8\")[3]\n_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"",
        "detail": ".build.functions.students.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELDS_SEQUENCE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.filepost",
        "description": ".build.functions.students.urllib3.filepost",
        "peekOfCode": "_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.",
        "detail": ".build.functions.students.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "_TYPE_FIELDS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.filepost",
        "description": ".build.functions.students.urllib3.filepost",
        "peekOfCode": "_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:",
        "detail": ".build.functions.students.urllib3.filepost",
        "documentation": {}
    },
    {
        "label": "PoolKey",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "class PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n    key_scheme: str\n    key_host: str\n    key_port: int | None\n    key_timeout: Timeout | float | int | None",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "PoolManager",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "class PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "ProxyManager",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "class ProxyManager(PoolManager):\n    \"\"\"\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n    :param proxy_url:\n        The URL of the proxy to be used.\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "proxy_from_url",
        "kind": 2,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "def proxy_from_url(url: str, **kw: typing.Any) -> ProxyManager:\n    return ProxyManager(proxy_url=url, **kw)",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "__all__ = [\"PoolManager\", \"ProxyManager\", \"proxy_from_url\"]\nlog = logging.getLogger(__name__)\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "log = logging.getLogger(__name__)\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "SSL_KEYWORDS",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "SSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",\n    \"ca_cert_dir\",",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_BLOCKSIZE",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "_DEFAULT_BLOCKSIZE = 16384\nclass PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n    key_scheme: str\n    key_host: str\n    key_port: int | None",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "key_fn_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "key_fn_by_scheme = {\n    \"http\": functools.partial(_default_key_normalizer, PoolKey),\n    \"https\": functools.partial(_default_key_normalizer, PoolKey),\n}\npool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "pool_classes_by_scheme",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.poolmanager",
        "description": ".build.functions.students.urllib3.poolmanager",
        "peekOfCode": "pool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n    :param headers:\n        Headers to include with all requests, unless other headers are given",
        "detail": ".build.functions.students.urllib3.poolmanager",
        "documentation": {}
    },
    {
        "label": "ContentDecoder",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class ContentDecoder:\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        raise NotImplementedError()\n    @property\n    def has_unconsumed_tail(self) -> bool:\n        raise NotImplementedError()\n    def flush(self) -> bytes:\n        raise NotImplementedError()\nclass DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "DeflateDecoder",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._first_try = True\n        self._first_try_data = b\"\"\n        self._unfed_data = b\"\"\n        self._obj = zlib.decompressobj()\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        data = self._unfed_data + data\n        self._unfed_data = b\"\"\n        if not data and not self._obj.unconsumed_tail:",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "GzipDecoderState",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class GzipDecoderState:\n    FIRST_MEMBER = 0\n    OTHER_MEMBERS = 1\n    SWALLOW_DATA = 2\nclass GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n        self._unconsumed_tail = b\"\"\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "GzipDecoder",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n        self._unconsumed_tail = b\"\"\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        ret = bytearray()\n        if self._state == GzipDecoderState.SWALLOW_DATA:\n            return bytes(ret)\n        if max_length == 0:",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "MultiDecoder",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class MultiDecoder(ContentDecoder):\n    \"\"\"\n    From RFC7231:\n        If one or more encodings have been applied to a representation, the\n        sender that applied the encodings MUST generate a Content-Encoding\n        header field that lists the content codings in the order in which\n        they were applied.\n    \"\"\"\n    # Maximum allowed number of chained HTTP encodings in the\n    # Content-Encoding header.",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "BytesQueueBuffer",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class BytesQueueBuffer:\n    \"\"\"Memory-efficient bytes buffer\n    To return decoded data in read() and still follow the BufferedIOBase API, we need a\n    buffer to always return the correct amount of bytes.\n    This buffer should be filled using calls to put()\n    Our maximum memory usage is determined by the sum of the size of:\n     * self.buffer, which contains the full data\n     * the largest chunk that we will copy in get()\n    \"\"\"\n    def __init__(self) -> None:",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "BaseHTTPResponse",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class BaseHTTPResponse(io.IOBase):\n    CONTENT_DECODERS = [\"gzip\", \"x-gzip\", \"deflate\"]\n    if brotli is not None:\n        CONTENT_DECODERS += [\"br\"]\n    if HAS_ZSTD:\n        CONTENT_DECODERS += [\"zstd\"]\n    REDIRECT_STATUSES = [301, 302, 303, 307, 308]\n    DECODER_ERROR_CLASSES: tuple[type[Exception], ...] = (IOError, zlib.error)\n    if brotli is not None:\n        DECODER_ERROR_CLASSES += (brotli.error,)",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "HTTPResponse",
        "kind": 6,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "class HTTPResponse(BaseHTTPResponse):\n    \"\"\"\n    HTTP Response container.\n    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\n    loaded and decoded on-demand when the ``data`` property is accessed.  This\n    class is also compatible with the Python standard library's :mod:`io`\n    module, and can hence be treated as a readable object in the context of that\n    framework.\n    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n    :param preload_content:",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": ".build.functions.students.urllib3.response",
        "description": ".build.functions.students.urllib3.response",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass ContentDecoder:\n    def decompress(self, data: bytes, max_length: int = -1) -> bytes:\n        raise NotImplementedError()\n    @property\n    def has_unconsumed_tail(self) -> bool:\n        raise NotImplementedError()\n    def flush(self) -> bytes:\n        raise NotImplementedError()\nclass DeflateDecoder(ContentDecoder):",
        "detail": ".build.functions.students.urllib3.response",
        "documentation": {}
    },
    {
        "label": "ICatalystCacheResp",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.cache._segment",
        "description": ".build.functions.students.zcatalyst_sdk.cache._segment",
        "peekOfCode": "class ICatalystCacheResp(ICatalystCache):\n    project_details: Optional[ICatalystProject]\nclass Segment(ParsableComponent):\n    def __init__(self, cache_instance, segment_details: Dict):\n        if segment_details:\n            validator.is_non_empty_dict(segment_details, 'segment_details', CatalystCacheError)\n        self._requester: AuthorizedHttpClient = cache_instance._requester\n        self._id = segment_details.get('id') if segment_details else None\n        self._segment_details = segment_details\n    def __repr__(self) -> str:",
        "detail": ".build.functions.students.zcatalyst_sdk.cache._segment",
        "documentation": {}
    },
    {
        "label": "Segment",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.cache._segment",
        "description": ".build.functions.students.zcatalyst_sdk.cache._segment",
        "peekOfCode": "class Segment(ParsableComponent):\n    def __init__(self, cache_instance, segment_details: Dict):\n        if segment_details:\n            validator.is_non_empty_dict(segment_details, 'segment_details', CatalystCacheError)\n        self._requester: AuthorizedHttpClient = cache_instance._requester\n        self._id = segment_details.get('id') if segment_details else None\n        self._segment_details = segment_details\n    def __repr__(self) -> str:\n        return str(self.to_dict())\n    def get_component_name(self):",
        "detail": ".build.functions.students.zcatalyst_sdk.cache._segment",
        "documentation": {}
    },
    {
        "label": "Connector",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.connection._connector",
        "description": ".build.functions.students.zcatalyst_sdk.connection._connector",
        "peekOfCode": "class Connector:\n    def __init__(self, connection_instance, connector_details: Dict[str, str]) -> None:\n        self._app = connection_instance._app\n        self._requester: HttpClient = connection_instance._requester\n        self.connector_name = connector_details.get(CONNECTOR_NAME)\n        self.auth_url = connector_details.get(AUTH_URL)\n        self.refresh_url = connector_details.get(REFRESH_URL)\n        self.refresh_token = connector_details.get(REFRESH_TOKEN)\n        self.client_id = connector_details.get(CLIENT_ID)\n        self.client_secret = connector_details.get(CLIENT_SECRET)",
        "detail": ".build.functions.students.zcatalyst_sdk.connection._connector",
        "documentation": {}
    },
    {
        "label": "BulkJob",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkJob(Component, ABC):\n    def __init__(self, table_instance, operation: str):\n        self._requester: AuthorizedHttpClient = table_instance._requester\n        self._identifier = table_instance._identifier\n        self._operation = operation\n    def get_component_name(self):\n        return Components.DATA_STORE\n    def get_status(self, job_id: Union[str, int]) -> ICatalystBulkJob:\n        validator.is_non_empty_string_or_number(job_id, 'job_id', CatalystDatastoreError)\n        resp = self._requester.request(",
        "detail": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "BulkRead",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkRead(BulkJob):\n    def __init__(self, table_instance):\n        super().__init__(table_instance, 'read')\n    def create_job(\n        self,\n        query: ICatalystBulkReadQuery = None,\n        callback: ICatalystBulkCallback = None\n    ) -> ICatalystBulkJob:\n        resp = self._requester.request(\n            method=RequestMethod.POST,",
        "detail": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "BulkWrite",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "description": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "peekOfCode": "class BulkWrite(BulkJob):\n    def __init__(self, table_instance):\n        super().__init__(table_instance, 'write')\n    def create_job(\n        self,\n        file_details: Union[CatalystBucketObject, str],\n        options: ICatalystBulkWriteInput = None,\n        callback: ICatalystBulkCallback = None\n    ) -> ICatalystBulkJob:\n        if options:",
        "detail": ".build.functions.students.zcatalyst_sdk.datastore._bulk_job",
        "documentation": {}
    },
    {
        "label": "Table",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "peekOfCode": "class Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)\n    def get_component_name(self):\n        return Components.DATA_STORE",
        "detail": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "ICatalystRowInput",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "peekOfCode": "ICatalystRowInput = TypedDict('ICatalystRowInput', {'ROWID': str})\nBulkOperation = Literal['read', 'write']\nclass Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)",
        "detail": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "BulkOperation",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "description": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "peekOfCode": "BulkOperation = Literal['read', 'write']\nclass Table(ParsableComponent):\n    def __init__(self, datastore_instance, table_details: Dict):\n        validator.is_non_empty_dict(table_details, 'table_details', CatalystDatastoreError)\n        self._requester: AuthorizedHttpClient = datastore_instance._requester\n        self._identifier = table_details.get('table_id') or table_details.get('table_name')\n        self._table_details = table_details\n    def __repr__(self) -> str:\n        return str(self._table_details)\n    def get_component_name(self):",
        "detail": ".build.functions.students.zcatalyst_sdk.datastore._table",
        "documentation": {}
    },
    {
        "label": "ICatalystFolderDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class ICatalystFolderDetails(ICatalystFolder):\n    created_time: Optional[str]\n    created_by: Optional[ICatalystSysUser]\n    project_details: Optional[ICatalystProject]\nclass ICatalystFileDetails(ICatalystFile, ICatalystGResponse):\n    pass\nclass Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester",
        "detail": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "ICatalystFileDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class ICatalystFileDetails(ICatalystFile, ICatalystGResponse):\n    pass\nclass Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester\n        self._folder_details = folder_details\n        self._id = folder_details.get('id')\n    def __repr__(self) -> str:\n        return str(self._folder_details)",
        "detail": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "Folder",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "description": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "peekOfCode": "class Folder(ParsableComponent):\n    def __init__(self, filestore_instance, folder_details: Dict):\n        validator.is_non_empty_dict(folder_details, 'folder_details', CatalystFilestoreError)\n        self._requester: AuthorizedHttpClient = filestore_instance._requester\n        self._folder_details = folder_details\n        self._id = folder_details.get('id')\n    def __repr__(self) -> str:\n        return str(self._folder_details)\n    def get_component_name(self):\n        return Components.FILE_STORE",
        "detail": ".build.functions.students.zcatalyst_sdk.filestore._folder",
        "documentation": {}
    },
    {
        "label": "Cron",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._cron",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._cron",
        "peekOfCode": "class Cron:\n    def __init__(self, job_scheduling_instance) -> None:\n        self._requester: AuthorizedHttpClient = job_scheduling_instance._requester\n    def get_component_name(self):\n        return Components.JOB_SCHEDULING\n    def get_all(self) -> List[ICatalystCronDetails]:\n        \"\"\"\n        Get a list of all static crons\n        Returns:\n            List[ICatalystCronDetails]: List of static cron details",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._cron",
        "documentation": {}
    },
    {
        "label": "CatalystJobSchedulingError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._exception",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._exception",
        "peekOfCode": "class CatalystJobSchedulingError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._exception",
        "documentation": {}
    },
    {
        "label": "Job",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._job",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._job",
        "peekOfCode": "class Job:\n    def __init__(self, job_scheduling_instance):\n        self._requester: AuthorizedHttpClient = job_scheduling_instance._requester\n    def get_job(self, job_id: str) -> ICatalystJobDetails:\n        \"\"\"\n        Get a job's details\n        Args:\n            job_id: Id of the job to be fetched\n        Returns:\n            ICatalystJobDetails: Details of job fetched with the job_id",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._job",
        "documentation": {}
    },
    {
        "label": "CapacityAttribute",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CapacityAttribute(Enum):\n    MEMORY = \"memory\"\n    NUMBER = \"number\"\nclass CronExecutionType(Enum):\n    PRE_DEFINED = \"pre-defined\"\n    DYNAMIC = \"dynamic\"\nclass CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "CronExecutionType",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CronExecutionType(Enum):\n    PRE_DEFINED = \"pre-defined\"\n    DYNAMIC = \"dynamic\"\nclass CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"\n    CRON_EXPRESSION = \"CronExpression\"\nclass TargetType(Enum):\n    FUNCTION = \"Function\"",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "CronType",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class CronType(Enum):\n    CALENDER = \"Calender\"\n    PERIODIC = \"Periodic\"\n    ONETIME = \"OneTime\"\n    CRON_EXPRESSION = \"CronExpression\"\nclass TargetType(Enum):\n    FUNCTION = \"Function\"\n    CIRCUIT = \"Circuit\"\n    APPSAIL = \"AppSail\"\n    WEBHOOK = \"Webhook\"",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TargetType",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class TargetType(Enum):\n    FUNCTION = \"Function\"\n    CIRCUIT = \"Circuit\"\n    APPSAIL = \"AppSail\"\n    WEBHOOK = \"Webhook\"\nclass JobStatus(Enum):\n    SUBMITTED = \"Submitted\"\n    PENDING = \"Pending\"\n    RUNNING = \"Running\"\n    SUCCESSFUL = \"Successful\"",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "JobStatus",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class JobStatus(Enum):\n    SUBMITTED = \"Submitted\"\n    PENDING = \"Pending\"\n    RUNNING = \"Running\"\n    SUCCESSFUL = \"Successful\"\n    FAILURE = \"Failure\"\nclass RepetitionType(Enum):\n    EVERY = \"every\"\n    DAILY = \"daily\"\n    MONTHLY = \"monthly\"",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "RepetitionType",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class RepetitionType(Enum):\n    EVERY = \"every\"\n    DAILY = \"daily\"\n    MONTHLY = \"monthly\"\n    YEARLY = \"yearly\"\nclass ICatalystCapacityAttributes(TypedDict):\n    memory: int\n    number: int\nclass ICatalystJobTargetDetails(TypedDict):\n    id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCapacityAttributes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCapacityAttributes(TypedDict):\n    memory: int\n    number: int\nclass ICatalystJobTargetDetails(TypedDict):\n    id: str\n    target_name: str\n    details: Dict[str, Any]\nclass ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobTargetDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobTargetDetails(TypedDict):\n    id: str\n    target_name: str\n    details: Dict[str, Any]\nclass ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType\n    name: str\n    capacity: ICatalystCapacityAttributes\nclass ICatalystJobMetaConfig(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobpoolDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobpoolDetails(TypedDict):\n    id: str\n    type: TargetType\n    name: str\n    capacity: ICatalystCapacityAttributes\nclass ICatalystJobMetaConfig(TypedDict):\n    number_of_retires: int\n    retry_interval: int\nclass ICatalystJobBasic(TypedDict):\n    job_name: str",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobMetaConfig",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobMetaConfig(TypedDict):\n    number_of_retires: int\n    retry_interval: int\nclass ICatalystJobBasic(TypedDict):\n    job_name: str\n    job_config: Optional[ICatalystJobMetaConfig]\n    jobpool_id: str\n    jobpool_name: str\nclass ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobBasic",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobBasic(TypedDict):\n    job_name: str\n    job_config: Optional[ICatalystJobMetaConfig]\n    jobpool_id: str\n    jobpool_name: str\nclass ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]\n    target_id: str\n    params: Dict[str, str]\nclass ICatalystWebhookJob(ICatalystJobBasic):",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystFunctionJob",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystFunctionJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.FUNCTION]\n    target_id: str\n    params: Dict[str, str]\nclass ICatalystWebhookJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.WEBHOOK]\n    target_id: str\n    url: str\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystWebhookJob",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystWebhookJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.WEBHOOK]\n    target_id: str\n    url: str\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]\n    request_method: str\n    request_body: Optional[str]\nclass ICatalystAppSailJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.APPSAIL]",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystAppSailJob",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystAppSailJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.APPSAIL]\n    target_id: str\n    url: Optional[str]\n    params: Optional[Dict[str, str]]\n    headers: Optional[Dict[str, str]]\n    request_method: str\n    request_body: Optional[str]\nclass ICatalystCircuitJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.CIRCUIT]",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCircuitJob",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCircuitJob(ICatalystJobBasic):\n    target_type: Literal[TargetType.CIRCUIT]\n    target_id: str\n    test_cases: Dict[str, Any]\n# pylint: disable=invalid-name\nTCatalystJobs = Union[\n    ICatalystFunctionJob, ICatalystWebhookJob, ICatalystAppSailJob, ICatalystCircuitJob\n]\nclass ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobMetaDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str\n    target_details: ICatalystJobTargetDetails\n    source_type: str\n    source_id: str\n    source_details: str\n    jobpool_details: ICatalystJobpoolDetails\n    target_type: TargetType\n    target_id: str\n    url: Optional[str]",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystJobDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystJobDetails(ICatalystGResponse):\n    job_id: str\n    status: bool\n    job_status: JobStatus\n    capacity: ICatalystCapacityAttributes\n    job_meta_details: ICatalystJobMetaDetails\n    response_code: Optional[str]\n    start_time: str\n    end_time: str\n    execution_time: str",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronBasic",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronBasic(TypedDict):\n    cron_execution_type: CronExecutionType\n    cron_name: str\n    cron_status: bool\n    job_meta: TCatalystJobs\none_time_cron_detail = TypedDict(\n    \"one_time_cron_detail\", {\"time_of_execution\": str, \"timezone\": Optional[str]}\n)\nclass ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystOneTimeCron",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]\n    cron_detail: one_time_cron_detail\nevery_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystEveryCron",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystEveryCron(ICatalystCronBasic):\n    cron_type: Literal[\"Periodic\"]\n    cron_detail: every_cron_detail\n    end_time: Optional[str]\ndaily_cron_detail = TypedDict(\n    \"daily_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystDailyCron",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystDailyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: daily_cron_detail\n    end_time: Optional[str]\nmonthly_cron_detail = TypedDict(\n    \"monthly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"monthly\"],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystMonthlyCron",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystMonthlyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: monthly_cron_detail\n    end_time: Optional[str]\nyearly_cron_detail = TypedDict(\n    \"yearly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"yearly\"],\n        \"months\": List[int],\n        \"days\": Optional[List[int]],",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystYearlyCron",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystYearlyCron(ICatalystCronBasic):\n    cron_type: Literal[\"Calendar\"]\n    cron_detail: yearly_cron_detail\n    end_time: Optional[str]\nexpression_cron_detail = TypedDict(\n    \"expression_cron_detail\", {\"timezone\": Optional[str]}\n)\nclass ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronExpression",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str\n    cron_detail: expression_cron_detail\n    end_time: Optional[str]\n# pylint: disable=invalid-name\nTCatalystCron = Union[\n    ICatalystOneTimeCron,\n    ICatalystEveryCron,\n    ICatalystDailyCron,",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "ICatalystCronDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "class ICatalystCronDetails(ICatalystGResponse):\n    id: str\n    cron_name: str\n    description: Optional[str]\n    cron_type: CronType\n    cron_function_id: Optional[str]\n    cron_execution_type: CronExecutionType\n    cron_status: bool\n    start_time: str\n    end_time: str",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TCatalystJobs",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "TCatalystJobs = Union[\n    ICatalystFunctionJob, ICatalystWebhookJob, ICatalystAppSailJob, ICatalystCircuitJob\n]\nclass ICatalystJobMetaDetails(ICatalystJobBasic):  # for response\n    id: str\n    target_details: ICatalystJobTargetDetails\n    source_type: str\n    source_id: str\n    source_details: str\n    jobpool_details: ICatalystJobpoolDetails",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "one_time_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "one_time_cron_detail = TypedDict(\n    \"one_time_cron_detail\", {\"time_of_execution\": str, \"timezone\": Optional[str]}\n)\nclass ICatalystOneTimeCron(ICatalystCronBasic):\n    cron_type: Literal[\"OneTime\"]\n    cron_detail: one_time_cron_detail\nevery_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "every_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "every_cron_detail = TypedDict(\n    \"every_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],\n        \"repetition_type\": Literal[\"every\"],\n    },\n)",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "daily_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "daily_cron_detail = TypedDict(\n    \"daily_cron_detail\",\n    {\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,\n        \"timezone\": Optional[str],\n        \"repetition_type\": Literal[\"daily\"],\n    },\n)",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "monthly_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "monthly_cron_detail = TypedDict(\n    \"monthly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"monthly\"],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],\n        \"week_day\": Optional[List[int]],\n        \"hour\": int,\n        \"minute\": int,\n        \"second\": int,",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "yearly_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "yearly_cron_detail = TypedDict(\n    \"yearly_cron_detail\",\n    {\n        \"repetition_type\": Literal[\"yearly\"],\n        \"months\": List[int],\n        \"days\": Optional[List[int]],\n        \"weeks_of_month\": Optional[List[int]],\n        \"week_day\": Optional[List[int]],\n        \"hour\": int,\n        \"minute\": int,",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "expression_cron_detail",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "expression_cron_detail = TypedDict(\n    \"expression_cron_detail\", {\"timezone\": Optional[str]}\n)\nclass ICatalystCronExpression(ICatalystCronBasic):\n    cron_type: Literal[\"CronExpression\"]\n    cron_expression: str\n    cron_detail: expression_cron_detail\n    end_time: Optional[str]\n# pylint: disable=invalid-name\nTCatalystCron = Union[",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TCatalystCron",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "description": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "peekOfCode": "TCatalystCron = Union[\n    ICatalystOneTimeCron,\n    ICatalystEveryCron,\n    ICatalystDailyCron,\n    ICatalystMonthlyCron,\n    ICatalystYearlyCron,\n    ICatalystCronExpression,\n]\nclass ICatalystCronDetails(ICatalystGResponse):\n    id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.job_scheduling._types",
        "documentation": {}
    },
    {
        "label": "TableItem",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql._table_items",
        "description": ".build.functions.students.zcatalyst_sdk.nosql._table_items",
        "peekOfCode": "class TableItem(Component):\n    \"\"\"This class used to perform NoSQL table operations.\n    Args:\n        Component (ABC): Class used to retrieve the component's name.\n    \"\"\"\n    def __init__(self, nosql_instance, table) -> None:\n        self._requester: AuthorizedHttpClient = nosql_instance._requester\n        if not is_non_empty_string_or_number(table, 'table_identifier'):\n            table = table['id']\n        self.base_path = f'/nosqltable/{table}'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql._table_items",
        "documentation": {}
    },
    {
        "label": "AttrBase",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttrBase:\n    \"\"\"This class used to construct the attribute condition dict.\"\"\"\n    operator = ''\n    def __init__(self, name, values):\n        self.name = name\n        self.value = values\n    def get_condition(self):\n        return {\n            'attribute': self.name,\n            'operator': self.operator,",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "FuncBase",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class FuncBase:\n    \"\"\"This class used to construct the function condition dict.\"\"\"\n    operator = ''\n    def __init__(self, name, value = None):\n        self.args = []\n        self.args.append({\n            'attribute_path': name\n        })\n        self.values = value\n    def get_condition(self):",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GroupBase",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GroupBase:\n    \"\"\"This class used to construct the group condition dict.\"\"\"\n    operator = ''\n    group= []\n    def __init__(self, value):\n        self.value = value\n    def get_grouped_values(self):\n        self.group.extend(self.value)\n    def get_condition(self):\n        self.get_grouped_values()",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Attr",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Attr:\n    \"\"\"Represents an NoSql attribute condition.\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def __and__(self, value):\n        raise CatalystNoSqlError('AND', self)\n    def __or__(self, value):\n        raise CatalystNoSqlError('OR', self)\n    def __invert__(self):\n        raise CatalystNoSqlError('NOT', self)",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Func",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Func:\n    \"\"\"Represents an NoSql function condition.\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def exists(self):\n        \"\"\"Creates a condition where the attribute exists.\"\"\"\n        return AttributeExists(self.name).get_condition()\n    def not_exists(self):\n        \"\"\"Creates a condition where the attribute does not exist.\"\"\"\n        return AttributeNotExists(self.name).get_condition()",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Group",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Group:\n    \"\"\"Represents an NoSql Group condition.\"\"\"\n    def __init__(self, value):\n        self.value = value\n    def with_and(self):\n        \"\"\"Creates a group condition where the condition and to the other condition\n        :param value: The condition that the other condition is group with AND operator.\n        \"\"\"\n        return And(self.value).get_condition()\n    def with_or(self):",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Key",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Key(Attr):\n    pass\nclass Equals(AttrBase):\n    operator = 'equals'\nclass NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Equals",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Equals(AttrBase):\n    operator = 'equals'\nclass NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "NotEquals",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class NotEquals(AttrBase):\n    operator = 'not_equals'\nclass LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "LessThan",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class LessThan(AttrBase):\n    operator = 'less_than'\nclass LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "LessThanEquals",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class LessThanEquals(AttrBase):\n    operator = 'less_equal'\nclass GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GreaterThan",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GreaterThan(AttrBase):\n    operator = 'greater_than'\nclass GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "GreaterThanEquals",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class GreaterThanEquals(AttrBase):\n    operator = 'greater_equal'\nclass Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Between",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Between(AttrBase):\n    operator = 'between'\nclass BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "BeginsWith",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class BeginsWith(AttrBase):\n    operator = 'begins_with'\nclass Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Contains",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Contains(AttrBase):\n    operator = 'contains'\nclass In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "In",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class In(AttrBase):\n    operator = 'in'\nclass AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeExists",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeExists(FuncBase):\n    operator = 'attribute_exists'\nclass AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeNotExists",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeNotExists(FuncBase):\n    operator = 'attribute_not_exists'\nclass AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "AttributeType",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class AttributeType(FuncBase):\n    operator = 'attribute_type'\nclass And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "And",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class And(GroupBase):\n    operator = 'AND'\nclass Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Or",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "peekOfCode": "class Or(GroupBase):\n    operator = 'OR'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.conditions",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class Item:\n    \"\"\"This class used to perform coversion between NoSQL and Python types.\n    Returns:\n        Item: Instance of the class.\n    \"\"\"\n    @staticmethod\n    def to_nosql(items):\n        \"\"\"Convert the given type to NoSQl typs.\n        Args:\n            items (dict): Items to converted in to NoSQL type.",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "NoSqlItemResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class NoSqlItemResponse():\n    \"\"\" NoSQL Table Response.\"\"\"\n    def __init__(self, res_data: NoSqlItem):\n        self.status = res_data.get('status')\n        self.item = res_data.get('item') and Item.to_python({ 'M': res_data.get('item')})\n        self.old_item = res_data.get('old_item') and \\\n            Item.to_python({ 'M' :res_data.get('old_item')})\n    def to_dict(self):\n        return {k: v for k, v in self.__dict__.items() if v is not None and v != self.status}\n    def __repr__(self):",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "NoSqlResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "peekOfCode": "class NoSqlResponse():\n    \"\"\"NoSQL response for all operations performed in the NoSQL table.\"\"\"\n    def __init__(self, res_data: NoSqlItemRes) -> None:\n        self._res_data = res_data\n        self.size = res_data.get('size')\n        self.operation = res_data.get('operation')\n        self.start_key = res_data.get('start_key')\n        self.get = res_data.get('get') and \\\n            [NoSqlItemResponse(i).to_dict() for i in res_data.get('get')]\n        self.update = res_data.get('update') and \\",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.transfom",
        "documentation": {}
    },
    {
        "label": "Binary",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify\n    binary data for item in NoSQL. It is essentially a wrapper around\n    binary. Unicode and Python 3 string types are not allowed.\n    \"\"\"\n    def __init__(self, value):\n        if not isinstance(value, BINARY_TYPES):\n            types = ', '.join([str(t) for t in BINARY_TYPES])\n            raise TypeError(f'Value must be of the following types: {types}')",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "TypeSerializer",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class TypeSerializer:\n    \"\"\"This class serializes Python data types to NoSQL types.\"\"\"\n    def serialize(self, value):\n        \"\"\"The method to serialize the Python data types.\n        :param value: A python value to be serialized to NoSQL. Here are\n            the various conversions:\n            Python                                  NoSQL\n            ------                                  --------\n            None                                    {'NULL': True}\n            True/False                              {'BOOL': True/False}",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "TypeDeserializer",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "class TypeDeserializer:\n    \"\"\"This class deserializes NoSQL types to Python types.\"\"\"\n    def deserialize(self, value):\n        \"\"\"The method to deserialize the NoSQL data types.\n        :param value: A NoSQL value to be deserialized to a pythonic value.\n            Here are the various conversions:\n            NoSQL                                Python\n            --------                                ------\n            {'NULL': True}                          None\n            {'BOOL': True/False}                    True/False",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "STRING",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "STRING = 'S'\nNUMBER = 'N'\nBINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NUMBER",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NUMBER = 'N'\nBINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY = 'B'\nSTRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "STRING_SET",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "STRING_SET = 'SS'\nNUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NUMBER_SET",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NUMBER_SET = 'SN'\nBINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY_SET",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY_SET = 'SB'\nNULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NULL",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NULL = 'NULL'\nBOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BOOLEAN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BOOLEAN = 'BOOL'\nMAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "MAP",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "MAP = 'M'\nLIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "LIST",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "LIST = 'L'\nNOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "NOSQL_CONTEXT",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "NOSQL_CONTEXT = Context(\n    Emin=-128,\n    Emax=126,\n    prec=38,\n    traps=[Clamped, Overflow, Inexact, Rounded, Underflow],\n)\nBINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "BINARY_TYPES",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "description": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "peekOfCode": "BINARY_TYPES = (bytearray, bytes)\nclass Binary:\n    \"\"\"A class for representing Binary in nosql\n    Especially for Python 2, use this class to explicitly specify\n    binary data for item in NoSQL. It is essentially a wrapper around\n    binary. Unicode and Python 3 string types are not allowed.\n    \"\"\"\n    def __init__(self, value):\n        if not isinstance(value, BINARY_TYPES):\n            types = ', '.join([str(t) for t in BINARY_TYPES])",
        "detail": ".build.functions.students.zcatalyst_sdk.nosql.types",
        "documentation": {}
    },
    {
        "label": "MobilePlatform",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.push_notification._mobile_notification",
        "description": ".build.functions.students.zcatalyst_sdk.push_notification._mobile_notification",
        "peekOfCode": "class MobilePlatform(Enum):\n    IOS = \"ios\"\n    ANDROID = \"android\"\nclass MobileNotification:\n    \"\"\"\n    Class that contains the APIs for mobile push notification\n    \"\"\"\n    def __init__(self, requester: AuthorizedHttpClient, app_id):\n        self._app_id = app_id\n        self._requester = requester",
        "detail": ".build.functions.students.zcatalyst_sdk.push_notification._mobile_notification",
        "documentation": {}
    },
    {
        "label": "MobileNotification",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.push_notification._mobile_notification",
        "description": ".build.functions.students.zcatalyst_sdk.push_notification._mobile_notification",
        "peekOfCode": "class MobileNotification:\n    \"\"\"\n    Class that contains the APIs for mobile push notification\n    \"\"\"\n    def __init__(self, requester: AuthorizedHttpClient, app_id):\n        self._app_id = app_id\n        self._requester = requester\n    def send_ios_notification(\n        self, notify_obj: ICatalystPushDetails, recipient: str\n    ) -> ICatalystMobileNotification:",
        "detail": ".build.functions.students.zcatalyst_sdk.push_notification._mobile_notification",
        "documentation": {}
    },
    {
        "label": "WebNotification",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.push_notification._web_notificaton",
        "description": ".build.functions.students.zcatalyst_sdk.push_notification._web_notificaton",
        "peekOfCode": "class WebNotification:\n    def __init__(self, notification_instance):\n        self._app = notification_instance._app\n        self._requester: AuthorizedHttpClient = notification_instance._requester\n    def send_notification(\n        self,\n        message: str,\n        recipients: List[str]\n    ) -> bool:\n        validator.is_non_empty_string(message, 'message', CatalystPushNotificationError)",
        "detail": ".build.functions.students.zcatalyst_sdk.push_notification._web_notificaton",
        "documentation": {}
    },
    {
        "label": "SignatureCache",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.stratus._auth_util",
        "description": ".build.functions.students.zcatalyst_sdk.stratus._auth_util",
        "peekOfCode": "class SignatureCache:\n    \"\"\"\n    Handles signature caching and retrieval for bucket authentication.\n    \"\"\"\n    bucket_signatures: Dict[str, Dict] = {}\n    @classmethod\n    def get_signature(cls, bucket_name: str) -> Optional[Dict]:\n        \"\"\"\n        Retrieve the cached signature for the specified bucket if valid.\n        \"\"\"",
        "detail": ".build.functions.students.zcatalyst_sdk.stratus._auth_util",
        "documentation": {}
    },
    {
        "label": "AuthUtil",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.stratus._auth_util",
        "description": ".build.functions.students.zcatalyst_sdk.stratus._auth_util",
        "peekOfCode": "class AuthUtil:\n    \"\"\"\n    Handles user authentication and signature retrieval for buckets.\n    \"\"\"\n    def __init__(self, bucket_name: str, requester: AuthorizedHttpClient) -> None:\n        self.bucket_name = bucket_name\n        self._requester = requester\n        self.user_type = requester._app.credential.current_user_type()\n        self.user_scope = requester._app.credential.current_user()\n    def get_user_type(self) -> str:",
        "detail": ".build.functions.students.zcatalyst_sdk.stratus._auth_util",
        "documentation": {}
    },
    {
        "label": "Bucket",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.stratus.bucket",
        "description": ".build.functions.students.zcatalyst_sdk.stratus.bucket",
        "peekOfCode": "class Bucket(ParsableComponent):\n    def __init__(self, stratus_instance, bucket_details: Dict):\n        validator.is_non_empty_dict(bucket_details, 'bucket_details', CatalystStratusError)\n        self._requester: AuthorizedHttpClient = stratus_instance._requester\n        self._bucket_name = bucket_details.get('bucket_name')\n        self.bucket_details = bucket_details\n        self._auth_util = AuthUtil(self._bucket_name, self._requester)\n        if self._requester._app.config.get(ENVIRONMENT) == 'Development':\n            self.bucket_domain = f'https://{self._bucket_name}-development{STRATUS_SUFFIX}'\n        else:",
        "detail": ".build.functions.students.zcatalyst_sdk.stratus.bucket",
        "documentation": {}
    },
    {
        "label": "StratusObject",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.stratus.object",
        "description": ".build.functions.students.zcatalyst_sdk.stratus.object",
        "peekOfCode": "class StratusObject(ParsableComponent):\n    def __init__(self, bucket_instance, object_details: Dict):\n        validator.is_non_empty_dict(object_details, 'object_details', CatalystStratusError)\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self._key = object_details.get('key')\n        self.object_details = object_details\n        self.req_params = {\n            'bucket_name': bucket_instance.get_name(),\n            'object_key': self._key\n        }",
        "detail": ".build.functions.students.zcatalyst_sdk.stratus.object",
        "documentation": {}
    },
    {
        "label": "MultipartUpload",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "class MultipartUpload():\n    def __init__(self, bucket_instance, key, upload_id):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.key = key\n        self.upload_id = upload_id\n    def upload_part(self,\n            body: Union[BufferedReader, bytes],\n            part_number: Union[str, int],\n            overwrite: Union[str, bool] = False",
        "detail": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "TransferManager",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "class TransferManager(Component):\n    def __init__(self, bucket_instance):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.bucket_domain = bucket_instance.bucket_domain\n    def get_component_name(self):\n        return Components.STRATUS\n    def create_multipart_instance(self,\n        key: str,\n        upload_id: str = None,",
        "detail": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "description": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "peekOfCode": "logger = get_logger()\nclass MultipartUpload():\n    def __init__(self, bucket_instance, key, upload_id):\n        self._requester: AuthorizedHttpClient = bucket_instance._requester\n        self.bucket: Bucket = bucket_instance\n        self.key = key\n        self.upload_id = upload_id\n    def upload_part(self,\n            body: Union[BufferedReader, bytes],\n            part_number: Union[str, int],",
        "detail": ".build.functions.students.zcatalyst_sdk.stratus.transfer_manager",
        "documentation": {}
    },
    {
        "label": "NoSqlCrudOperation",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\nclass CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str\n    first_name: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystSysUser",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str\n    first_name: str\n    last_name: str\n    zuid: Optional[str]\n    is_confirmed: Optional[bool]\nclass CatalystProjectInfo(TypedDict):\n    id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystProjectInfo",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystProjectInfo(TypedDict):\n    id: str\n    project_name: str\n    project_type: str\nclass CatalystNoSqlKeyInfo(TypedDict):\n    column_name: str\n    data_type: str\nclass NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "CatalystNoSqlKeyInfo",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class CatalystNoSqlKeyInfo(TypedDict):\n    column_name: str\n    data_type: str\nclass NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    modified_by: CatalystSysUser\n    modified_time: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlTableResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlTableResponse(TypedDict):\n    id: str\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str\n    partition_key: CatalystNoSqlKeyInfo\n    project_id: CatalystProjectInfo",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlIndexRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlIndexRes(TypedDict):\n    created_by: CatalystSysUser\n    created_time: str\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str\n    partition_key:CatalystNoSqlKeyInfo\n    project_id: CatalystProjectInfo\n    projected_attributes: ProjectedAttribute",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlTableResourceRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlTableResourceRes(TypedDict):\n    additional_sort_keys: List[NoSqlIndexRes]\n    api_access: bool\n    created_by: CatalystSysUser\n    created_time: str\n    global_index: List[NoSqlIndexRes]\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "UpdateCondion",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class UpdateCondion(TypedDict):\n    function_name: Literal['if_not_exists', 'add', 'subtract', 'append_list']\n    args: AttributePath\nclass NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion\n    attribute_path: List[str]\nclass NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItemUpdateAttributeOperation",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion\n    attribute_path: List[str]\nclass NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']\n    args: AttributePath\nclass NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlFunctionCondition",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlFunctionCondition(TypedDict):\n    function_name: Literal['attribute_exits', 'attribute_type']\n    args: AttributePath\nclass NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]\nclass NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlConditionFuncOperation",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlConditionFuncOperation():\n    function: Optional[NoSqlFunctionCondition]\nclass NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlAttributeCondition",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlAttributeCondition(TypedDict):\n    attribute: Optional[NoSqlAttributeType]\n    operator: Optional[NoSqlOperator]\n    value: Dict[str, str]\nclass NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool\nNoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlGroupCondition",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlGroupCondition(TypedDict):\n    group_operator: Optional[str]\n    group: Optional['NoSqlCondition']\n    negate: bool\nNoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItem",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]\n    create: List[NoSqlItem]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlItemRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]\n    create: List[NoSqlItem]\n    delete: List[NoSqlItem]\n    get: List[NoSqlItem]\nNoSqlInsertItemReq = TypedDict('NoSqlInsertItemReq', {\n    'item': Dict[str, str],",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlFetchItemReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlFetchItemReq(TypedDict):\n    keys: List[Dict[str, str]]\n    required_attributes: List[str]\nclass NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\nclass NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlDeleteItemReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\nclass NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]\nclass NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlUpdateItemReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlUpdateItemReq(TypedDict):\n    keys: Dict[str, str]\n    condition: Optional[NoSqlCondition]\n    update_attributes: List[NoSqlItemUpdateAttributeOperation]\nclass NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition\n    other_condition: Optional[NoSqlCondition]\n    limit: int\n    forward_scan: bool",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlQueryItemReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "class NoSqlQueryItemReq(TypedDict):\n    consistent_read: bool\n    key_condition: NoSqlCondition\n    other_condition: Optional[NoSqlCondition]\n    limit: int\n    forward_scan: bool\n    start_key: Dict[str, str]\n    additional_sort_keys: str\n    required_attributes: List[str]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlAttributeType",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlAttributeType = Literal['keys_only', 'all', 'include']\nNoSqlGroupOperator = Literal['AND', 'OR']\nNoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlGroupOperator",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlGroupOperator = Literal['AND', 'OR']\nNoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlUpdateOperation",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlUpdateOperation = Literal['PUT', 'DELETE']\nNoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlOperator",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlOperator = Literal[\n     'contains', 'begins_with', 'not_contains', 'ends_with', 'in', 'not_in',\n       'between', 'not_between', 'equals', 'not_equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ItemType",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ItemType = Literal[\n    'S', 'N', 'B', 'L', 'M', 'SS', 'SB', 'SN', 'BOOL'\n]\nNoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlSecondaryKeyCondition",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlSecondaryKeyCondition = Literal[\n      'begins_with', 'between', 'equals', 'greater_than',\n       'less_than', 'greater_equal','less_equal'\n]\nReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ReturnType",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ReturnType = Literal['NEW', 'OLD', 'NULL']\nclass NoSqlCrudOperation(Enum):\n    CREATE = \"create\"\n    READ = \"read\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\nclass CatalystSysUser(TypedDict):\n    user_id: str\n    user_type: str\n    email_id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "ProjectedAttribute",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "ProjectedAttribute = TypedDict('ProjectedAttribute', {\n    'type': str,\n})\nclass NoSqlIndexRes(TypedDict):\n    created_by: CatalystSysUser\n    created_time: str\n    id: str\n    modified_by: CatalystSysUser\n    modified_time: str\n    name: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "AttributePath",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "AttributePath = TypedDict('AttributePath', {\n        'attribute_path': List[str]\n})\nclass UpdateCondion(TypedDict):\n    function_name: Literal['if_not_exists', 'add', 'subtract', 'append_list']\n    args: AttributePath\nclass NoSqlItemUpdateAttributeOperation(TypedDict, total= False):\n    operation_type: NoSqlUpdateOperation\n    update_value: Dict[str, str]\n    update_function: UpdateCondion",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlCondition",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlCondition = Union[NoSqlAttributeCondition, NoSqlGroupCondition, NoSqlConditionFuncOperation]\nclass NoSqlItem(TypedDict, total = False):\n    status: str\n    old_item: str\n    item: str\nclass NoSqlItemRes(TypedDict, total = False):\n    size: str\n    start_key: str\n    operation: Literal['create', 'read', 'update', 'delete']\n    update: List[NoSqlItem]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "NoSqlInsertItemReq",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "description": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "peekOfCode": "NoSqlInsertItemReq = TypedDict('NoSqlInsertItemReq', {\n    'item': Dict[str, str],\n    'condition': Optional[NoSqlCondition],\n    'return': ReturnType\n}, total = False)\nclass NoSqlFetchItemReq(TypedDict):\n    keys: List[Dict[str, str]]\n    required_attributes: List[str]\nclass NoSqlDeleteItemReq(TypedDict):\n    keys: Dict[str, str]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.nosql",
        "documentation": {}
    },
    {
        "label": "PipelineDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.pipeline",
        "description": ".build.functions.students.zcatalyst_sdk.types.pipeline",
        "peekOfCode": "class PipelineDetails(TypedDict):\n    pipeline_id: str\n    name: str\n    description: str\n    project_details: ICatalystProject\n    created_time: str\n    created_by: ICatalystSysUser\n    modified_time: str\n    modified_by: ICatalystSysUser\n    git_account_id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.pipeline",
        "documentation": {}
    },
    {
        "label": "PipelineRun",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.pipeline",
        "description": ".build.functions.students.zcatalyst_sdk.types.pipeline",
        "peekOfCode": "class PipelineRun(TypedDict):\n    history_id: str\n    pipeline_id: str\n    event_time: str\n    event_details: Dict[str, str]\n    history_status: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.pipeline",
        "documentation": {}
    },
    {
        "label": "PdfOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class PdfOptions(TypedDict, total=False):\n    scale: Union[int,str]\n    display_header_footer: bool\n    header_template: str\n    password: str\n    footer_template: str\n    print_background: bool\n    landscape: bool\n    page_ranges: Union[int,str]\n    format: PdfFormats",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfPageOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name\n    viewport: PdfViewPort\n    javascript_enabled: bool\nclass ScreenShotOptions(TypedDict, total=False):\n    type: Literal['jpeg', 'png']\n    quality: Union[int, str]\n    full_page: bool\n    omit_background: bool",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "ScreenShotOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class ScreenShotOptions(TypedDict, total=False):\n    type: Literal['jpeg', 'png']\n    quality: Union[int, str]\n    full_page: bool\n    omit_background: bool\n    capture_beyond_viewport: bool\nclass ScreenShotPageOptions(TypedDict):\n    device: str\nclass NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "ScreenShotPageOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class ScreenShotPageOptions(TypedDict):\n    device: str\nclass NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]\n    wait_until: Literal['load', 'domcontentloaded', 'networkidle0', 'networkidle2']\nclass OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "NavigationOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class NavigationOptions(TypedDict, total=False):\n    timeout: Union[int,str]\n    wait_until: Literal['load', 'domcontentloaded', 'networkidle0', 'networkidle2']\nclass OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "OutputOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class OutputOptions(TypedDict):\n    output_type: Literal['pdf', 'screenshot']\nclass DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseSimilarCompanyReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseSimilarCompanyReq(TypedDict, total = False):\n    lead_name: str\n    website_url: str\nclass DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseEnrichLeadReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseEnrichLeadReq(DataverseSimilarCompanyReq, total = False):\n    email: str\nOrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,\n    'street':str,\n    'pincode':str\n}, total=False)",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseLead",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseLead(TypedDict, total = False):\n    organization_name: str\n    description: str\n    employee_count: str\n    revenue: str\n    organization_type: str\n    organization_status: str\n    email: List[str]\n    address: List[str]\n    contact: List[str]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "DataverseTechStack",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "class DataverseTechStack(TypedDict, total = False):\n    organization_name: str\n    website: str\n    website_status: str\n    technographic_data: Dict[str, None]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfFormats",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfFormats = Literal[\n    'Letter', 'Legal', 'Tabloid', 'Ledger',\n    'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6'\n]\nPdfMargin = TypedDict('PdfMargin', {\n    'top': str,\n    'bottom': str,\n    'left': str,\n    'right': str\n}, total=False)",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfMargin",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfMargin = TypedDict('PdfMargin', {\n    'top': str,\n    'bottom': str,\n    'left': str,\n    'right': str\n}, total=False)\nclass PdfOptions(TypedDict, total=False):\n    scale: Union[int,str]\n    display_header_footer: bool\n    header_template: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "CssContent",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "CssContent = TypedDict('CssContent', {\n    'content': str\n})\nCssUrl = TypedDict('CssUrl', {\n    'url': str\n})\nJsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "CssUrl",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "CssUrl = TypedDict('CssUrl', {\n    'url': str\n})\nJsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "JsContent",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "JsContent = TypedDict('JsContent', {\n    'content': str\n})\nJsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "JsUrl",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "JsUrl = TypedDict('JsUrl', {\n    'url': str\n})\nPdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})\nclass PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "PdfViewPort",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "PdfViewPort = TypedDict('PdfViewPort', {\n    \"width\": Union[int,str],\n    \"height\": Union[int,str]\n})\nclass PdfPageOptions(TypedDict, total=False):\n    css: Union[CssContent, CssUrl]\n    js: Union[JsContent, JsUrl] # pylint: disable=invalid-name\n    viewport: PdfViewPort\n    javascript_enabled: bool\nclass ScreenShotOptions(TypedDict, total=False):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "OrgHeadquarters",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "peekOfCode": "OrgHeadquarters = TypedDict('OrgHeadquarters', {\n    'city': str,\n    'country': str,\n    'state': str,\n    'id': str,\n    'street':str,\n    'pincode':str\n}, total=False)\nclass DataverseLead(TypedDict, total = False):\n    organization_name: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.smart_browz",
        "documentation": {}
    },
    {
        "label": "BucketMeta",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class BucketMeta(TypedDict):\n    versioning: bool\n    caching: Cache\n    encryption: bool\n    audit_consent: bool\nclass StratusObjectDetails(TypedDict):\n    key_type: str\n    key: str\n    size: int\n    version_id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectDetails",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectDetails(TypedDict):\n    key_type: str\n    key: str\n    size: int\n    version_id: str\n    etag: str\n    content_type: str\n    last_modified: str\n    object_url: Optional[str]\nclass StratusObjectsRes(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectsRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectsRes(TypedDict):\n    key_count: int\n    max_keys: Optional[int]\n    truncated: str\n    next_continuation_token: Optional[str]\n    contents: List[StratusObjectDetails]\nclass DeleteObjectOptions(TypedDict):\n    key: str\n    version_id: str\nclass StratusBucket(ICatalystGResponse):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "DeleteObjectOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class DeleteObjectOptions(TypedDict):\n    key: str\n    version_id: str\nclass StratusBucket(ICatalystGResponse):\n    bucket_name: str\n    bucket_url: str\n    objects_count: str\n    size_in_bytes: str\n    bucket_meta: BucketMeta\nclass StratusObjectVersion(TypedDict, total = False):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusBucket",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusBucket(ICatalystGResponse):\n    bucket_name: str\n    bucket_url: str\n    objects_count: str\n    size_in_bytes: str\n    bucket_meta: BucketMeta\nclass StratusObjectVersion(TypedDict, total = False):\n    version_id: str\n    is_latest: Optional[bool]\n    last_modified: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusObjectVersion",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusObjectVersion(TypedDict, total = False):\n    version_id: str\n    is_latest: Optional[bool]\n    last_modified: str\n    size: str\n    etag: str\nclass ObjectVersionsRes(TypedDict):\n    key: str\n    versions_count: str\n    next_continuation_token: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "ObjectVersionsRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class ObjectVersionsRes(TypedDict):\n    key: str\n    versions_count: str\n    next_continuation_token: str\n    max_versions: str\n    is_truncated: Optional[bool]\n    version: List[StratusObjectVersion]\nclass BucketCorsResponse(TypedDict):\n    domain: str\n    allowed_methods: List[str]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "BucketCorsResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class BucketCorsResponse(TypedDict):\n    domain: str\n    allowed_methods: List[str]\nclass CopyObjectResponse(TypedDict):\n    key: str\n    copy_to: str\n    message: str\nclass RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "CopyObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class CopyObjectResponse(TypedDict):\n    key: str\n    copy_to: str\n    message: str\nclass RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str\n    message: str\nclass UnzipObjectResponse(TypedDict):\n    key: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "RenameObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class RenameObjectResponse(TypedDict):\n    current_key: str\n    rename_to: str\n    message: str\nclass UnzipObjectResponse(TypedDict):\n    key: str\n    destination: str\n    message: str\n    task_id: str\nclass DeleteObjectPathResponse(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "UnzipObjectResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class UnzipObjectResponse(TypedDict):\n    key: str\n    destination: str\n    message: str\n    task_id: str\nclass DeleteObjectPathResponse(TypedDict):\n    prefix: str\n    message: str\nclass InitiateMultipartUploadResponse(TypedDict):\n    bucket: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "DeleteObjectPathResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class DeleteObjectPathResponse(TypedDict):\n    prefix: str\n    message: str\nclass InitiateMultipartUploadResponse(TypedDict):\n    bucket: str\n    key: str\n    upload_id: int\n    status: str\nclass UploadedObjectPartRes(TypedDict):\n    part_number: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "InitiateMultipartUploadResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class InitiateMultipartUploadResponse(TypedDict):\n    bucket: str\n    key: str\n    upload_id: int\n    status: str\nclass UploadedObjectPartRes(TypedDict):\n    part_number: str\n    size: str\n    upload_at: str\nclass MultipartUploadSummaryRes(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "UploadedObjectPartRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class UploadedObjectPartRes(TypedDict):\n    part_number: str\n    size: str\n    upload_at: str\nclass MultipartUploadSummaryRes(TypedDict):\n    bucket: str\n    key: str\n    upload_id: str\n    parts: List[UploadedObjectPartRes]\nclass StratusSignature(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "MultipartUploadSummaryRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class MultipartUploadSummaryRes(TypedDict):\n    bucket: str\n    key: str\n    upload_id: str\n    parts: List[UploadedObjectPartRes]\nclass StratusSignature(TypedDict):\n    stsPolicy: str\n    stsSignature: str\nclass StratusPutObjectRes(TypedDict):\n    task_id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusSignature",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusSignature(TypedDict):\n    stsPolicy: str\n    stsSignature: str\nclass StratusPutObjectRes(TypedDict):\n    task_id: str\nclass PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusPutObjectRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusPutObjectRes(TypedDict):\n    task_id: str\nclass PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "PutObjectAsPartsOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class PutObjectAsPartsOptions(TypedDict, total=False):\n    overwrite: Optional[Union[str, bool]]\nclass StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusInitiateUploadOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "class StratusInitiateUploadOptions(TypedDict, total=False):\n    overwrite: Union[str, bool]\n    compress: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "Cache",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "Cache = TypedDict('caching', {\n    'status': Union[str, bool]\n})\nStratusUploadOptions = TypedDict('StratusUploadOptions', {\n    'overwrite': Union[str, bool],\n    'ttl': str,\n    'compress': str,\n    'meta_data': Dict[str, str],\n    'content_type': str,\n    'extract_upload': Literal['true', 'false']",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusUploadOptions",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "StratusUploadOptions = TypedDict('StratusUploadOptions', {\n    'overwrite': Union[str, bool],\n    'ttl': str,\n    'compress': str,\n    'meta_data': Dict[str, str],\n    'content_type': str,\n    'extract_upload': Literal['true', 'false']\n}, total= False)\nStratusDownloadOptions = TypedDict('StratusDownloadOptions', {\n    'version_id': str,",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "StratusDownloadOptions",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "description": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "peekOfCode": "StratusDownloadOptions = TypedDict('StratusDownloadOptions', {\n    'version_id': str,\n    'range': str\n}, total= False)\nclass BucketMeta(TypedDict):\n    versioning: bool\n    caching: Cache\n    encryption: bool\n    audit_consent: bool\nclass StratusObjectDetails(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.stratus",
        "documentation": {}
    },
    {
        "label": "ObjectParams",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ObjectParams(TypedDict):\n    co_ordinates: List[int]\n    object_type: str\n    confidence: str\nclass ICatalystZiaObject(TypedDict):\n    object: List[ObjectParams]\nclass ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaObject",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaObject(TypedDict):\n    object: List[ObjectParams]\nclass ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaOCR",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaOCR(TypedDict):\n    confidence: Optional[str]\n    text: str\nclass ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaBarcode",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaBarcode(TypedDict):\n    content: str\nclass ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaModeration",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaModeration(TypedDict):\n    probability: Dict[str, str]\n    confidence: int\n    prediction: str\nclass ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):\n    confidence: int\n    id: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaCom",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaCom(TypedDict):\n    prediction: str\n    confidence: Dict[str, str]\nclass FaceParams(TypedDict):\n    confidence: int\n    id: str\n    co_ordinates: List[int]\n    emotion: ICatalystZiaCom\n    age: ICatalystZiaCom\n    gender: ICatalystZiaCom",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "FaceParams",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class FaceParams(TypedDict):\n    confidence: int\n    id: str\n    co_ordinates: List[int]\n    emotion: ICatalystZiaCom\n    age: ICatalystZiaCom\n    gender: ICatalystZiaCom\n    landmarks: Optional[Dict[str, List[int]]]\nclass ICatalystZiaFace(TypedDict):\n    faces: List[FaceParams]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaFace",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaFace(TypedDict):\n    faces: List[FaceParams]\nclass ICatalystZiaFaceComparison(TypedDict):\n    confidence: Optional[int]\n    matched: bool\nclass ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaFaceComparison",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaFaceComparison(TypedDict):\n    confidence: Optional[int]\n    matched: bool\nclass ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaAutoML",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaAutoML(TypedDict):\n    regression_result: Optional[int]\n    classification_result: Optional[Dict[str, int]]\n# Text analysis response\nclass ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int\n    positive: int\nclass ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ConfidenceScores",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ConfidenceScores(TypedDict):\n    negative: int\n    neutral: int\n    positive: int\nclass ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]\n    confidence_scores: ConfidenceScores\nclass ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaAnalytics",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaAnalytics(TypedDict):\n    sentiment: Literal[\"Positive\", \"Negative\", \"Neutral\"]\n    confidence_scores: ConfidenceScores\nclass ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentenceAnalytics",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentenceAnalytics(ICatalystZiaAnalytics):\n    sentence: str\nclass ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaKeywordAnalytics",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaKeywordAnalytics(ICatalystZiaAnalytics):\n    keyword: str\nclass ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentimentAnalysis",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentimentAnalysis(TypedDict):\n    document_sentiment: str\n    sentence_analytics: List[ICatalystZiaSentenceAnalytics]\n    keyword_analytics: List[ICatalystZiaKeywordAnalytics]\n    overall_score: float\nclass ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaSentimentAnalysisResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaSentimentAnalysisResponse(TypedDict):\n    sentiment_prediction: List[ICatalystZiaSentimentAnalysis]\nclass ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]\nclass ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaExtractedKeywords",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaExtractedKeywords(TypedDict):\n    keywords: List[str]\n    keyphrases: List[str]\nclass ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaKeywordExtractionResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaKeywordExtractionResponse(TypedDict):\n    keyword_extractor: ICatalystZiaExtractedKeywords\nclass ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str\n    token: str\nclass ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNer",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNer(TypedDict):\n    start_index: int\n    confidence_score: int\n    end_index: int\n    ner_tag: str\n    token: str\nclass ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]\nclass ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNerGeneralEntities",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNerGeneralEntities(TypedDict):\n    general_entities: List[ICatalystZiaNer]\nclass ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities\nclass ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaNERPredictionResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaNERPredictionResponse(TypedDict):\n    ner: ICatalystZiaNerGeneralEntities\nclass ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystZiaTextAnalyticsResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.types.zia",
        "description": ".build.functions.students.zcatalyst_sdk.types.zia",
        "peekOfCode": "class ICatalystZiaTextAnalyticsResponse(\n    ICatalystZiaNERPredictionResponse,\n    ICatalystZiaKeywordExtractionResponse,\n    ICatalystZiaSentimentAnalysisResponse,\n):\n    pass",
        "detail": ".build.functions.students.zcatalyst_sdk.types.zia",
        "documentation": {}
    },
    {
        "label": "AcceptHeader",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialUser",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    HEAD = \"HEAD\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "RequestMethod",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class RequestMethod:\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    HEAD = \"HEAD\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"\nclass Components:\n    CACHE = \"Cache\"\n    FILE_STORE = \"FileStore\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "Components",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class Components:\n    CACHE = \"Cache\"\n    FILE_STORE = \"FileStore\"\n    MAIL = \"Mail\"\n    SEARCH = \"Search\"\n    ZCQL = \"ZCQL\"\n    ZIA = \"Zia\"\n    CRON = \"Cron\"\n    DATA_STORE = \"DataStore\"\n    FUNCTION = \"Function\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialType",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialType:\n    token = 'token'\n    ticket = 'ticket'\nclass ProjectHeader:\n    project_id = 'X-ZC-ProjectId'\n    domain = 'X-ZC-Project-Domain'\n    key = 'X-ZC-Project-Key'\n    environment = 'X-ZC-Environment'\n    project_secret_key = 'X-ZC-PROJECT-SECRET-KEY'\nclass CredentialHeader:",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ProjectHeader",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class ProjectHeader:\n    project_id = 'X-ZC-ProjectId'\n    domain = 'X-ZC-Project-Domain'\n    key = 'X-ZC-Project-Key'\n    environment = 'X-ZC-Environment'\n    project_secret_key = 'X-ZC-PROJECT-SECRET-KEY'\nclass CredentialHeader:\n    admin_cred_type = 'X-ZC-Admin-Cred-Type'\n    user_cred_type = 'X-ZC-User-Cred-Type'\n    admin_token = 'X-ZC-Admin-Cred-Token'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CredentialHeader",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class CredentialHeader:\n    admin_cred_type = 'X-ZC-Admin-Cred-Type'\n    user_cred_type = 'X-ZC-User-Cred-Type'\n    admin_token = 'X-ZC-Admin-Cred-Token'\n    user_token = 'X-ZC-User-Cred-Token'\n    cookie = 'x-zc-cookie'\n    zcsrf = 'X-ZCSRF-TOKEN'\n    user = 'X-ZC-User-Type'\n    signature = \"X-ZC-Stratus-Signature\"\nclass CatalystService:",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CatalystService",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "class CatalystService:\n    SERVERLESS = 'baas'\n    BROWSER360 = 'browser360'\n    QUICK_ML = 'quickml'\n    STRATUS = 'stratus'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "env_override",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "def env_override(env_name: str, default_value: str):\n    env_value = os.getenv(env_name)\n    if not env_value:\n        return default_value\n    return env_value\nmeta_file = path.join(path.dirname(path.abspath(__file__)), '__version__.py')\nmeta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "meta_file",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "meta_file = path.join(path.dirname(path.abspath(__file__)), '__version__.py')\nmeta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version\nSDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "meta",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "meta = {}\nwith open(meta_file, encoding=\"utf-8\") as fp:\n    exec(fp.read(), meta) # pylint: disable=exec-used\n# SDK version\nSDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "SDK_VERSION",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "SDK_VERSION = meta['__version__']\n# Json variables\nJSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_KEY",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_KEY = \"data\"\nJSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_STATUS",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_STATUS = \"status\"\nJSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_MESSAGE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_MESSAGE = \"message\"\nJSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JSON_RESPONSE_CODE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "JSON_RESPONSE_CODE = \"error_code\"\nSUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "SUCCESS_STATUS",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "SUCCESS_STATUS = \"success\"\nFAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "FAILURE_STATUS",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "FAILURE_STATUS = \"failure\"\n# Environment Variable\nPROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_KEY",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_KEY = \"project_key\"\nPROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_ID",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_ID = \"project_id\"\nPROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_DOMAIN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_DOMAIN = \"project_domain\"\nENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ENVIRONMENT = \"environment\"\nPROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_SECRET_KEY",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_SECRET_KEY = \"project_secret_key\"\nADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_CRED",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_CRED = \"admin_cred\"\nCLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_CRED",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_CRED = \"client_cred\"\nCOOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE_CRED",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE_CRED = \"cookie_cred\"\nACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ACCESS_TOKEN = \"access_token\"\nCLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_ACCESS_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_ACCESS_TOKEN = \"client_token\"\nCLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_COOKIE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_COOKIE = \"client_cookie\"\nCLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_ID",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_ID = \"client_id\"\nEXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "EXPIRES_IN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "EXPIRES_IN = \"expires_in\"\nREFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_IN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_IN = \"refresh_in\"\nCLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_SECRET",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_SECRET = \"client_secret\"\nAUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "AUTH_URL",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "AUTH_URL = \"auth_url\"\nREFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_URL",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_URL = \"refresh_url\"\nREDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REDIRECT_URL",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "REDIRECT_URL = \"redirect_url\"\nGRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "GRANT_TYPE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "GRANT_TYPE = \"grant_type\"\nCODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CODE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CODE = \"code\"\nTICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "TICKET",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "TICKET = \"ticket\"\nADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_CRED_TYPE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_CRED_TYPE = \"admin_cred_type\"\nCLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_CRED_TYPE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_CRED_TYPE = \"client_cred_type\"\nREFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "REFRESH_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "REFRESH_TOKEN = \"refresh_token\"\nSCOPES=\"scopes\"\nJWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "JWT_TOKEN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "JWT_TOKEN = \"refresh_token\"\nUSER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_TYPE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "USER_TYPE = \"user_type\"\nCONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CONNECTOR_NAME",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CONNECTOR_NAME = \"connector_name\"\nENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ENVIRONMENT_KEY_NAME = \"X-Catalyst-Environment\"\nUSER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "USER_KEY_NAME = \"X-CATALYST-USER\"\nCATALYST_ORG_ID_KEY=\"CATALYST-ORG\"\nX_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "X_CATALYST_ORG_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "X_CATALYST_ORG_ENV_KEY = 'X_ZOHO_CATALYST_ORG_ID'\n# URL constants\nPROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_URL",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_URL = \"project\"\nPROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_KEY_NAME",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "PROJECT_KEY_NAME = \"PROJECT_ID\"\nURL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "URL_SEPARATOR",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "URL_SEPARATOR = \"/\"\nIS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "IS_LOCAL",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "IS_LOCAL = env_override(\"X_ZOHO_CATALYST_IS_LOCAL\", \"False\")\nCSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_TOKEN_COOKIE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_TOKEN_COOKIE = \"ZD_CSRF_TOKEN\"\nAPP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "APP_DOMAIN",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "APP_DOMAIN = env_override(\"X_ZOHO_CATALYST_CONSOLE_URL\", \"https://console.catalyst.localzoho.com\")\nAPP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "APP_VERSION_V1",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "APP_VERSION_V1 = \"/v1\"\nACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ACCOUNTS_URL",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ACCOUNTS_URL = env_override(\"X_ZOHO_CATALYST_ACCOUNTS_URL\", \"https://accounts.localzoho.com\")\nSTRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "STRATUS_SUFFIX",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "STRATUS_SUFFIX = env_override(\"X_ZOHO_STRATUS_RESOURCE_SUFFIX\", \".zohostratus.com\")\n# Header Constants\nCONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CONTENT_TYPE = \"Content-Type\"\nCLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CLIENT_HEADER",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CLIENT_HEADER = \"PROJECT_ID\"\nCOOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE_HEADER",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE_HEADER = \"Cookie\"\nCSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_HEADER",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_HEADER = \"X-ZCSRF-TOKEN\"\nUSER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_AGENT",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "USER_AGENT = \"USER-AGENT\"\n# Auth Constants\nAUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "AUTHORIZATION",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "AUTHORIZATION = \"Authorization\"\nCOOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "COOKIE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "COOKIE = \"cookie\"\nUSER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_SCOPE_HEADER",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "USER_SCOPE_HEADER = \"X-CATALYST-USER\"\nADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ADMIN_SCOPE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ADMIN_SCOPE = \"admin\"\nUSER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "USER_SCOPE",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "USER_SCOPE = \"user\"\nOAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "OAUTH_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "OAUTH_PREFIX = \"Zoho-oauthtoken \"\nTICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "TICKET_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "TICKET_PREFIX = \"Zoho-ticket \"\nCSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "CSRF_PARAM_PREFIX",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "CSRF_PARAM_PREFIX = \"zd_csrparam=\"\nZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "ZAID",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._constants",
        "description": ".build.functions.students.zcatalyst_sdk._constants",
        "peekOfCode": "ZAID = 'zaid'\nclass AcceptHeader:\n    KEY = 'Accept'\n    VALUE = 'application/vnd.catalyst.v2+json'\n    ZCQL = 'application/vnd.catalyst.v2+zcql'\nclass CredentialUser:\n    ADMIN = 'admin'\n    USER = 'user'\nclass RequestMethod:\n    GET = \"GET\"",
        "detail": ".build.functions.students.zcatalyst_sdk._constants",
        "documentation": {}
    },
    {
        "label": "DefaultHttpResponse",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._http_client",
        "description": ".build.functions.students.zcatalyst_sdk._http_client",
        "peekOfCode": "class DefaultHttpResponse:\n    def __init__(self, resp: requests.Response):\n        self._response = resp\n        self._status_code = resp.status_code\n        self._headers = resp.headers\n        self.check_status()\n    @property\n    def response(self):\n        return self._response\n    @property",
        "detail": ".build.functions.students.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "HttpClient",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._http_client",
        "description": ".build.functions.students.zcatalyst_sdk._http_client",
        "peekOfCode": "class HttpClient:\n    def __init__(\n        self,\n        app=None,\n        base_url=None,\n        retries=DEFAULT_RETRY_CONFIG,\n        timeout=DEFAULT_TIMEOUT\n    ):\n        self._session = requests.session()\n        self._timeout = timeout",
        "detail": ".build.functions.students.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "AuthorizedHttpClient",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._http_client",
        "description": ".build.functions.students.zcatalyst_sdk._http_client",
        "peekOfCode": "class AuthorizedHttpClient(HttpClient):\n    temp_credential: JwtTokenCredential = None\n    def __init__(\n        self,\n        app\n    ):\n        super().__init__(app)\n    def request(\n        self,\n        method: str,",
        "detail": ".build.functions.students.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "USERAGENT_HEADER",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._http_client",
        "description": ".build.functions.students.zcatalyst_sdk._http_client",
        "peekOfCode": "USERAGENT_HEADER = {USER_AGENT: \"zc-python-sdk/\" + SDK_VERSION}\n# Default timeout for connect and read operation in seconds\nDEFAULT_TIMEOUT = (60, 30)\nDEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5",
        "detail": ".build.functions.students.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUT",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._http_client",
        "description": ".build.functions.students.zcatalyst_sdk._http_client",
        "peekOfCode": "DEFAULT_TIMEOUT = (60, 30)\nDEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5\n)\nclass DefaultHttpResponse:",
        "detail": ".build.functions.students.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RETRY_CONFIG",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk._http_client",
        "description": ".build.functions.students.zcatalyst_sdk._http_client",
        "peekOfCode": "DEFAULT_RETRY_CONFIG = retry.Retry(\n    connect=2,\n    read=1,\n    status=4,\n    status_forcelist=[500, 502, 503, 504],\n    raise_on_status=False,\n    backoff_factor=0.5\n)\nclass DefaultHttpResponse:\n    def __init__(self, resp: requests.Response):",
        "detail": ".build.functions.students.zcatalyst_sdk._http_client",
        "documentation": {}
    },
    {
        "label": "ZCThreadUtil",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk._thread_util",
        "description": ".build.functions.students.zcatalyst_sdk._thread_util",
        "peekOfCode": "class ZCThreadUtil:\n    def __init__(self) -> None:\n        try:\n            self.__zclocal = getattr(threading.current_thread(), '__zc_local')\n        except AttributeError:\n            setattr(threading.current_thread(), '__zc_local', {})\n            self.__zclocal = getattr(threading.current_thread(), '__zc_local')\n    def get_value(self, key: str):\n        return self.__zclocal.get(key)\n    def put_value(self, key: str, val: Any):",
        "detail": ".build.functions.students.zcatalyst_sdk._thread_util",
        "documentation": {}
    },
    {
        "label": "get_attr",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk._thread_util",
        "description": ".build.functions.students.zcatalyst_sdk._thread_util",
        "peekOfCode": "def get_attr(obj: dict, key: str):\n    if obj.get(key):\n        return obj.get(key)\n    fallback_obj = dict((k.lower(), v) for k, v in obj.items())\n    return fallback_obj.get(key.lower())",
        "detail": ".build.functions.students.zcatalyst_sdk._thread_util",
        "documentation": {}
    },
    {
        "label": "parse_headers_from_request",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk._util",
        "description": ".build.functions.students.zcatalyst_sdk._util",
        "peekOfCode": "def parse_headers_from_request(request):\n    try:\n        if hasattr(request, 'headers'):\n            thread_obj = ZCThreadUtil()\n            thread_obj.put_value(\"catalyst_headers\", dict(request.headers))\n    except Exception as err:\n        raise CatalystAppError(\n            \"Invalid req_obj\",\n            \"Kindly ensure whether the request object is valid\"\n        ) from err",
        "detail": ".build.functions.students.zcatalyst_sdk._util",
        "documentation": {}
    },
    {
        "label": "ICatalystNewUser",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.authentication",
        "description": ".build.functions.students.zcatalyst_sdk.authentication",
        "peekOfCode": "class ICatalystNewUser(ICatalystSignupConfig):\n    user_details: ICatalystUser\nclass Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:\n        resp = self._requester.request(",
        "detail": ".build.functions.students.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "Authentication",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.authentication",
        "description": ".build.functions.students.zcatalyst_sdk.authentication",
        "peekOfCode": "class Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:\n        resp = self._requester.request(\n            method=RequestMethod.GET,\n            path='/project-user/current',",
        "detail": ".build.functions.students.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "UserStatus",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.authentication",
        "description": ".build.functions.students.zcatalyst_sdk.authentication",
        "peekOfCode": "UserStatus = Literal['enable', 'disable']\nclass ICatalystNewUser(ICatalystSignupConfig):\n    user_details: ICatalystUser\nclass Authentication(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.AUTHENTICATION\n    def get_current_user(self) -> ICatalystUser:",
        "detail": ".build.functions.students.zcatalyst_sdk.authentication",
        "documentation": {}
    },
    {
        "label": "CatalystAppOptions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "class CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()\n        if not isinstance(options, dict):\n            raise CatalystAppError(\n                'INVALID_APP_OPTIONS',\n                f'Illegal app option type - {type(options)}. App options must be a instance of dict'\n            )\n        config = CatalystAppOptions.validate_options(options)",
        "detail": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CatalystApp",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "class CatalystApp:\n    def __init__(\n        self,\n        credential: Credential,\n        options: Dict,\n        name: str\n    ):\n        if not name or not isinstance(name, str):\n            raise CatalystAppError(\n                'INVALID_APP_NAME',",
        "detail": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CATALYST_OPTIONS_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "CATALYST_OPTIONS_ENV_KEY = 'CATALYST_OPTIONS'\nCONFIG_MANDATORIES = {\n    APIConstants.PROJECT_ID: (int, str),\n    APIConstants.PROJECT_KEY: (int, str),\n    APIConstants.PROJECT_DOMAIN: (str,)\n}\nDEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:",
        "detail": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "CONFIG_MANDATORIES",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "CONFIG_MANDATORIES = {\n    APIConstants.PROJECT_ID: (int, str),\n    APIConstants.PROJECT_KEY: (int, str),\n    APIConstants.PROJECT_DOMAIN: (str,)\n}\nDEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()",
        "detail": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENVIRONMENT",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "description": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "peekOfCode": "DEFAULT_ENVIRONMENT = \"Development\"\nclass CatalystAppOptions:\n    def __init__(self, options: Dict):\n        if options is None:\n            options = self._load_options_from_env()\n        if not isinstance(options, dict):\n            raise CatalystAppError(\n                'INVALID_APP_OPTIONS',\n                f'Illegal app option type - {type(options)}. App options must be a instance of dict'\n            )",
        "detail": ".build.functions.students.zcatalyst_sdk.catalyst_app",
        "documentation": {}
    },
    {
        "label": "Circuit",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.circuit",
        "description": ".build.functions.students.zcatalyst_sdk.circuit",
        "peekOfCode": "class Circuit(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CIRCUIT\n    def execute(\n        self,\n        circuit_id: Union[int, str],\n        name: str,",
        "detail": ".build.functions.students.zcatalyst_sdk.circuit",
        "documentation": {}
    },
    {
        "label": "Credential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class Credential(ABC):\n    @abstractmethod\n    def token(self):\n        pass\n    def _switch_user(self, user=None):  # pylint: disable=unused-argument\n        return None\n    def current_user(self):\n        return CredentialUser.ADMIN\n    def current_user_type(self):\n        return CredentialUser.ADMIN",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "RefreshTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class RefreshTokenCredential(Credential):\n    def __init__(self, refresh_obj: ICatalystRefreshObj):\n        super().__init__()\n        RefreshTokenCredential._validate_refresh_obj(refresh_obj)\n        self._client_id = refresh_obj.get(APIConstants.CLIENT_ID)\n        self._client_secret = refresh_obj.get(APIConstants.CLIENT_SECRET)\n        self._refresh_token = refresh_obj.get(APIConstants.REFRESH_TOKEN)\n        self._cached_token: Dict[str, Union[str, int]] = None\n    def token(self) -> str:\n        if not self._cached_token or self._cached_token.get('expires_in') <= int(round(time())):",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "JwtTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class JwtTokenCredential:\n    def __init__(self, _app):\n        self.project_key = _app.config.get(PROJECT_KEY)\n        self.project_id = _app.config.get(PROJECT_ID)\n        self.project_domain = _app.config.get(PROJECT_DOMAIN)\n        self._cached_token = None\n    def generate_jwt_token(self, cookie: str, requester) -> ICatalystJwtObj:\n        resp = requester.request(\n                method=RequestMethod.GET,\n                url='https://' + self.project_domain +",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "AccessTokenCredential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class AccessTokenCredential(Credential):\n    def __init__(self, token_obj: ICatalystTokenObj):\n        super().__init__()\n        self._token: str = _get_attr(token_obj, 'access_token')\n    def token(self):\n        return self._token\nclass TicketCredential(Credential):\n    def __init__(self, ticket_obj: ICatalystTicketObj):\n        super().__init__()\n        self._token: str = _get_attr(ticket_obj, 'ticket')",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "TicketCredential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class TicketCredential(Credential):\n    def __init__(self, ticket_obj: ICatalystTicketObj):\n        super().__init__()\n        self._token: str = _get_attr(ticket_obj, 'ticket')\n    def token(self):\n        return self._token\nclass CookieCredential(Credential):\n    def __init__(self, cookie_obj):\n        super().__init__()\n        cookie_str = _get_attr(cookie_obj, 'cookie')",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "CookieCredential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class CookieCredential(Credential):\n    def __init__(self, cookie_obj):\n        super().__init__()\n        cookie_str = _get_attr(cookie_obj, 'cookie')\n        csrf_token: str = ZCThreadUtil().get_value(APIConstants.CSRF_TOKEN_COOKIE)\n        if not csrf_token:\n            cookies_list: List = cookie_str.split(\"; \")\n            for cookie in cookies_list:\n                splitted_cookie: List = cookie.split(\"=\")\n                if splitted_cookie[0] == APIConstants.CSRF_TOKEN_COOKIE:",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "CatalystCredential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class CatalystCredential(Credential):\n    def __init__(self, user: str = None):\n        super().__init__()\n        thread_obj = ZCThreadUtil()\n        self._admin_cred: Union[AccessTokenCredential, TicketCredential] = None\n        self._user_cred: Union[AccessTokenCredential, TicketCredential, CookieCredential] = None\n        self._admin_token: str = thread_obj.get_value(APIConstants.ADMIN_CRED)\n        self._user_token: str = thread_obj.get_value(APIConstants.CLIENT_CRED)\n        self._cookie: str = thread_obj.get_value(APIConstants.COOKIE_CRED)\n        self._admin_cred_type = thread_obj.get_value(APIConstants.ADMIN_CRED_TYPE)",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ApplicationDefaultCredential",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "class ApplicationDefaultCredential(Credential):\n    def __init__(self):\n        super().__init__()\n        self._credential_obj = None\n        self._credential: Union[\n            AccessTokenCredential,\n            TicketCredential,\n            RefreshTokenCredential\n        ] = None\n        # load credentials from environment",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_CATALYST_AUTH_ENV_KEY",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "_CATALYST_AUTH_ENV_KEY = 'CATALYST_AUTH'\n_JWT_TOKEN_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.JWT_TOKEN,\n    APIConstants.SCOPES\n]\n_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_JWT_TOKEN_KEYS",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "_JWT_TOKEN_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.JWT_TOKEN,\n    APIConstants.SCOPES\n]\n_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN\n]",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_REFRESH_OBJ_KEYS",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "_REFRESH_OBJ_KEYS = [\n    APIConstants.CLIENT_ID,\n    APIConstants.CLIENT_SECRET,\n    APIConstants.REFRESH_TOKEN\n]\n_CATALYST_SCOPES = ['admin', 'user']\n_PORTAL_ID=os.getenv('CATALYST_PORTAL_DOMAIN')\nICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "_CATALYST_SCOPES",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "_CATALYST_SCOPES = ['admin', 'user']\n_PORTAL_ID=os.getenv('CATALYST_PORTAL_DOMAIN')\nICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],\n    'jwt_token': str\n})\nICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystJwtObj",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystJwtObj = TypedDict('ICatalystJwtObj', {\n    'client_id': str,\n    'scopes': List[str],\n    'jwt_token': str\n})\nICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,\n    'refresh_token': str\n})",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystRefreshObj",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystRefreshObj = TypedDict('ICatalystRefreshObj', {\n    'client_id': str,\n    'client_secret': str,\n    'refresh_token': str\n})\nICatalystTokenObj = TypedDict('ICatalystTokenObj', {\n    'access_token': str\n})\nICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystTokenObj",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystTokenObj = TypedDict('ICatalystTokenObj', {\n    'access_token': str\n})\nICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str\n})\n# Credential class for all credentials\nclass Credential(ABC):\n    @abstractmethod\n    def token(self):",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystTicketObj",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.credentials",
        "description": ".build.functions.students.zcatalyst_sdk.credentials",
        "peekOfCode": "ICatalystTicketObj = TypedDict('ICatalystTicketObj', {\n    'ticket': str\n})\n# Credential class for all credentials\nclass Credential(ABC):\n    @abstractmethod\n    def token(self):\n        pass\n    def _switch_user(self, user=None):  # pylint: disable=unused-argument\n        return None",
        "detail": ".build.functions.students.zcatalyst_sdk.credentials",
        "documentation": {}
    },
    {
        "label": "ICatalystCronReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.cron",
        "description": ".build.functions.students.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronReq(ICatalystCron):\n    pass\nclass ICatalystCronUpdateReq(ICatalystCron):\n    id: str  # pylint: disable=invalid-name\nclass ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:",
        "detail": ".build.functions.students.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystCronUpdateReq",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.cron",
        "description": ".build.functions.students.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronUpdateReq(ICatalystCron):\n    id: str  # pylint: disable=invalid-name\nclass ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)",
        "detail": ".build.functions.students.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystCronRes",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.cron",
        "description": ".build.functions.students.zcatalyst_sdk.cron",
        "peekOfCode": "class ICatalystCronRes(ICatalystCron, ICatalystGResponse):\n    id: str  # pylint: disable=invalid-name\n    success_count: int\n    failure_count: int\nclass Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CRON",
        "detail": ".build.functions.students.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "Cron",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.cron",
        "description": ".build.functions.students.zcatalyst_sdk.cron",
        "peekOfCode": "class Cron(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.CRON\n    def get_all_cron(self) -> List[ICatalystCronRes]:\n        resp = self._requester.request(\n            method=RequestMethod.GET,\n            path='/cron',",
        "detail": ".build.functions.students.zcatalyst_sdk.cron",
        "documentation": {}
    },
    {
        "label": "ICatalystMailResp",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.email",
        "description": ".build.functions.students.zcatalyst_sdk.email",
        "peekOfCode": "class ICatalystMailResp(ICatalystMail):\n    project_details: Optional[ICatalystProject]\nclass Email(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.MAIL\n    def send_mail(self, mail_obj: ICatalystMail) -> ICatalystMailResp:\n        validator.is_non_empty_dict(mail_obj, 'mail_obj', CatalystMailError)",
        "detail": ".build.functions.students.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "Email",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.email",
        "description": ".build.functions.students.zcatalyst_sdk.email",
        "peekOfCode": "class Email(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.MAIL\n    def send_mail(self, mail_obj: ICatalystMail) -> ICatalystMailResp:\n        validator.is_non_empty_dict(mail_obj, 'mail_obj', CatalystMailError)\n        mail_data = self._generate_data(mail_obj)\n        resp = self._requester.request(",
        "detail": ".build.functions.students.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "_MAIL_OBJ_DICT",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.email",
        "description": ".build.functions.students.zcatalyst_sdk.email",
        "peekOfCode": "_MAIL_OBJ_DICT = {\n    'from_email': str,\n    'to_email': list,\n    'subject': str,\n    'content': str,\n    'cc': list,\n    'bcc': list,\n    'reply_to': list,\n    'html_mode': bool,\n    'display_name': str,",
        "detail": ".build.functions.students.zcatalyst_sdk.email",
        "documentation": {}
    },
    {
        "label": "CatalystError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystError(Exception):\n    def __init__(self, code, message, value=None, status_code = None):\n        self._code = code\n        self._message = message\n        self._http_status_code = status_code\n        self._value = value\n        Exception.__init__(self, self.to_string())\n    @property\n    def code(self):\n        return self._code",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCredentialError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCredentialError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAppError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAppError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAppError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)\n    @property\n    def status_code(self):\n        return self.http_status_code",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAPIError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAPIError(CatalystError):\n    def __init__(self, code, message, value=None, http_status_code=None):\n        self.http_status_code = http_status_code\n        CatalystError.__init__(self, code, message, value, self.http_status_code)\n    @property\n    def status_code(self):\n        return self.http_status_code\nclass CatalystCacheError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCacheError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCacheError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDatastoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystDatastoreError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystDatastoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystFunctionError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystFunctionError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystMailError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystMailError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystFilestoreError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystFilestoreError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystAuthenticationError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystAuthenticationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystZCQLError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystZCQLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCronError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCronError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystCircuitError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystCircuitError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystConnectorError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystConnectorError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystPushNotificationError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystPushNotificationError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystSearchError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystSearchError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystZiaError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystZiaError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "BrowserLogicError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class BrowserLogicError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "QuickMLError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class QuickMLError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystStratusError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystStratusError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystPipelineError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystPipelineError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystNoSqlError",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystNoSqlError(CatalystError):\n    def __init__(self, code, message, value=None):\n        CatalystError.__init__(self, code, message, value)\nclass CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "CatalystDeprecationWarning",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.exceptions",
        "description": ".build.functions.students.zcatalyst_sdk.exceptions",
        "peekOfCode": "class CatalystDeprecationWarning(Warning):\n    pass",
        "detail": ".build.functions.students.zcatalyst_sdk.exceptions",
        "documentation": {}
    },
    {
        "label": "Functions",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.functions",
        "description": ".build.functions.students.zcatalyst_sdk.functions",
        "peekOfCode": "class Functions(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.FUNCTION\n    def execute(self, func_id: Union[str, int], args: Dict = None):\n        validator.is_non_empty_string_or_number(func_id, 'func_id', CatalystFunctionError)\n        if args is not None and not isinstance(args, dict):\n            raise CatalystFunctionError(",
        "detail": ".build.functions.students.zcatalyst_sdk.functions",
        "documentation": {}
    },
    {
        "label": "LogLevel",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.logger",
        "description": ".build.functions.students.zcatalyst_sdk.logger",
        "peekOfCode": "class LogLevel:\n    DEBUG = 10\n    INFO = 20\n    WARNING = 30\n    ERROR = 40\n    CRITICAL = 50\n    LEVELS = {\n        DEBUG: 'DEBUG',\n        INFO: 'INFO',\n        WARNING: 'WARNING',",
        "detail": ".build.functions.students.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.logger",
        "description": ".build.functions.students.zcatalyst_sdk.logger",
        "peekOfCode": "class Logger:\n    def __init__(self,\n        name: str = None,\n        log_level=LogLevel.WARNING,\n        log_format='{timestamp} [{level}] {message}'\n    ):\n        self.name = name\n        self.log_level = log_level\n        self.log_format = log_format\n    def set_level(self, level: int):",
        "detail": ".build.functions.students.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.logger",
        "description": ".build.functions.students.zcatalyst_sdk.logger",
        "peekOfCode": "def get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.students.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "_global_logger",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.logger",
        "description": ".build.functions.students.zcatalyst_sdk.logger",
        "peekOfCode": "_global_logger = Logger()\n_logger_registry = {}\ndef get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.students.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "_logger_registry",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.logger",
        "description": ".build.functions.students.zcatalyst_sdk.logger",
        "peekOfCode": "_logger_registry = {}\ndef get_logger(name: str = None):\n    if name is None:\n        return _global_logger\n    if name not in _logger_registry:\n        _logger_registry[name] = Logger(name)\n    return _logger_registry[name]",
        "detail": ".build.functions.students.zcatalyst_sdk.logger",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.pipeline",
        "description": ".build.functions.students.zcatalyst_sdk.pipeline",
        "peekOfCode": "class Pipeline(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.PIPELINE\n    def get_pipeline_details(self, pipeline_id: str) -> PipelineDetails:\n        \"\"\"Get the details of the pipelines.\n        Args:\n            pipeline_id (str): Id to get the details of the pipeline.",
        "detail": ".build.functions.students.zcatalyst_sdk.pipeline",
        "documentation": {}
    },
    {
        "label": "QuickML",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.quick_ml",
        "description": ".build.functions.students.zcatalyst_sdk.quick_ml",
        "peekOfCode": "class QuickML(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.QUICK_ML\n    def predict(\n        self,\n        end_point_key: str,\n        input_data: Dict[str,Union[str, int]]",
        "detail": ".build.functions.students.zcatalyst_sdk.quick_ml",
        "documentation": {}
    },
    {
        "label": "Search",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.search",
        "description": ".build.functions.students.zcatalyst_sdk.search",
        "peekOfCode": "class Search(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.SEARCH\n    def execute_search_query(\n        self,\n        query: ICatalystSearchQuery\n    ) -> Dict[str, List[Dict[str, Any]]]:",
        "detail": ".build.functions.students.zcatalyst_sdk.search",
        "documentation": {}
    },
    {
        "label": "SmartBrowz",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.smart_browz",
        "description": ".build.functions.students.zcatalyst_sdk.smart_browz",
        "peekOfCode": "class SmartBrowz(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.SMART_BROWZ\n    def convert_to_pdf(\n        self,\n        source: str,\n        pdf_options: PdfOptions  = None,",
        "detail": ".build.functions.students.zcatalyst_sdk.smart_browz",
        "documentation": {}
    },
    {
        "label": "is_valid_email",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_valid_email(email):\n    \"\"\"\n    validates the given value is a email\n    Args:\n        email: The value to validate.\n    Returns:\n        bool: Whether the value is a valid email or not.\n    \"\"\"\n    regex = r'^[^@]+@[^@]+$'\n    if re.fullmatch(regex, email):",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_bool",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_bool(value):\n    \"\"\"\n    validates the given value is a boolean\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a boolean or not.\n    \"\"\"\n    return isinstance(value, bool)\ndef _is_number(value):",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_string",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_string(value):\n    \"\"\"\n    validates the given value is a string\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a string or not.\n    \"\"\"\n    return isinstance(value, str)\ndef is_list(value):",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_list",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_list(value):\n    \"\"\"\n    validates the given value is a list\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a list or not.\n    \"\"\"\n    return isinstance(value, list)\ndef is_dict(value):",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_dict",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_dict(value):\n    \"\"\"\n    validates the given value is a dict\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a dict or not.\n    \"\"\"\n    return isinstance(value, dict)\ndef is_set(value):",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_set",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_set(value):\n    \"\"\"\n    validates the given value is a set\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a set or not.\n    \"\"\"\n    return isinstance(value, set)\ndef is_tuple(value):",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_tuple",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_tuple(value):\n    \"\"\"\n    validates the given value is a tuple\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a tuple or not.\n    \"\"\"\n    return isinstance(value, tuple)\ndef is_buffered_reader(value):",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_buffered_reader",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_buffered_reader(value):\n    \"\"\"\n    validates the given value is a buffered reader or not\n    Args:\n        value: The value to validate.\n    Returns:\n        bool: Whether the value is a buffered reader or not.\n    \"\"\"\n    return isinstance(value, BufferedReader)\ndef is_non_empty_string(",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_string",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_string(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty string\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_string_or_number",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_string_or_number(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty string or number\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_parsable_number",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_parsable_number(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a parsable number\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_parsable_integer",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_parsable_integer(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a parsable integer\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_list",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_list(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty list\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_tuple",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_tuple(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty tuple\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_non_empty_dict",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_non_empty_dict(\n    value,\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates the given value is a non-empty dict\n    Args:\n        value: The value to validate.\n        attr_name: The name of the value to use in error.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_keys_present",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_keys_present(\n    obj: dict,\n    keys: List[str],\n    attr_name: Optional[str] = None,\n    exception: Optional[Type[Exception]] = None\n):\n    \"\"\"\n    validates a dict has given keys. Note: single level\n    Args:\n        obj: The obj to validate.",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_deprecated_key_present",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_deprecated_key_present(\n    obj: dict,\n    depkey: str,\n    actkey: Optional[str] = None,\n    delet : bool = False,\n    warn: bool = False\n):\n    \"\"\"\n    validates a dict has deprecated key. Note: single level\n    Args:",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "is_valid_url",
        "kind": 2,
        "importPath": ".build.functions.students.zcatalyst_sdk.validator",
        "description": ".build.functions.students.zcatalyst_sdk.validator",
        "peekOfCode": "def is_valid_url(url):\n    \"\"\"\n    validates the given value is a valid url\n    Args:\n        email: The value to validate.\n    Returns:\n        bool: Whether the value is a valid url or not.\n    \"\"\"\n    regex = \"\"\"^https?:\\\\/\\\\/(?:www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\n            \\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)$\"\"\"",
        "detail": ".build.functions.students.zcatalyst_sdk.validator",
        "documentation": {}
    },
    {
        "label": "Zcql",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.zcql",
        "description": ".build.functions.students.zcatalyst_sdk.zcql",
        "peekOfCode": "class Zcql(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.ZCQL\n    def execute_query(self, query: str) -> List[ZcqlQueryOutput]:\n        if not query or not isinstance(query, str):\n            raise CatalystZCQLError(\n                'INVALID_QUERY',",
        "detail": ".build.functions.students.zcatalyst_sdk.zcql",
        "documentation": {}
    },
    {
        "label": "ZcqlQueryOutput",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.zcql",
        "description": ".build.functions.students.zcatalyst_sdk.zcql",
        "peekOfCode": "ZcqlQueryOutput = TypedDict('ZcqlQueryOutput', {'table_name': Dict})\nclass Zcql(Component):\n    def __init__(self, app) -> None:\n        self._app = app\n        self._requester = AuthorizedHttpClient(self._app)\n    def get_component_name(self):\n        return Components.ZCQL\n    def execute_query(self, query: str) -> List[ZcqlQueryOutput]:\n        if not query or not isinstance(query, str):\n            raise CatalystZCQLError(",
        "detail": ".build.functions.students.zcatalyst_sdk.zcql",
        "documentation": {}
    },
    {
        "label": "Zia",
        "kind": 6,
        "importPath": ".build.functions.students.zcatalyst_sdk.zia",
        "description": ".build.functions.students.zcatalyst_sdk.zia",
        "peekOfCode": "class Zia(Component):\n    def __init__(self, app):\n        self._app = app\n        self._requester = AuthorizedHttpClient(app)\n    def get_component_name(self):\n        return Components.ZIA\n    def detect_object(self, file: BufferedReader) -> ICatalystZiaObject:\n        self._is_valid_file_type(file)\n        resp = self._requester.request(\n            method=RequestMethod.POST,",
        "detail": ".build.functions.students.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystOCROptions",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.zia",
        "description": ".build.functions.students.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystOCROptions = TypedDict(\n    \"ICatalystOCROptions\",\n    {\"language\": Optional[str], \"model_type\": Optional[str]},\n    total=False,\n)\nICatalystBarCodeOptions = TypedDict(\n    \"ICatalystBarCodeOptions\", {\"format\": Optional[str]}\n)\nICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}",
        "detail": ".build.functions.students.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystBarCodeOptions",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.zia",
        "description": ".build.functions.students.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystBarCodeOptions = TypedDict(\n    \"ICatalystBarCodeOptions\", {\"format\": Optional[str]}\n)\nICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}\n)\nICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],",
        "detail": ".build.functions.students.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystImageModerationOpts",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.zia",
        "description": ".build.functions.students.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystImageModerationOpts = TypedDict(\n    \"ICatalystImageModerationOpt\", {\"mode\": Optional[str]}\n)\nICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],\n        \"emotion\": Optional[bool],\n        \"age\": Optional[bool],\n        \"gender\": Optional[bool],",
        "detail": ".build.functions.students.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "ICatalystFaceAnalysisOptions",
        "kind": 5,
        "importPath": ".build.functions.students.zcatalyst_sdk.zia",
        "description": ".build.functions.students.zcatalyst_sdk.zia",
        "peekOfCode": "ICatalystFaceAnalysisOptions = TypedDict(\n    \"ICatalystFaceAnalysisOptions\",\n    {\n        \"mode\": Optional[str],\n        \"emotion\": Optional[bool],\n        \"age\": Optional[bool],\n        \"gender\": Optional[bool],\n    },\n    total=False,\n)",
        "detail": ".build.functions.students.zcatalyst_sdk.zia",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": ".build.functions.students.main",
        "description": ".build.functions.students.main",
        "peekOfCode": "def handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()\n            student = body.get('student')\n            if not student:\n                return make_response(jsonify({",
        "detail": ".build.functions.students.main",
        "documentation": {}
    },
    {
        "label": "tableName",
        "kind": 5,
        "importPath": ".build.functions.students.main",
        "description": ".build.functions.students.main",
        "peekOfCode": "tableName = \"students\"\ncolumnName_1 = \"student_name\"\ncolumnName_2 = \"account_number\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()",
        "detail": ".build.functions.students.main",
        "documentation": {}
    },
    {
        "label": "columnName_1",
        "kind": 5,
        "importPath": ".build.functions.students.main",
        "description": ".build.functions.students.main",
        "peekOfCode": "columnName_1 = \"student_name\"\ncolumnName_2 = \"account_number\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()\n            student = body.get('student')",
        "detail": ".build.functions.students.main",
        "documentation": {}
    },
    {
        "label": "columnName_2",
        "kind": 5,
        "importPath": ".build.functions.students.main",
        "description": ".build.functions.students.main",
        "peekOfCode": "columnName_2 = \"account_number\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()\n            student = body.get('student')\n            if not student:",
        "detail": ".build.functions.students.main",
        "documentation": {}
    },
    {
        "label": "_Sentinel",
        "kind": 6,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "class _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(\n            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)\n        )\nelif sys.version_info >= (3, 9):",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_ExtensionsSpecialForm",
        "kind": 6,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):\n    def __repr__(self):\n        return 'typing_extensions.' + self._name\nFinal = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.\n    # See https://bugs.python.org/issue46342",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_DefaultMixin",
        "kind": 6,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "class _DefaultMixin:\n    \"\"\"Mixin for TypeVarLike defaults.\"\"\"\n    __slots__ = ()\n    __init__ = _set_default\n# Classes using this metaclass must provide a _backported_typevarlike ClassVar\nclass _TypeVarLikeMeta(type):\n    def __instancecheck__(cls, __instance: Any) -> bool:\n        return isinstance(__instance, cls._backported_typevarlike)\nif _PEP_696_IMPLEMENTED:\n    from typing import TypeVar",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_TypeVarLikeMeta",
        "kind": 6,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "class _TypeVarLikeMeta(type):\n    def __instancecheck__(cls, __instance: Any) -> bool:\n        return isinstance(__instance, cls._backported_typevarlike)\nif _PEP_696_IMPLEMENTED:\n    from typing import TypeVar\nelse:\n    # Add default and infer_variance parameters from PEP 696 and 695\n    class TypeVar(metaclass=_TypeVarLikeMeta):\n        \"\"\"Type variable.\"\"\"\n        _backported_typevarlike = typing.TypeVar",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_SpecialForm",
        "kind": 6,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "class _SpecialForm(typing._Final, _root=True):\n    __slots__ = ('_name', '__doc__', '_getitem')\n    def __init__(self, getitem):\n        self._getitem = getitem\n        self._name = getitem.__name__\n        self.__doc__ = getitem.__doc__\n    def __getattr__(self, item):\n        if item in {'__name__', '__qualname__'}:\n            return self._name\n        raise AttributeError(item)",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "IntVar",
        "kind": 2,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "def IntVar(name):\n    return typing.TypeVar(name)\n# A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8\nif sys.version_info >= (3, 10, 1):\n    Literal = typing.Literal\nelse:\n    def _flatten_literal_params(parameters):\n        \"\"\"An internal helper for Literal creation: flatten Literals among parameters\"\"\"\n        params = []\n        for p in parameters:",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "__all__ = [\n    # Super-special typing primitives.\n    'Any',\n    'ClassVar',\n    'Concatenate',\n    'Final',\n    'LiteralString',\n    'ParamSpec',\n    'ParamSpecArgs',\n    'ParamSpecKwargs',",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "PEP_560",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "PEP_560 = True\nGenericMeta = type\n_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "GenericMeta",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "GenericMeta = type\n_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PEP_696_IMPLEMENTED",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, \"beta\")\n# The functions below are modified copies of typing internal helpers.\n# They are needed by _ProtocolMeta and they provide support for PEP 646.\nclass _Sentinel:\n    def __repr__(self):\n        return \"<sentinel>\"\n_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_marker",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_marker = _Sentinel()\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(\n            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)\n        )\nelif sys.version_info >= (3, 9):\n    def _should_collect_from_parameters(t):\n        return isinstance(t, (typing._GenericAlias, _types.GenericAlias))\nelse:",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "NoReturn = typing.NoReturn\n# Some unconstrained type variables.  These are used by the container types.\n# (These are not for export.)\nT = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "T = typing.TypeVar('T')  # Any type.\nKT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "KT",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "KT = typing.TypeVar('KT')  # Key type.\nVT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "VT",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "VT = typing.TypeVar('VT')  # Value type.\nT_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_co",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "T_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.\nT_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "T_contra",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "T_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\nif sys.version_info >= (3, 11):\n    from typing import Any\nelse:\n    class _AnyMeta(type):\n        def __instancecheck__(self, obj):\n            if self is Any:\n                raise TypeError(\"typing_extensions.Any cannot be used with isinstance()\")\n            return super().__instancecheck__(obj)\n        def __repr__(self):",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "ClassVar = typing.ClassVar\nclass _ExtensionsSpecialForm(typing._SpecialForm, _root=True):\n    def __repr__(self):\n        return 'typing_extensions.' + self._name\nFinal = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Final",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Final = typing.Final\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    # @final exists in 3.8+, but we backport it for all versions\n    # before 3.11 to keep support for the __final__ attribute.\n    # See https://bugs.python.org/issue46342\n    def final(f):\n        \"\"\"This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_overload_dummy",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_overload_dummy = typing._overload_dummy\nif hasattr(typing, \"get_overloads\"):  # 3.11+\n    overload = typing.overload\n    get_overloads = typing.get_overloads\n    clear_overloads = typing.clear_overloads\nelse:\n    # {module: {qualname: {firstlineno: func}}}\n    _overload_registry = collections.defaultdict(\n        functools.partial(collections.defaultdict, dict)\n    )",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Type",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Type = typing.Type\n# Various ABCs mimicking those in collections.abc.\n# A few are simply re-exported for completeness.\nAwaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Awaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Coroutine",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Coroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterable",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "AsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "AsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Deque",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Deque = typing.Deque\nDefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "DefaultDict = typing.DefaultDict\nOrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "OrderedDict = typing.OrderedDict\nCounter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Counter",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Counter = typing.Counter\nChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "ChainMap = typing.ChainMap\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Text",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Text = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(\n        typing, \"_SpecialGenericAlias\", typing._GenericAlias",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "TYPE_CHECKING = typing.TYPE_CHECKING\nif sys.version_info >= (3, 13, 0, \"beta\"):\n    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator\nelse:\n    def _is_dunder(attr):\n        return attr.startswith('__') and attr.endswith('__')\n    # Python <3.9 doesn't have typing._SpecialGenericAlias\n    _special_generic_alias_base = getattr(\n        typing, \"_SpecialGenericAlias\", typing._GenericAlias\n    )",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PROTO_ALLOWLIST",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_PROTO_ALLOWLIST = {\n    'collections.abc': [\n        'Callable', 'Awaitable', 'Iterable', 'Iterator', 'AsyncIterable',\n        'Hashable', 'Sized', 'Container', 'Collection', 'Reversible', 'Buffer',\n    ],\n    'contextlib': ['AbstractContextManager', 'AbstractAsyncContextManager'],\n    'typing_extensions': ['Buffer'],\n}\n_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {\n    \"__match_args__\", \"__protocol_attrs__\", \"__non_callable_proto_members__\",",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_EXCLUDED_ATTRS",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {\n    \"__match_args__\", \"__protocol_attrs__\", \"__non_callable_proto_members__\",\n    \"__final__\",\n}\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object\n        if base.__name__ in {'Protocol', 'Generic'}:\n            continue\n        annotations = getattr(base, '__annotations__', {})",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "runtime",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "runtime = runtime_checkable\n# Our version of runtime-checkable protocols is faster on Python 3.8-3.11\nif sys.version_info >= (3, 12):\n    SupportsInt = typing.SupportsInt\n    SupportsFloat = typing.SupportsFloat\n    SupportsComplex = typing.SupportsComplex\n    SupportsBytes = typing.SupportsBytes\n    SupportsIndex = typing.SupportsIndex\n    SupportsAbs = typing.SupportsAbs\n    SupportsRound = typing.SupportsRound",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_PEP_728_IMPLEMENTED",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_PEP_728_IMPLEMENTED = False\nif _PEP_728_IMPLEMENTED:\n    # The standard library TypedDict in Python 3.8 does not store runtime information\n    # about which (if any) keys are optional.  See https://bugs.python.org/issue38834\n    # The standard library TypedDict in Python 3.9.0/1 does not honour the \"total\"\n    # keyword with old-style TypedDict().  See https://bugs.python.org/issue42059\n    # The standard library TypedDict below Python 3.11 does not store runtime\n    # information about optional and required keys when using Required or NotRequired.\n    # Generic TypedDicts are also impossible using typing.TypedDict on Python <3.11.\n    # Aaaand on 3.12 we add __orig_bases__ to TypedDict",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_UNPACK_DOC",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_UNPACK_DOC = \"\"\"\\\nType unpack operator.\nThe type unpack operator takes the child types from some container type,\nsuch as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For\nexample:\n  # For some generic class `Foo`:\n  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]\n  Ts = TypeVarTuple('Ts')\n  # Specifies that `Bar` is generic in an arbitrary number of types.\n  # (Think of `Ts` as a tuple of an arbitrary number of individual",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_TYPEVARTUPLE_TYPES",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_TYPEVARTUPLE_TYPES = {TypeVarTuple, getattr(typing, \"TypeVarTuple\", None)}\ndef _is_unpacked_typevartuple(x) -> bool:\n    if get_origin(x) is not Unpack:\n        return False\n    args = get_args(x)\n    return (\n        bool(args)\n        and len(args) == 1\n        and type(args[0]) in _TYPEVARTUPLE_TYPES\n    )",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "_CapsuleType",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "_CapsuleType = getattr(_types, \"CapsuleType\", None)\nif _CapsuleType is None:\n    try:\n        import _socket\n    except ImportError:\n        pass\n    else:\n        _CAPI = getattr(_socket, \"CAPI\", None)\n        if _CAPI is not None:\n            _CapsuleType = type(_CAPI)",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "AbstractSet = typing.AbstractSet\nAnyStr = typing.AnyStr\nBinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "AnyStr = typing.AnyStr\nBinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "BinaryIO = typing.BinaryIO\nCallable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Callable",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Callable = typing.Callable\nCollection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Collection",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Collection = typing.Collection\nContainer = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Container = typing.Container\nDict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Dict = typing.Dict\nForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ForwardRef",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "ForwardRef = typing.ForwardRef\nFrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "FrozenSet = typing.FrozenSet\nGeneric = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Generic",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Generic = typing.Generic\nHashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Hashable",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Hashable = typing.Hashable\nIO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "IO",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "IO = typing.IO\nItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ItemsView",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "ItemsView = typing.ItemsView\nIterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Iterable = typing.Iterable\nIterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Iterator = typing.Iterator\nKeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "KeysView",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "KeysView = typing.KeysView\nList = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "List = typing.List\nMapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Mapping = typing.Mapping\nMappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MappingView",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "MappingView = typing.MappingView\nMatch = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Match = typing.Match\nMutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "MutableMapping = typing.MutableMapping\nMutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "MutableSequence = typing.MutableSequence\nMutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "MutableSet = typing.MutableSet\nOptional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Optional",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Optional = typing.Optional\nPattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Pattern = typing.Pattern\nReversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Reversible",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Reversible = typing.Reversible\nSequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Sequence = typing.Sequence\nSet = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Set = typing.Set\nSized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Sized",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Sized = typing.Sized\nTextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "TextIO = typing.TextIO\nTuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Tuple = typing.Tuple\nUnion = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "Union",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "Union = typing.Union\nValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "ValuesView = typing.ValuesView\ncast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "cast",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "cast = typing.cast\nno_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "no_type_check",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "no_type_check = typing.no_type_check\nno_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "no_type_check_decorator",
        "kind": 5,
        "importPath": ".build.functions.students.typing_extensions",
        "description": ".build.functions.students.typing_extensions",
        "peekOfCode": "no_type_check_decorator = typing.no_type_check_decorator",
        "detail": ".build.functions.students.typing_extensions",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": "functions.exams.main",
        "description": "functions.exams.main",
        "peekOfCode": "def handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")\n            if not exam:\n                return make_response(jsonify({\n                    \"error\": \"exam object missing\"",
        "detail": "functions.exams.main",
        "documentation": {}
    },
    {
        "label": "EXAMS_TABLE",
        "kind": 5,
        "importPath": "functions.exams.main",
        "description": "functions.exams.main",
        "peekOfCode": "EXAMS_TABLE = \"exams\"\nRESULTS_TABLE = \"exam_results\"\nSTUDENTS_TABLE = \"students\"\nYELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":",
        "detail": "functions.exams.main",
        "documentation": {}
    },
    {
        "label": "RESULTS_TABLE",
        "kind": 5,
        "importPath": "functions.exams.main",
        "description": "functions.exams.main",
        "peekOfCode": "RESULTS_TABLE = \"exam_results\"\nSTUDENTS_TABLE = \"students\"\nYELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()",
        "detail": "functions.exams.main",
        "documentation": {}
    },
    {
        "label": "STUDENTS_TABLE",
        "kind": 5,
        "importPath": "functions.exams.main",
        "description": "functions.exams.main",
        "peekOfCode": "STUDENTS_TABLE = \"students\"\nYELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")",
        "detail": "functions.exams.main",
        "documentation": {}
    },
    {
        "label": "YELLOW",
        "kind": 5,
        "importPath": "functions.exams.main",
        "description": "functions.exams.main",
        "peekOfCode": "YELLOW = \"\\u001b[33m\"\nRESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")\n            if not exam:",
        "detail": "functions.exams.main",
        "documentation": {}
    },
    {
        "label": "RESET",
        "kind": 5,
        "importPath": "functions.exams.main",
        "description": "functions.exams.main",
        "peekOfCode": "RESET = \"\\u001b[0m\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        # ----------------------------- conduct exam -----------------------------\n        if request.path == \"/addExam\" and request.method == \"POST\":\n            body = request.get_json()\n            exam = body.get(\"exam\")\n            if not exam:\n                return make_response(jsonify({",
        "detail": "functions.exams.main",
        "documentation": {}
    },
    {
        "label": "getSchoolForLogin",
        "kind": 2,
        "importPath": "functions.school.main",
        "description": "functions.school.main",
        "peekOfCode": "def getSchoolForLogin(id, password, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_id = '{id}' AND school_password = '{password}'\"\n    output = zcql_service.execute_query(query)\n    return output\ndef getSchoolForSignUp(name, address, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_name = '{name}' AND school_address = '{address}'\"\n    output = zcql_service.execute_query(query)\n    return output",
        "detail": "functions.school.main",
        "documentation": {}
    },
    {
        "label": "getSchoolForSignUp",
        "kind": 2,
        "importPath": "functions.school.main",
        "description": "functions.school.main",
        "peekOfCode": "def getSchoolForSignUp(name, address, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_name = '{name}' AND school_address = '{address}'\"\n    output = zcql_service.execute_query(query)\n    return output\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        body = request.get_json()\n        school = body.get('school')",
        "detail": "functions.school.main",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": "functions.school.main",
        "description": "functions.school.main",
        "peekOfCode": "def handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        body = request.get_json()\n        school = body.get('school')\n        print(school)\n        if not school:\n            return make_response(jsonify({\n                \"error\": \"school object is missing\"\n            }), 400)",
        "detail": "functions.school.main",
        "documentation": {}
    },
    {
        "label": "tableName",
        "kind": 5,
        "importPath": "functions.school.main",
        "description": "functions.school.main",
        "peekOfCode": "tableName = \"schools\"\ndef getSchoolForLogin(id, password, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_id = '{id}' AND school_password = '{password}'\"\n    output = zcql_service.execute_query(query)\n    return output\ndef getSchoolForSignUp(name, address, app):\n    zcql_service = app.zcql()\n    query = f\"SELECT * FROM schools WHERE school_name = '{name}' AND school_address = '{address}'\"\n    output = zcql_service.execute_query(query)",
        "detail": "functions.school.main",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 2,
        "importPath": "functions.students.main",
        "description": "functions.students.main",
        "peekOfCode": "def handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()\n            student = body.get('student')\n            if not student:\n                return make_response(jsonify({",
        "detail": "functions.students.main",
        "documentation": {}
    },
    {
        "label": "tableName",
        "kind": 5,
        "importPath": "functions.students.main",
        "description": "functions.students.main",
        "peekOfCode": "tableName = \"students\"\ncolumnName_1 = \"student_name\"\ncolumnName_2 = \"account_number\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()",
        "detail": "functions.students.main",
        "documentation": {}
    },
    {
        "label": "columnName_1",
        "kind": 5,
        "importPath": "functions.students.main",
        "description": "functions.students.main",
        "peekOfCode": "columnName_1 = \"student_name\"\ncolumnName_2 = \"account_number\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()\n            student = body.get('student')",
        "detail": "functions.students.main",
        "documentation": {}
    },
    {
        "label": "columnName_2",
        "kind": 5,
        "importPath": "functions.students.main",
        "description": "functions.students.main",
        "peekOfCode": "columnName_2 = \"account_number\"\ndef handler(request: Request):\n    try:\n        app = zcatalyst_sdk.initialize()\n        zcql = app.zcql()\n    # --------------------------- add students ---------------------------\n        if request.path == \"/addStudent\" and request.method == 'POST':\n            body = request.get_json()\n            student = body.get('student')\n            if not student:",
        "detail": "functions.students.main",
        "documentation": {}
    }
]